## 중요하지만 헷갈리는 리액트 개념

프레임워크나 라이브러리를 온전히 이해하지 못한 채로 프로젝트를 시작하면 기술 부채가 늘어난다. 어설프게 알고 있던 내용이 있다면 이 기회에 확실히 이해하자.

### 상탯값과 속성값으로 관리하는 UI 데이터

UI 라이브러리인 리액트는 UI 데이터를 관리하는 방법을 제공한다. UI 데이터는 컴포넌트 내부에서 관리되는 상탯값과 부모 컴포넌트에서 내려 주는 속성값으로 구성된다. 리덕스와 같이 전역 데이터를 관리해 주는 라이브러리를 리액트에 적용할 때도 결국에는 컴포넌트의 상탯값과 속성값을 이용해서 구현한다.

UI 데이터가 변경되면 화면을 다시 그려야 하낟. 리액트와 같은 UI 라이브러리를 사용하지 않는다면 UI 데이터가 변경될 때마다 돔 요소를 직접 수정해야 한다. 그런데 돔 요소를 직접 수정하다 봄녀 비즈니스 로직과 UI를 수정하는 코드가 뒤섞여지고, 코드가 복잡해진다. 그래서 리액트는 화면을 그리는 모든 코드를 컴포넌트 함수에 선언형으로 작성하도록 했다. UI 데이터가 변경되면 리액트가 컴포넌트 함수를 이용해서 화면을 자동으로 갱신해 주며, 이것이 리액트의 가장 중요한 역할이다. 

#### 리액트를 사용한 코드의 특징

리액트 코드와 리액트를 사용하지 않은 코드를 비교해 보면서 리액트의 특징을 살펴보자. 다음은 리액트와 같은 라이브러리를 사용하지 않고 직접 UI를 관리하는 코드다. 할 일 목록을 추가하거나 삭제할 수 있는 간단한 프로그램이다. 

```html
<html>
	<body>
    	<div class="todo">
        	<h3>할 일 목록</h3>
            <ul class="list"></ul>
            <input class="desc" type="text" />
            <button onClick="onAdd()">추가</button>
            <button onClick="onSaveToServer()">서버에 저장</button>
        </div>
        <script>
        	let currentId = 1;
            const todoList = [];
            function onAdd() {
                const inputEl = document.querySelector('.todo .desc');
                const todo = { id: currentId, desc: inputEl.value };
                todoList.push(todo);
                currentId += 1;
                const elemList = document.querySelector('.todo .list');
                const liEl = makeTodoElement(todo);
                elemList.appendChild(liEl);
            }
            function makeTodoElement(todo) {
                const liEl = document.createElement('li');
                const spanEl = document.createElement('span');
                const buttonEl = document.createElement('button');
                spanEl.innerHTML = todo.desc;
                buttonEl.innerHTML = '삭제';
                buttonEl.dataset.id = todo.id;
                liEl.appendChild(spanEl);
                liEl.appendChild(buttonEl);
                return liEl;
            }
            function onDelete(e) {
                const id = Number(e.target.dataset.id);
                const index = todoList.findIndex(item => item.id === id);
                if (index >= 0) {
                    todoList.splice(index, 1);
                    conse elemList = document.querySelector('.todo .list');
                    const liEl = e.target.parentNode;
                    elem.removeChild(liEl);
                }
            }
            function onSaveToServer() {
                // todoList 전송
            }
        </script>
    </body>
</html>
```

`<div class="todo">`로 초기화면을 정의한다. const todoList = []로 배열에 할일 목록을 저장한다. onAdd()로 할 일을 추가하는 함수를 정으히ㅏㄴ다. 로직과 UI 코드가 복잡하게 얽혀 있다. onDelete로 할 일을 삭제하는 코드도 가독성이 낮다. 

다음은 같은 기능을 리액트로 작성한 코드다.

```jsx
function MyComponent() {
    const [desc, setDesc] = useState("");
    const [currentId, setCurrentId] = useState(1);
    const [todoList, setTodoList] = useState([]);
    function onAdd() {
        const todo = { id: currentId, desc };
        setCurrentId(currentId + 1);
        setTodoList([...todoList, todo]);
    }
    function onDelete(e) {
        const id = Number(e.target.dataset.id);
        const newTodoList = todoList.filter(todo => todo.id !== id);
        setTodoList(newTodoList);
    }
    function onSaveToServer() {
        // todoList 전송
    }
    return (
    	<div>
        	<h3>할 일 목록</h3>
            <ul>
            	{todoList.map(todo => {
                    <li key={todo.id}>
                    	<span>{todo.desc}</span>
                        <button data-id={todo.id} onClick={onDelete}>삭제</button>
                    </li>
                })}
            </ul>
            <input type="text" value={desc} onChange={e => setDesc(e.target.value)} />
            <button onClick={onAdd}>추가</button>
            <button onClick={onSaveToServer}>서버에 저장</button>
        </div>
    );
}
```

컴포넌트가 반환하는 값은 화면에 무엇을 그려야 하는지 설명하는 UI 코드로 이루어져 있다. UI 코드는 할 일을 추가하고 삭제하는 코드와 분리되어 있다. MyComponent 컴포넌트는 상탯값 todoList, desc를 기반으로 UI를 정의한다. 리액트는 상탯값이 수정되면 컴포넌트 함수를 실행해서 화면을 갱신할 수 있다. 

리액트를 사용하지 않은 코드는 화면을 어떻게 그리는지 나타낸다. 이와 대조적으로 리액트를 사용한 코드는 화면에 무엇을 그리는지 나타낸다. 전자를 명령형(imperative) 프로그래밍이라 부르고, 후자를 선언형(declarative) 프로그래밍이라 부른다. 

리액트를 사용하지 않은 코드는 돔을 직접 수정하면서 화면을 어떻게 그리는지 구체적으로 나타낸다. 상당히 구체적이기 때문에 돔 환경이 아닌 곳에서는 사용하기 힘들다. 반면에 리액트를 사용한 코드는 무엇을 그리는지만 나타내기 때문에 다양한 방식으로 그릴 수 있다. 컴포넌트 함수가 반환하는 코드는 선언형으로 작성되기 때문에 리액트는 돔 환경 뿐만 아니라 모바일 네이티브의 UI도 표현할 수 있다. 따라서 선언형 프로그래밍은 명령형 프로그래밍보다 추상화 단계가 높다고 할 수 있다. 추상화 단계가 높을수록 비즈니스 로직에 좀 더 집중할 수 있다는 장점이 있다. 

#### 컴포넌트의 속성값과 상탯값

##### 속성값과 상탯값으로 관리하는 UI 데이터

컴포넌트의 상탯값은 해당 컴포넌트가 관리하는 데이터이고, 컴포넌트의 속성값은 부모 컴포넌트로부터 전달받는 데이터다. 리액트에서 UI 데이터는 반드시 상탯값과 속성값으로 관리해야 한다. UI 데이터를 상탯값과 속성값으로 관리하지 않으면 UI 데이터가 변경돼도 화면이 갱신되지 않을 수 있다. 

다음 코드는 화면에서 버튼 하나를 보여 주고, 버튼을 누르면 color 변수의 값을 수정한다. 속성값과 상탯값을 사용하지 않았기 때문에 화면이 제대로 갱신되지 않는다. 

```jsx
let color = "red";
function MyComponent() {
    function onClick() {
        color = "blue";
    }
    return (
    	<button style={{ backgroundColor: color}}>좋아요</button>
    );
}
```

1행의 color 데이터는 버튼의 배경색을 나타낸다. 초기 화면은 의도한 대로 빨간색으로 잘 나온다. 버튼을 클릭하면 color 데이터는 파란색으로 변경되지만, 화면에 보이는 버튼의 배경색은 여전히 빨간색이다. 이는 리액트가 UI 데이터가 변경됐다는 사실을 모르기 때문이다. 

컴포넌트의 상탯값을 이용하면 리액트가 UI 데이터의 변경을 알 수 있다. 다음은 컴포넌트의 상탯값을 사용하도록 수정한 코드다. 

```jsx
import React, { useState } from "react";

function MyComponent() {
    const [color, setColor] = useState("red");
    function onClick() {
        setColor("blue");
    }
    return (
    	<button style={{ backgroundColor: color }} onClick={onClick}>좋아요</button>
    )
}
```

컴포넌트에 상탯값을 추가할 때는 useState 훅을 사용한다. useState 훅의 인자는 초깃값을 의미한다. useState가 반환하는 배열의 첫 번째 원소는 상탯값이고, 두 번째 원소는 상탯값 변경 함수다. 이처럼 훅에서는 배열 비구조화 문법을 자주 사용한다. 리액트는 setColor 함수가 호출되면 상탯값을 변경하고, 해당 컴포넌트를 다시 렌더링한다. 

속성값은 부모 컴포넌트가 전달해 주는 데이터이고, 대부분의 경우 UI 데이터를 포함한다. 다음은 컴포넌트의 속성값을 이용한 코드다. 

```jsx
function Title(props) {
    return <p>{props.title}</p>
}
```

Title 컴포넌트는 부모 컴포넌트로부터 title이라는 속성값을 받는다. Title 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링되므로 title 속성값의 변경 사항이 바로 화면에 반영된다. 

다음은 title 속성값을 내려 주는 부모 컴포넌트의 코드다.

```jsx
function Todo() {
    const [count, setCount] = useState(0);
    function onClick() {
        setCount(count + 1);
    }
    return (
    	<div>
        	<Title title={`현재 카운트: ${count}`} />
            <button onClick={onClick}>증가</button>
        </div>
    );
}
```

버튼을 클릭할 때마다 count 상탯값을 변경하고, Todo 컴포넌트는 다시 렌더링된다. 이때 Title 컴포넌트는 새로운 title 속성값을 내려받는다. 이렇게 상탯값과 속성값으로 UI 데이터를 관리하는 것이 리액트의 핵심이다. 

Title 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링된다. 만약 title 속성값이 변경될 때만 렌더링되길 원한다면 React.memo를 이용할 수 있다. 

```jsx
function Title(props) {
    return <p>{props.title}</p>;
}
export default React.memo(Title);
```

4행에서 memo 함수의 인수로 컴포넌트를 입력하면, 컴포넌트의 속성값이 변경되는 경우에만 렌더링된다.

같은 컴포넌트를 여러 번 사용할 수도 있다. 사용된 각 컴포넌트는 상탯값을 위한 자신만의 메모리 공간이 있어서 같은 컴포넌트라도 자신만의 상탯값이 존재한다. 다음과 같이 컴포넌트를 두 번 사용하면 두 개의 상탯값이 따로 관리된다. 

```jsx
function App() {
    return (
    	<div>
        	<MyComponent />
            <MyComponent />
        </div>
    );
}
```

##### 불변 객체로 관리하는 속성값과 상탯값

속성값은 불변(immutable) 변수이지만 상탯값은 불변 변수가 아니다. 하지만 상탯값도 불변 변수로 관리하는 게 좋다. 

속성값은 불변 변수이기 때문에 값을 변경하려고 시도하면 에러가 발생한다. 

```jsx
function Title(props) {
    props.title = 'abc';
    // ...
}
```

자식 컴포넌트에 전달되는 속성값은 상위 컴포넌트에서 관리하기 때문에 수정하지 못하도록 막혀 있다. 따라서 title이라는 데이터를 수정하고 싶다면 title 상탯값을 가진 컴포넌트에서 관리하는 상탯값 변경 함수를 이용해야 한다. 

속성값과 달리 상탯값은 직접 수정이 가능하다. 다음은 상탯값을 직접 수정하는 코드다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState({ value: 0 });
    
    function onClick() {
        const.value = 2;
        // ...
        setCount(count);
    }
}
// ...
```

onClick 함수 내에서 `const.value`와 같이 상탯값을 직접 수정할 수는 있지만 화면이 갱신되지 않는다. 리액트는 아직 상탯값이 변경된 사실을 모른다. `setCount(count)`와 같이 상탯값 변경 함수를 호출해도 화면은 갱신되지 않는다. 리액트는 상탯값 변경 유무를 이전 값과 단순 비교로 판단하는데, count 객체의 참조값은 그대로이므로 변경 사항이 없다고 판단하고 해당 요청을 무시한다. 

따라서 상탯값도 속성값과 같이 불변 변수로 관리하는 게 좋다. 불변 변수로 관리하면 코드의 복잡도가 낮아지는 장점도 있다. 

#### 컴포넌트 함수의 반환값

다음은 컴포넌트 함수에서 반환할 수 있는 다양한 값을 보여 주는 예제 코드다.

```jsx
return <MyComponent title="안녕하세요" />;
return <p>안녕하세요</p>;
return '안녕하세요';
return 123;
return [<p key="a">안녕하세요</p>, <p key="b">반갑습니다</p>];
return (
	<React.Fragment>
    	<p>안녕하세요</p>
    	<p>반갑습니다</p>
    </React.Fragment>
);
return (
	<>
    	<p>안녕하세요</p>
    	<p>반갑습니다</p>
    </>
);
return null;
return false;
return ReactDOM.createPortal(<p>안녕하세요</p>, domNode);
```

1-2행을 보면 우리가 작성한 컴포넌트와 HTML에 정의된 거의 모든 태그를 사용할 수 있다. 3-4행처럼 문자열과 숫자를 반환할 수 있다. 5행은 배열을 반환할 수 있다. 6-11행은 프래그먼트(fragment)를 사용하여 배열을 사용하지 않고도 여러 개의 요소를 표현할 수 있다. 그리고 프래그먼트 내부의 리액트 요소에 key 속성값을 부여하지 않아도 되므로 배열보다 편하게 작성할 수 있다. 12-17행은 보통 바벨을 이용해서 이렇게 프래그먼트를 축약해서 작성한다. 18-19행은 null 또는 불(boolean)을 반환하면 아무것도 렌더링하지 않는다. 20행은 리액트 포털(portal)을 사용하면 컴포넌트의 현재 위치와는 상관없이 특정 돔 요소에 렌더링할 수 있다. 

다ㅇ므은 컴포넌트 함수가 불을 반환할 수 있다는 점을 이용한 코드다. 

```jsx
function MyComponent({ title }) {
    return title.length > 0 && <p>{title}</p>;
}
```

title 속성값의 길이가 0이면 거짓(false)를 반환하고, 결과적으로 아무것도 렌더링되지 않는다. 반대로 title 속성값의 길이가 1 이상이면 우측으 p 요소가 반환된다. 

다음은 리액트 포털을 사용하는 코드다.

```jsx
function Modal({ title, desc }) {
    const domNode = document.getElementById('modal');
    return ReactDOM.createPortal(
    	<div>
        	<p>{title}</p>
        	<p>{desc}</p>
        </div>,
        domNode,
    );
}
```

3행은 리액트 포털을 이용해서 특정 돔 요소에 리액트 요소를 랜더링할 수 있다. Modal 컴포넌트가 사용된 위치와 상관없이 렌더링할 위치를 선택할 수 있다. 

### 리액트 요소와 가상 돔

리액트 요소(element)는 리액트가 UI를 표현하는 수단이다. 보통 우리는 JSX 문법을 사용하기 때문에 리액트 요소의 존재를 잘 모른다. 하지만 리액트 요소를 이해한다면 리액트가 내부적으로 어떻게 동작하는지 알 수 있다. 

리액트는 렌더링 성능을 위해 가상 돔을 사용한다. 브라우저에서 돔을 변경하는 것은 비교적 오래 걸리는 작업이다. 따라서 빠른 렌더링을 위해서는 돔 변경을 최소화해야 한다. 그래서 리액트는 메모리에 가상 돔을 올려 놓고 이전과 이후의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영하는 전략을 채택했다.

리액트 요소로부터 가상 돔을 만들고, 실제 돔에 반영할 변경 사항을 찾는 과정을 따라가 보자. 

#### 리액트 요소 이해하기

JSX 문법으로 작성된 코드는 createElement 함수로 변경된다는 사실을 배웠다. 이름에서 알 수 있듯이 createElement 함수는 리액트 요소를 반환한다. 따라서 대부분의 경우 컴포넌트 함수는 리액트 요소를 반환한다. 리액트가 UI를 표현하기 위해 사용하는 리액트 요소의 구조를 살펴보자. 

다음은 JSX 코드가 createElement 함수를 사용하는 코드로 변경된 예다. 

```jsx
const element = <a href="http://google.com">click here</a>;
const element = React.createElement(
	'a',
    { href: 'http://google.com' },
    'click here',
);
```

첫 번째 줄의 코드는 그 다음 줄의 코드로 변경된다.

다음 코드는 createElement 함수가 반환하는 리액트 요소의 구조를 보여 준다.

```jsx
const element = (
	<a key="key1" style={{ width: 100 }} href="http://google.com">click here</a>
);

console.log(element);
const consoleLogResult = {
    type: 'a',
    key: 'key1',
    ref: null,
    props: {
        href: 'http://google.com',
        style: {
            width: 100,
        },
        children: 'click here',
    },
    // ...
};
```

1행부터 3행까지의 element 변수는 createElement 함수가 반환한 리액트 요소다. consoleLogRsult 변수는 리액트 요소를 로그로 출력한 결과를 표현한 것이다. type 속성값이 문자열이면 HTML 태그를 나타낸다. type 속성값이 함수이면 우리가 작성한 컴포넌트를 나타낸다. key: 'key1'은 JSX 코드에서 key 속성값을 입력하면 리액트 요소의 ref 속성값으로 들어간다. key와 ref를 제외한 나머지 속성값은 리액트 요소의 props 속성값으로 들어간다. 그 밖에도 리액트 요소가 가진 속성값이 더 있지만, 이정도만 이해해도 충분하다.

JSX 코드에서 태그 사이에 표현식이 들어가면, 리액트 요소에는 이 표현식이 여러 개로 분할되어 들어간다.

```jsx
const element = <h1>제 나이는 {20 + 5} 세입니다</h1>;
console.log(element);
const consoleLogResult = {
    type: 'h1',
    props: { children: ['제 나이는 ', 25, ' 세입니다'] },
    // ...
}
```

1행의 코드에서 태그 사이의 값은 5행의 코드와 같이 표현식을 기준으로 분할돼서 들어간다.

JSX 코드에서 컴포넌트가 사용되면, 리액트 요소의 type 속성값은 해당 컴포넌트 함수가 된다. 

```jsx
function Title({ title, color }) {
    return <p style={{ color }}>{title}</p>;
}
const element = <Title title="안녕하세요" color="blue" />;
console.log(element);
const consoleLogResult = {
    type: Title,
    props: { title: '안녕하세요', color: 'blue' },
    // ...
}
```

4행에서 JSX에 사용된 Title 컴포넌트는 consoleLogResult에서 리액트 요소의 type 속성값에 입력된다. 리액트는 type 속성값으로 전달된 함수를 호출해서 화면을 그리기 위한 충분한 정보를 얻을 수 있다. 

리액트 요소는 불변 객체이기 때문에 속성값을 변경할 수 없다.

```jsx
const element = <a href="http://google.com">click hire</a>;
elements.type = 'b'; // 에러 발생
```

리액트는 전달된 리액트 요소를 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다. 

```jsx
let seconds = 0;
function update() {
    seconds += 1;
    const element = {
        <div>
        	<h1>안녕하세요</h1>
            <h2>지금까지 {seconds}초가 지났습니다.</h2>
        </div>
    };
    ReactDOM.render(element, document.getElementByID('root'));
}

setInterval(update, 1000);
```

setInterval로 1초마다 update 함수를 호출해서 화면을 갱신한다. 리액트 요소에서 변경되는 부분은 seconds 변수로 표현된 숫자가 유일하다. ReactDOM.render로 리액트가 새로운 리액트 요소를 받으면 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다. 따라서 앞의 코드에 의해 업데이트되는 과정에서 리액트는 실제 돔의 h1 요소는 건드리지 않는다. 

#### 리액트 요소가 돔 요소로 만들어지는 과정

하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 트리(tree) 구조로 구성된다. 프로그램 화면은 여러 가지 이벤트를 통해서 다양한 모습으로 변화한다. 하나의 리액트 트리 요소는 시간에 따라 변화하는 화면의 한순간을 나타낸다. 

리액트에서 