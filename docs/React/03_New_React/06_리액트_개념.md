## 중요하지만 헷갈리는 리액트 개념

프레임워크나 라이브러리를 온전히 이해하지 못한 채로 프로젝트를 시작하면 기술 부채가 늘어난다. 어설프게 알고 있던 내용이 있다면 이 기회에 확실히 이해하자.

### 상탯값과 속성값으로 관리하는 UI 데이터

UI 라이브러리인 리액트는 UI 데이터를 관리하는 방법을 제공한다. UI 데이터는 컴포넌트 내부에서 관리되는 상탯값과 부모 컴포넌트에서 내려 주는 속성값으로 구성된다. 리덕스와 같이 전역 데이터를 관리해 주는 라이브러리를 리액트에 적용할 때도 결국에는 컴포넌트의 상탯값과 속성값을 이용해서 구현한다.

UI 데이터가 변경되면 화면을 다시 그려야 하낟. 리액트와 같은 UI 라이브러리를 사용하지 않는다면 UI 데이터가 변경될 때마다 돔 요소를 직접 수정해야 한다. 그런데 돔 요소를 직접 수정하다 봄녀 비즈니스 로직과 UI를 수정하는 코드가 뒤섞여지고, 코드가 복잡해진다. 그래서 리액트는 화면을 그리는 모든 코드를 컴포넌트 함수에 선언형으로 작성하도록 했다. UI 데이터가 변경되면 리액트가 컴포넌트 함수를 이용해서 화면을 자동으로 갱신해 주며, 이것이 리액트의 가장 중요한 역할이다. 

#### 리액트를 사용한 코드의 특징

리액트 코드와 리액트를 사용하지 않은 코드를 비교해 보면서 리액트의 특징을 살펴보자. 다음은 리액트와 같은 라이브러리를 사용하지 않고 직접 UI를 관리하는 코드다. 할 일 목록을 추가하거나 삭제할 수 있는 간단한 프로그램이다. 

```html
<html>
	<body>
    	<div class="todo">
        	<h3>할 일 목록</h3>
            <ul class="list"></ul>
            <input class="desc" type="text" />
            <button onClick="onAdd()">추가</button>
            <button onClick="onSaveToServer()">서버에 저장</button>
        </div>
        <script>
        	let currentId = 1;
            const todoList = [];
            function onAdd() {
                const inputEl = document.querySelector('.todo .desc');
                const todo = { id: currentId, desc: inputEl.value };
                todoList.push(todo);
                currentId += 1;
                const elemList = document.querySelector('.todo .list');
                const liEl = makeTodoElement(todo);
                elemList.appendChild(liEl);
            }
            function makeTodoElement(todo) {
                const liEl = document.createElement('li');
                const spanEl = document.createElement('span');
                const buttonEl = document.createElement('button');
                spanEl.innerHTML = todo.desc;
                buttonEl.innerHTML = '삭제';
                buttonEl.dataset.id = todo.id;
                liEl.appendChild(spanEl);
                liEl.appendChild(buttonEl);
                return liEl;
            }
            function onDelete(e) {
                const id = Number(e.target.dataset.id);
                const index = todoList.findIndex(item => item.id === id);
                if (index >= 0) {
                    todoList.splice(index, 1);
                    conse elemList = document.querySelector('.todo .list');
                    const liEl = e.target.parentNode;
                    elem.removeChild(liEl);
                }
            }
            function onSaveToServer() {
                // todoList 전송
            }
        </script>
    </body>
</html>
```

`<div class="todo">`로 초기화면을 정의한다. const todoList = []로 배열에 할일 목록을 저장한다. onAdd()로 할 일을 추가하는 함수를 정으히ㅏㄴ다. 로직과 UI 코드가 복잡하게 얽혀 있다. onDelete로 할 일을 삭제하는 코드도 가독성이 낮다. 

다음은 같은 기능을 리액트로 작성한 코드다.

```jsx
function MyComponent() {
    const [desc, setDesc] = useState("");
    const [currentId, setCurrentId] = useState(1);
    const [todoList, setTodoList] = useState([]);
    function onAdd() {
        const todo = { id: currentId, desc };
        setCurrentId(currentId + 1);
        setTodoList([...todoList, todo]);
    }
    function onDelete(e) {
        const id = Number(e.target.dataset.id);
        const newTodoList = todoList.filter(todo => todo.id !== id);
        setTodoList(newTodoList);
    }
    function onSaveToServer() {
        // todoList 전송
    }
    return (
    	<div>
        	<h3>할 일 목록</h3>
            <ul>
            	{todoList.map(todo => {
                    <li key={todo.id}>
                    	<span>{todo.desc}</span>
                        <button data-id={todo.id} onClick={onDelete}>삭제</button>
                    </li>
                })}
            </ul>
            <input type="text" value={desc} onChange={e => setDesc(e.target.value)} />
            <button onClick={onAdd}>추가</button>
            <button onClick={onSaveToServer}>서버에 저장</button>
        </div>
    );
}
```

컴포넌트가 반환하는 값은 화면에 무엇을 그려야 하는지 설명하는 UI 코드로 이루어져 있다. UI 코드는 할 일을 추가하고 삭제하는 코드와 분리되어 있다. MyComponent 컴포넌트는 상탯값 todoList, desc를 기반으로 UI를 정의한다. 리액트는 상탯값이 수정되면 컴포넌트 함수를 실행해서 화면을 갱신할 수 있다. 

리액트를 사용하지 않은 코드는 화면을 어떻게 그리는지 나타낸다. 이와 대조적으로 리액트를 사용한 코드는 화면에 무엇을 그리는지 나타낸다. 전자를 명령형(imperative) 프로그래밍이라 부르고, 후자를 선언형(declarative) 프로그래밍이라 부른다. 

리액트를 사용하지 않은 코드는 돔을 직접 수정하면서 화면을 어떻게 그리는지 구체적으로 나타낸다. 상당히 구체적이기 때문에 돔 환경이 아닌 곳에서는 사용하기 힘들다. 반면에 리액트를 사용한 코드는 무엇을 그리는지만 나타내기 때문에 다양한 방식으로 그릴 수 있다. 컴포넌트 함수가 반환하는 코드는 선언형으로 작성되기 때문에 리액트는 돔 환경 뿐만 아니라 모바일 네이티브의 UI도 표현할 수 있다. 따라서 선언형 프로그래밍은 명령형 프로그래밍보다 추상화 단계가 높다고 할 수 있다. 추상화 단계가 높을수록 비즈니스 로직에 좀 더 집중할 수 있다는 장점이 있다. 

#### 컴포넌트의 속성값과 상탯값

##### 속성값과 상탯값으로 관리하는 UI 데이터

컴포넌트의 상탯값은 해당 컴포넌트가 관리하는 데이터이고, 컴포넌트의 속성값은 부모 컴포넌트로부터 전달받는 데이터다. 리액트에서 UI 데이터는 반드시 상탯값과 속성값으로 관리해야 한다. UI 데이터를 상탯값과 속성값으로 관리하지 않으면 UI 데이터가 변경돼도 화면이 갱신되지 않을 수 있다. 

다음 코드는 화면에서 버튼 하나를 보여 주고, 버튼을 누르면 color 변수의 값을 수정한다. 속성값과 상탯값을 사용하지 않았기 때문에 화면이 제대로 갱신되지 않는다. 

```jsx
let color = "red";
function MyComponent() {
    function onClick() {
        color = "blue";
    }
    return (
    	<button style={{ backgroundColor: color}}>좋아요</button>
    );
}
```

1행의 color 데이터는 버튼의 배경색을 나타낸다. 초기 화면은 의도한 대로 빨간색으로 잘 나온다. 버튼을 클릭하면 color 데이터는 파란색으로 변경되지만, 화면에 보이는 버튼의 배경색은 여전히 빨간색이다. 이는 리액트가 UI 데이터가 변경됐다는 사실을 모르기 때문이다. 

컴포넌트의 상탯값을 이용하면 리액트가 UI 데이터의 변경을 알 수 있다. 다음은 컴포넌트의 상탯값을 사용하도록 수정한 코드다. 

```jsx
import React, { useState } from "react";

function MyComponent() {
    const [color, setColor] = useState("red");
    function onClick() {
        setColor("blue");
    }
    return (
    	<button style={{ backgroundColor: color }} onClick={onClick}>좋아요</button>
    )
}
```

컴포넌트에 상탯값을 추가할 때는 useState 훅을 사용한다. useState 훅의 인자는 초깃값을 의미한다. useState가 반환하는 배열의 첫 번째 원소는 상탯값이고, 두 번째 원소는 상탯값 변경 함수다. 이처럼 훅에서는 배열 비구조화 문법을 자주 사용한다. 리액트는 setColor 함수가 호출되면 상탯값을 변경하고, 해당 컴포넌트를 다시 렌더링한다. 

속성값은 부모 컴포넌트가 전달해 주는 데이터이고, 대부분의 경우 UI 데이터를 포함한다. 다음은 컴포넌트의 속성값을 이용한 코드다. 

```jsx
function Title(props) {
    return <p>{props.title}</p>
}
```

Title 컴포넌트는 부모 컴포넌트로부터 title이라는 속성값을 받는다. Title 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링되므로 title 속성값의 변경 사항이 바로 화면에 반영된다. 

다음은 title 속성값을 내려 주는 부모 컴포넌트의 코드다.

```jsx
function Todo() {
    const [count, setCount] = useState(0);
    function onClick() {
        setCount(count + 1);
    }
    return (
    	<div>
        	<Title title={`현재 카운트: ${count}`} />
            <button onClick={onClick}>증가</button>
        </div>
    );
}
```

버튼을 클릭할 때마다 count 상탯값을 변경하고, Todo 컴포넌트는 다시 렌더링된다. 이때 Title 컴포넌트는 새로운 title 속성값을 내려받는다. 이렇게 상탯값과 속성값으로 UI 데이터를 관리하는 것이 리액트의 핵심이다. 

Title 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링된다. 만약 title 속성값이 변경될 때만 렌더링되길 원한다면 React.memo를 이용할 수 있다. 

```jsx
function Title(props) {
    return <p>{props.title}</p>;
}
export default React.memo(Title);
```

4행에서 memo 함수의 인수로 컴포넌트를 입력하면, 컴포넌트의 속성값이 변경되는 경우에만 렌더링된다.

같은 컴포넌트를 여러 번 사용할 수도 있다. 사용된 각 컴포넌트는 상탯값을 위한 자신만의 메모리 공간이 있어서 같은 컴포넌트라도 자신만의 상탯값이 존재한다. 다음과 같이 컴포넌트를 두 번 사용하면 두 개의 상탯값이 따로 관리된다. 

```jsx
function App() {
    return (
    	<div>
        	<MyComponent />
            <MyComponent />
        </div>
    );
}
```

##### 불변 객체로 관리하는 속성값과 상탯값

속성값은 불변(immutable) 변수이지만 상탯값은 불변 변수가 아니다. 하지만 상탯값도 불변 변수로 관리하는 게 좋다. 

속성값은 불변 변수이기 때문에 값을 변경하려고 시도하면 에러가 발생한다. 

```jsx
function Title(props) {
    props.title = 'abc';
    // ...
}
```

자식 컴포넌트에 전달되는 속성값은 상위 컴포넌트에서 관리하기 때문에 수정하지 못하도록 막혀 있다. 따라서 title이라는 데이터를 수정하고 싶다면 title 상탯값을 가진 컴포넌트에서 관리하는 상탯값 변경 함수를 이용해야 한다. 

속성값과 달리 상탯값은 직접 수정이 가능하다. 다음은 상탯값을 직접 수정하는 코드다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState({ value: 0 });
    
    function onClick() {
        const.value = 2;
        // ...
        setCount(count);
    }
}
// ...
```

onClick 함수 내에서 `const.value`와 같이 상탯값을 직접 수정할 수는 있지만 화면이 갱신되지 않는다. 리액트는 아직 상탯값이 변경된 사실을 모른다. `setCount(count)`와 같이 상탯값 변경 함수를 호출해도 화면은 갱신되지 않는다. 리액트는 상탯값 변경 유무를 이전 값과 단순 비교로 판단하는데, count 객체의 참조값은 그대로이므로 변경 사항이 없다고 판단하고 해당 요청을 무시한다. 

따라서 상탯값도 속성값과 같이 불변 변수로 관리하는 게 좋다. 불변 변수로 관리하면 코드의 복잡도가 낮아지는 장점도 있다. 

#### 컴포넌트 함수의 반환값

다음은 컴포넌트 함수에서 반환할 수 있는 다양한 값을 보여 주는 예제 코드다.

```jsx
return <MyComponent title="안녕하세요" />;
return <p>안녕하세요</p>;
return '안녕하세요';
return 123;
return [<p key="a">안녕하세요</p>, <p key="b">반갑습니다</p>];
return (
	<React.Fragment>
    	<p>안녕하세요</p>
    	<p>반갑습니다</p>
    </React.Fragment>
);
return (
	<>
    	<p>안녕하세요</p>
    	<p>반갑습니다</p>
    </>
);
return null;
return false;
return ReactDOM.createPortal(<p>안녕하세요</p>, domNode);
```

1-2행을 보면 우리가 작성한 컴포넌트와 HTML에 정의된 거의 모든 태그를 사용할 수 있다. 3-4행처럼 문자열과 숫자를 반환할 수 있다. 5행은 배열을 반환할 수 있다. 6-11행은 프래그먼트(fragment)를 사용하여 배열을 사용하지 않고도 여러 개의 요소를 표현할 수 있다. 그리고 프래그먼트 내부의 리액트 요소에 key 속성값을 부여하지 않아도 되므로 배열보다 편하게 작성할 수 있다. 12-17행은 보통 바벨을 이용해서 이렇게 프래그먼트를 축약해서 작성한다. 18-19행은 null 또는 불(boolean)을 반환하면 아무것도 렌더링하지 않는다. 20행은 리액트 포털(portal)을 사용하면 컴포넌트의 현재 위치와는 상관없이 특정 돔 요소에 렌더링할 수 있다. 

다ㅇ므은 컴포넌트 함수가 불을 반환할 수 있다는 점을 이용한 코드다. 

```jsx
function MyComponent({ title }) {
    return title.length > 0 && <p>{title}</p>;
}
```

title 속성값의 길이가 0이면 거짓(false)를 반환하고, 결과적으로 아무것도 렌더링되지 않는다. 반대로 title 속성값의 길이가 1 이상이면 우측으 p 요소가 반환된다. 

다음은 리액트 포털을 사용하는 코드다.

```jsx
function Modal({ title, desc }) {
    const domNode = document.getElementById('modal');
    return ReactDOM.createPortal(
    	<div>
        	<p>{title}</p>
        	<p>{desc}</p>
        </div>,
        domNode,
    );
}
```

3행은 리액트 포털을 이용해서 특정 돔 요소에 리액트 요소를 랜더링할 수 있다. Modal 컴포넌트가 사용된 위치와 상관없이 렌더링할 위치를 선택할 수 있다. 

### 리액트 요소와 가상 돔

리액트 요소(element)는 리액트가 UI를 표현하는 수단이다. 보통 우리는 JSX 문법을 사용하기 때문에 리액트 요소의 존재를 잘 모른다. 하지만 리액트 요소를 이해한다면 리액트가 내부적으로 어떻게 동작하는지 알 수 있다. 

리액트는 렌더링 성능을 위해 가상 돔을 사용한다. 브라우저에서 돔을 변경하는 것은 비교적 오래 걸리는 작업이다. 따라서 빠른 렌더링을 위해서는 돔 변경을 최소화해야 한다. 그래서 리액트는 메모리에 가상 돔을 올려 놓고 이전과 이후의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영하는 전략을 채택했다.

리액트 요소로부터 가상 돔을 만들고, 실제 돔에 반영할 변경 사항을 찾는 과정을 따라가 보자. 

#### 리액트 요소 이해하기

JSX 문법으로 작성된 코드는 createElement 함수로 변경된다는 사실을 배웠다. 이름에서 알 수 있듯이 createElement 함수는 리액트 요소를 반환한다. 따라서 대부분의 경우 컴포넌트 함수는 리액트 요소를 반환한다. 리액트가 UI를 표현하기 위해 사용하는 리액트 요소의 구조를 살펴보자. 

다음은 JSX 코드가 createElement 함수를 사용하는 코드로 변경된 예다. 

```jsx
const element = <a href="http://google.com">click here</a>;
const element = React.createElement(
	'a',
    { href: 'http://google.com' },
    'click here',
);
```

첫 번째 줄의 코드는 그 다음 줄의 코드로 변경된다.

다음 코드는 createElement 함수가 반환하는 리액트 요소의 구조를 보여 준다.

```jsx
const element = (
	<a key="key1" style={{ width: 100 }} href="http://google.com">click here</a>
);

console.log(element);
const consoleLogResult = {
    type: 'a',
    key: 'key1',
    ref: null,
    props: {
        href: 'http://google.com',
        style: {
            width: 100,
        },
        children: 'click here',
    },
    // ...
};
```

1행부터 3행까지의 element 변수는 createElement 함수가 반환한 리액트 요소다. consoleLogRsult 변수는 리액트 요소를 로그로 출력한 결과를 표현한 것이다. type 속성값이 문자열이면 HTML 태그를 나타낸다. type 속성값이 함수이면 우리가 작성한 컴포넌트를 나타낸다. key: 'key1'은 JSX 코드에서 key 속성값을 입력하면 리액트 요소의 ref 속성값으로 들어간다. key와 ref를 제외한 나머지 속성값은 리액트 요소의 props 속성값으로 들어간다. 그 밖에도 리액트 요소가 가진 속성값이 더 있지만, 이정도만 이해해도 충분하다.

JSX 코드에서 태그 사이에 표현식이 들어가면, 리액트 요소에는 이 표현식이 여러 개로 분할되어 들어간다.

```jsx
const element = <h1>제 나이는 {20 + 5} 세입니다</h1>;
console.log(element);
const consoleLogResult = {
    type: 'h1',
    props: { children: ['제 나이는 ', 25, ' 세입니다'] },
    // ...
}
```

1행의 코드에서 태그 사이의 값은 5행의 코드와 같이 표현식을 기준으로 분할돼서 들어간다.

JSX 코드에서 컴포넌트가 사용되면, 리액트 요소의 type 속성값은 해당 컴포넌트 함수가 된다. 

```jsx
function Title({ title, color }) {
    return <p style={{ color }}>{title}</p>;
}
const element = <Title title="안녕하세요" color="blue" />;
console.log(element);
const consoleLogResult = {
    type: Title,
    props: { title: '안녕하세요', color: 'blue' },
    // ...
}
```

4행에서 JSX에 사용된 Title 컴포넌트는 consoleLogResult에서 리액트 요소의 type 속성값에 입력된다. 리액트는 type 속성값으로 전달된 함수를 호출해서 화면을 그리기 위한 충분한 정보를 얻을 수 있다. 

리액트 요소는 불변 객체이기 때문에 속성값을 변경할 수 없다.

```jsx
const element = <a href="http://google.com">click hire</a>;
elements.type = 'b'; // 에러 발생
```

리액트는 전달된 리액트 요소를 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다. 

```jsx
let seconds = 0;
function update() {
    seconds += 1;
    const element = {
        <div>
        	<h1>안녕하세요</h1>
            <h2>지금까지 {seconds}초가 지났습니다.</h2>
        </div>
    };
    ReactDOM.render(element, document.getElementByID('root'));
}

setInterval(update, 1000);
```

setInterval로 1초마다 update 함수를 호출해서 화면을 갱신한다. 리액트 요소에서 변경되는 부분은 seconds 변수로 표현된 숫자가 유일하다. ReactDOM.render로 리액트가 새로운 리액트 요소를 받으면 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다. 따라서 앞의 코드에 의해 업데이트되는 과정에서 리액트는 실제 돔의 h1 요소는 건드리지 않는다. 

#### 리액트 요소가 돔 요소로 만들어지는 과정

하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 트리(tree) 구조로 구성된다. 프로그램 화면은 여러 가지 이벤트를 통해서 다양한 모습으로 변화한다. 하나의 리액트 트리 요소는 시간에 따라 변화하는 화면의 한순간을 나타낸다. 

리액트에서 데이터 변경에 의한 화면 업데이트는 렌더 단계(render phase, reconciliation phase라고도 불린다)와 커밋 단계(commit phase)를 거친다. 렌더는 실제 돔에 반영할 변경 사항을 파악하는 단계이고, 커밋은 파악된 변경 사항을 실제 돔에 반영하는 단계이다. 렌더 단계에서는 변경 사항을 파악하기 위해 가상 돔을 이용한다. 

가상 돔은 리액트 요소로부터 만들어진다. 리액트는 렌더링을 할 때마다 가상돔을 만들고 이전의 가상 돔과 비교한다. 이는 실제 돔의 변경 사항을 최소화하기 위한 과정이다. 

다음 코드는 할 일의 우선순위를 상탯값으로 관리하는 코드다. 할 일의 제목과 내용은 부모 컴포넌트가 속성값으로 내려준다. 이 코드를 기반으로 리액트 요소가 실제 돔으로 만들어지는 괒어을 이해해 보자. 

```jsx
function Todo({ title, desc }) {
    const [priority, setPriority] = useState("high");
    function onClick() {
        setPriority(priority === "high" ? "low" : "high");
    }
    return (
    	<Title title={title} />
        <p>{desc}</p>
        <p>{priority === "high" ? "우선순위 높음" : "우선순위 낮음"}</p>
        <button onClick={onClick}>우선순위 변경</button>
    );
}

const Title = React.memo(({ title }) => {
    return <p style={{ color: "blue" }}>{title}</p>;
});

ReactDOM.render(
	<Todo title="리액트 공부하기" desc="실전 리액트 프로그래밍을 열심히 읽는다" />,
    document.getElementById('root');
);
```

Todo 컴포넌트는 Title 컴포넌트를 자식으로 사용한다. 버튼을 클릭하면 priority 상탯값이 변경되고 화면을 다시 그린다. React.memo로 만들어진 Title 컴포넌트는 속성값이 변경될 때만 호출된다.

ReactDOM.render 함수로 전달된 리액트 요소 트리의 구조는 다음과 같다.

```jsx
const initialElementTree = {
    type: Todo,
    props: {
        title: '리액트 공부하기',
        desc: '실전 리액트 프로그래밍을 열심히 읽는다',
    },
    // ...
};
```

리액트가 initialElementTree를 이용해서 실제 돔을 만드는 과정을 따라가 보자. 먼저 Todo 컴포넌트의 렌더링 결과를 얻기 위해 Todo 컴포넌트 함수를 호출한다. 그 결과는 다음과 같다.

```jsx
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: Title,
                props: { title: '리액트 공부하기' },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 높음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: funcion() {
                    	/* Todo 컴포넌트의 onClick 함수 */
                	},
                	children: '우선순위 변경',
                },
            	// ...
            },
        ],
    },
    // ...
}
```

2행에서 트리의 루트는 div 태그로 변경된다. 6행에서는 아직 Title 컴포넌트가 존재하기 때문에 이 트리를 실제 돔으로 만들 수는 없다. 리액트 요소 트리가 실제 돔으로 만들어지기 위해서는 모든 리액트 요소의 type 속성값이 문자열이어야 한다. 이는 type 속성값이 문자열이어야 HTML 태그로 변환할 수 있기 때문이다. 그러기 위해서는 모든 컴포넌트 함수가 호출되어야 한다. 

Title 컴포넌트를 렌더링한 결과는 다음과 같다.

```jsx
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: 'p',
                props: { 
                    style: { color: 'blue' },
                    children: '리액트 공부하기', 
                },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 높음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: funcion() {
                    	/* Todo 컴포넌트의 onClick 함수 */
                	},
                	children: '우선순위 변경',
                },
            	// ...
            },
        ],
    },
    // ...
}
```

6행부터 Title 컴포넌트로 표현됐던 리액트 요소가 p 태그로 변경됐다. 이제 모든 리액트 요소의 type 속성값이 문자열이므로 실제 돔을 만들 수 있다. 이와 같이 실제 돔을 만들 수 있는 리액트 요소 트리를 가상 돔이라고 한다. 최초의 리액트 요소 트리로부터 가상 돔을 만들고 이전 가상 돔과 비교해서 실제 돔에 반영할 내용을 결정하는 단계를 렌더라고 한다. 

리액트는 화면을 업데이트할 때 이전의 가상 돔과 현재의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영한다. 브라우저에서 실제 돔을 변경하는 작업은 다른 작업에 비해 시간이 오래 걸리기 때문에 꼭 필요한 부분만 변경하는 것이 중요하다. 이렇듯 중요하지만 직접 하기는 귀찮은 작업을 리액트가 알아서 해준다. 

렌더 단계는 ReactDOM.render 함수와 상탯값 변경 함수에 의해 시작된다. 위에서 ReactDOM.render 함수에 의해 시작된 렌더 단계를 살펴봤다. 이제 상탯값 변경 함수에 의해 수행되는 렌더 단계를 따라가 보자.

Todo 컴포넌트는 상탯값을 갖고 있다. 버튼을 클릭하면 setPriority 함수가 호출되고 또다시 렌더 단계가 시작된다. Todo 컴포넌트의 priority 상탯값이 변경되면 Todo 컴포넌트 함수가 호출된다. 그 결과로 만들어지는 리액트 요소 트리는 다음과 같다.

```jsx
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: title,
                props: { title: '리액트 공부하기' },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 낮음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: funcion() {
                    	/* Todo 컴포넌트의 onClick 함수 */
                	},
                	children: '우선순위 변경',
                },
            	// ...
            },
        ],
    },
    // ...
}
```

Title 컴포넌트는 React.memo로 만들어졌고, 속성값이 변하지 않았기 때문에 이전 결과가 재사용된다. 이렇게 두 번째 가상 돔이 만들어졌다. 이전의 가상 돔과 비교해 보면 '우선순위 낮음' 문자열만 변경됐다는 사실을 알 수 있다. 따라서 실제 돔에서도 해당 p 태그의 문자열만 수정된다. 

지금까지의 과정을 정리해 보자. ReactDOM.render 함수가 호출되고 최초의 렌더 단계가 실행됐다. 그리고 이렇게 만들어진 가상 돔이 실제 돔으로 만들어졌다. 사용자의 버튼 클릭으로 Todo 컴포넌트의 상탯값이 변경된다. 곧 두 번째 렌더 단계가 실행되고 새로운 가상 돔이 만들어진다. 이때 이전의 가상 돔과 비교해서 변경된 부분만 실제 돔에 반영된다. 

지금까지 리액트 요소를 이용해서 렌더 단계를 설명했지만, 엄밀히 말하면 리액트 요소는 파이버(fiber)라는 구조체로 변환된다. 파이버는 리액트 버전 16부터 도입된 구조체 이름이다. 파이버도 리액트 요소와 같이 type, props 속성값을 가진다. 파이버로 동작할 때도 모든 type 속성값이 문자열이 될 때까지 연산한다는 사실에는 변함이 없다. 

### 리액트 훅 기초 익히기

훅은 함수형 컴포넌트에 기능을 추가할 때 사용하는 함수다. 훅을 이용하면 함수형 컴포넌트에서 상탯값을 사용할 수 있고, 자식 요소에 접근할 수 있다. 

훅은 비교적 최근(리액트 16.8)에 추가된 기능이며 기존에 리액트가 가지고 있던 여러 가지 문제를 해결해 준다. 새로 작성하는 컴포넌트는 되도록 클래스형 컴포넌트보다 훅을 사용해서 함수형 컴포넌트로 작성하는 게 좋다. 훅이 주는 장점이 매우 크고, 리액트 팀에서도 적극적으로 훅과 관련된 기능 개발에 많은 시간을 투자하고 있다. 

#### 상탯값 추가하기: useState

useState 훅을 이용하면 컴포넌트에 상탯값을 추가할 수 있다. useState 훅의 사용법은 앞서 간단하게 살펴봤다. 이제 useState 훅을 좀 더 깊이 이해해 보자. 

##### 배치로 처리되는 상탯값 변경 함수

useState 훅이 반환하는 배열의 두 번째 원소는 상탯값 변경 함수다. 리액트는 상탯값 변경 함수가 호출되면 해당 컴포넌트를 다시 그린다. 그 과정에서 자식 컴포넌트도 같이 렌더링된다. 

리액트는 가능하다면 상탯값 변경을 배치(batch)로 처리한다. 다음은 상탯값 변경 함수를 연속해서 호출하는 코드다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState({ value: 0 });
    function onClick() {
        setCount({value: count.value + 1});
        setCount({value: count.value + 1});
    }
    console.log('render called');
    return (
    	<div>
        	<h2>{count.value}</h2>
            <button onClick={onClick}>증가</button>
        </div>
    );
}
```

count.value 상탯값을 두 번 증가시키려고 했다. 하지만 의도와 달리 1만큼만 증가한다. 이는 상탯값 변경 함수가 비동기로 동작하기 때문이다. 리액트는 효율적으로 렌더링하기 위해 여러 개의 상탯값 변경 요청을 배치로 처리한다. 따라서 onClick 함수가 호출되어도 7행의 로그는 한 번만 출력된다. 

리액트가 상탯값 변경 함수를 동기로 처리하면 하나의 상탯값 변경 함수가 호출될 때마다 화면을 다시 그리기 때문에 성능 이슈가 생길 수 있다. 만약 동기로 처리하지만 매번 화면을 다시 그리지 않는다면 UI 데이터와 화면 간의 불일치가 발생해서 혼란스러울 수 있다. 

##### 상탯값 변경 함수에 함수 입력하기

위의 코드에서 생긴 문제를 해결하기 위해 다음과 같이 상탯값 변경 함수의 인수로 함수를 입력할 수 있다. 이전 코드에서는 상탯값이 객체였지만 여기서는 가독성을 위해 숫자로 변경했다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState(0);
    function onClick() {
        setCount(prev => prev + 1);
        setCount(prev => prev + 1);
    }
    // ...
}
```

상탯값 변경 함수로 입력된 함수는 자신이 호출되기 직전의 상탯값을 매개변수로 받는다. 이 코드에서는 첫 번째 호출에서 변경된 상탯값이 두 번째 호출의 인수로 사용된다. 따라서 onClick 함수를 호출하면 count 상탯값은 2만큼 증가한다. 

##### 호출 순서가 보장되는 상탯값 변경 함수

상탯값 변경 함수는 비동기로 처리되지만 그 순서가 보장된다. 

```jsx
function MyComponent() {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);
    function onClick() {
        setCount1(count1 + 1);
        setCount2(count2 + 1);
    }
    const result = count1 >= count2;
    // ...
}
```

count1 상탯값이 먼저 증가하고 count2 상탯값은 나중에 증가한다. 상탯값 변경 함수의 호출 순서대로 상탯값이 변경되기 때문에 result 변수는 항상 참이다. 

##### useState 훅 하나로 여러 상탯값 관리하기

상탯값 변경 함수는 클래스형 컴포넌트의 setState 메서드와 조금 다르게 동작한다. setState 메서드는 기존 상탯값과 새로 입력된 값을 병합하지만 useState 훅의 상탯값 변경 함수는 이전 상탯값을 덮어쓴다. 

다음은 여러 상탯값을 객체에 담아서 관리하는 코드다.

```jsx
import React, { useState } from 'react';

function Profile() {
    const [state, setState] = useState({ name: '', age: 0 });
    return (
    	<div>
        	<p>{`name is ${state.name}`}</p>
        	<p>{`age is ${state.age}`}</p>
            <input type="text" value={state.name} onChange={e => setState({ ...state, name: e.target.value })} />
            <input type="number" value={state.age} onChange={e => setState({ ...state, age: e.target.value })} />
        </div>
    );
}
```

4행과 같이 두 상탯값을 하나의 객체로 관리한다. onChange를 보면 useState 훅은 이전 상탯값을 덮어쓰기 때문에 ...state와 같은 코드가 필요하다. 이렇게 상탯값을 하나의 객체로 관리할 때는 useReducer 훅을 사용하는 게 좋다.

> **상탯값 변경이 배치로 처리되지 않는 경우**
>
> 리액트는 내부에서 관리하는 이벤트 처리 함수에 대해서만 상탯값 변경을 배치로 처리한다. 다음과 같이 리액트 외부에서 관리되는 이벤트 처리 함수의 경우에는 상탯값 변경이 배치로 처리되지 않는다. 
>
> ```jsx
> function MyComponent() {
>     const [count, setCount] = useState(0);
>     useEffect(() => {
>         function onClick() {
>             setCount(prev => prev + 1);
>             setCount(prev => prev + 1);
>         }
>         window.addEventListner("click", onClick);
>         return () => window.removeEventListner("click", onClick);
>     }, []);
>     console.log("render called");
>     // ...
> }
> ```
>
> useEffect 훅은 부수 효과를 처리하는 용도로 사용된다. 컴포넌트 최초 렌더링 후, useEffect에 입력된 함수가 한 번만 호출되도록 작성한 코드다. useEffect 훅에 대한 내용은 우선 이 정도만 이해하자. 자세한 내용은 바로 뒤에서 설명한다. window 객체에 이벤트 처리 함수를 등록한다. 리액트 요소에 등록되지 않은 이벤트 처리 함수는 리액트 내부에서 관리되지 않는다. 이처럼 리액트 외부에 등록된 이벤트 처리 함수에서 상탯값 변경 함수를 호출하면 배치로 처리되지 않는다. 따라서 화면을 한 번 클릭하면 로그가 두 번 출력된다. 
>
> 리액트 외부에서 관리되는 이벤트 처리 함수에서도 원한다면 상탯값 변경을 배치로 처리할 수 있다. 다음과 같이 unstable_batchedUpdates 함수를 이용하면 상탯값 변경 함수는 모두 배치로 처리된다. 
>
> ```jsx
> function onClick() {
>     ReactDOM.unstable_batchedUpdates(() => {
>         setCount(prev => preev + 1);
>         setCount(prev => preev + 1);
>     });
> }
> ```
>
> 이름에서 알 수 있듯이 안정화된 API가 아니므로 꼭 필요한 경우가 아니라면 사용하지 않는 게 좋다. 
>
> 참고로 concurrent 모드로 동작할 미래의 리액트는 외부에서 관리되는 이벤트 처리 함수도 배치로 처리할 것으로 예상된다. 

#### 컴포넌트에서 부수 효과 처리하기: useEffect

함수 실행 시 함수 외부의 상태를 변경하는 연산을 부수 효과라고 한다. 특별한 이유가 없다면 모든 부수 효과는 useEffect 훅에서 처리하는 게 좋다.

API를 호출하는 것과 이벤트 처리 함수를 등록하고 해제는 것 등이 부수 효과의 구체적인 예다. 이 두 가지 기능을 각각 useEffect 훅으로 구현해 볼 텐데, 그 전에 우선 useEffect 훅의 사용법을 알아보자. 다음은 useEffect 훅의 사용 예다.

```jsx
import React, { useState, useEffect } from 'react';

function MyComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
        document.title = `업데이트 횟수: ${count}`;
    });
    return <button onClick={() => setCount(count + 1)}>increase</button>;
}
```

useEffect 훅에 입력하는 함수를 부수 효과 함수라고 한다. 부수 효과 함수는 렌더링 결과가 실제 돔에 반영된 후 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 호출된다. 버튼을 클릭할 때마다 다시 렌더링되고, 렌더링이 끝나면 부수 효과 함수가 호출된다. 

##### 컴포넌트 API 호출하기

useEffect 훅을 이용해서 다음과 같이 API를 호출할 수 있다.

```jsx
import React, { useEffect, useState } from 'react';

function Profile({ userId }) {
    const [user, setUser] = useState(null);
    useEffect(() => {
       getUserApi(userId).then(data => setUser(data)); 
    }, [userId]);
    
    return (
    	<div>
        	{!user && <p>사용자 정보 가져오는 중...</p>}
            {user && (
            	<>
                	<p>{`name is ${user.name}`}</p>
                	<p>{`age is ${user.age}`}</p>
                </>
            )}
        </div>
    );
};
```

4행은 API 결괏값을 저장할 상탯값이다. useEffect의 부수 효과 함수에서 API 통신을 하며, 받아온 데이터는 user 상탯값에 저장한다. 부수 효과 함수는 렌더링할 때마다 호출되기 때문에 API 통신을 불필요하게 많이 하게 된다. 이를 방지하기 위해 useEffect 훅의 두 번째 매개변수로 배열을 입력하면, 배열의 값이 변경되는 경우에만 함수가 호출된다. 이 배열을 의존성 배열이라고 한다. 여기서는 userId 값이 변경되는 경우에만 API 통신을 하도록 설정한다.

대개의 경우 의존성 배열을 입력할 필요가 없다. useEffect 훅을 사용할 때 많은 버그가 의존성 배열을 잘못 입력하면서 발생한다. 

##### 이벤트 처리 함수를 등록하고 해제하기

다음은 useEffect 훅을 이용해서 이벤트 처리 함수를 등록하고 해제하는 코드다. 

```jsx
import React, { useEffect, useState } from 'react';

function WidthPrinter() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner('resize', onResize);
        return () => {
            window.removeEventListner('resize', onResize);
        };
    }, []);
    return <div>{`width is ${width}`}</div>;
}
```

window.addEventListner를 통해 창 크기가 변경될 때마다 onResize 이벤트 처리 함수가 호출되도록 등록한다. return에서 부수 효과 함수는 함수를 반환할 수 있다. 반환된 함수는 부수 효과 함수가 호출되기 직전에 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 호출된다. 따라서 부수 효과 함수가 반환한 함수는 프로그램이 비정상적으로 종료되지 않는다면 반드시 호출될 것이 보장된다. 의존성 배열로 빈 배열을 입력하면 컴포넌트가 생성될 때만 부수 효과 함수가 호출되고, 컴포넌트가 사라질 때만 반환된 함수가 호출된다. 

#### 훅 직접 만들기

리액트가 제공하는 훅을 이용해서 커스텀(custom) 훅을 만들 수 있다. 그리고 커스텀 훅을 이용해서 또 다른 커스텀 훅을 만들 수도 있다. 훅을 직접 만들어서 사용하면 쉽게 로직을 재사용할 수 있다. 

리액트의 내장 훅처럼 커스텀 훅의 이름은 use로 시작하는 게 좋다. 그러면 코드 가독성이 좋아지고, 여러 리액트 개발 도구의 도움도 쉽게 받을 수 있다.

##### useUser 커스텀 훅

위의 코드에서 작성했던 사용자 데이터를 관리하는 로직을 다음과 같이 커스텀 훅으로 분리할 수 있다.

```jsx
function useUser(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    return user;
}

function Profile({ userId }) {
    const user = useUser(userId);
    // ...
}
```

useState 훅과 useEffect 훅을 이용해서 커스텀 훅을 만들었다. 이렇게 레고 블록처럼 기존 훅을 이용해서 새로운 훅을 만들 수도 있다는 점은 매력적이다. useUser 훅은 userId를 입력으로 받아서 user 객체를 출력해준다. 커스텀 훅도 리액트에서 제공하는 내장 훅과 마찬가지로 단순히 함수를 호출하는 방식으로 간단하게 사용할 수 있다. 

userId가 변경되면 자동으로 사용자 데이터를 받아온다. useUser 훅을 사용하는 코드를 보면 동기 방식으로 사용자 데이터를 가져오는 것처럼 보인다. 물론 사용자 데이터는 비동기로 받아온다. 커스텀 훅은 이렇게 내부 구현을 숨기면서 사용 편의성을 높였다. 

##### useWindowWidth 커스텀 훅

이전에 작성했던 창의 너비를 관리하는 로직을 useWindowWidth 커스텀 훅으로 만들어 보자. 

```jsx
import { useEffect, useState } from 'react';

function useWindowWidth() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner('resize', onResize);
        return () => {
            window.removeEventListner('resize', onResize);
        };
    }, []);
    return width;
}

function WidthPrinter() {
    const width = useWindowWidth();
    return <div>{`width is ${width}`}</div>;
}
```

useWindowWidth 훅은 창의 너비를 저장해 두고 필요할 때마다 값을 제공한다. 창의 너비가 변경되면 새로운 창의 너비로 다시 렌더링된다. 

##### useMounted 커스텀 훅

리액트에서 마운트란 컴포넌트의 첫 번째 렌더링 결과가 실제 돔에 반영된 상태를 말한다. 컴포넌트 마운트 여부를 알려 주는 useMounted 훅은 다음과 같이 작성할 수 있다. 

```jsx
function useMounted() {
    const [mounted, setMounted] = useState(false);
    useEffect(() => setMounter(true), []);
    return mounted;
}
```

mounted 상탯값은 첫 번째 렌더링 결과가 실제 돔에 반영된 후에 항상 참을 반환한다. setMounted 함수는 한 번만 호출해도 충분하므로 의존성 배열에 빈 배열을 입력한다. 

#### 훅 사용 시 지켜야 할 규칙

훅을 사용할 때는 다음 규칙을 지켜야 한다.

+ 규칙1: 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야 한다.
+ 규칙2: 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다.

이 두 규칙을 지켜야 리액트가 각 훅의 상태를 제대로 기억할 수 있다. 훅은 규칙2에 의해 클래스형 컴포넌트의 메서드뿐만 아니라 기타 일반 함수에서도 사용할 수 없다. 훅은 함수형 컴포넌트를 위한 기능이므로 당연한 규칙이다.

다음은 훅 사용 시 규칙1을 위반한 경우다.

```jsx
function MyComponent() {
    const [value, setValue] = useState(0);
    if (value === 0) {
        const [v1, setV1] = useState(0);
    } else {
        const [v1, setV1] = useState(0);
        const [v2, setV2] = useState(0);
    }
    // ...
    for (let i = 0; i < value; i++) {
        const [num, setNum] = useState(0);
    }
    // ...
    function func1() {
        const [num, setNum] = useState(0);
    }
    // ...
}
```

조건에 따라 훅을 호출하면 순서가 보장되지 않는다. 루프 안에서 훅을 호출하는 것도 순서가 보장되지 않는다. func1 함수가 언제 호출될지 알 수 없기 때문에 마찬가지로 순서가 보장되지 않는다.

##### 훅의 호출 순서가 같아야 하는 이유

다음 코드를 기반으로 훅의 호출 순서가 같아야 하는 이유를 알아보자.

```jsx
function Profile() {
    const [age, setAge] = useState(0);
    const [name, setName] = useState('');
    // ...
    useEffect(() => {
        // ...
        setAge(23);
    }, []);
    // ...
}
```

우리가 useState 훅에 전달한 정보는 상탯값의 기본값 밖에 없다. 리액트가 age와 name 상탯값을 구분할 수 있는 유일한 정보는 훅이 사용된 순서다. age 상탯값이 23으로 변경됐다. 리액트는 첫 번째 훅의 상탯값을 23으로 설정한다. 만약 2행이 조건문에 의해 실행되지 않는다면 3행의 name 값은 23이 되므로 문제가 된다. 

##### 리액트가 내부적으로 훅을 처리하는 방식

훅이 사용된 순서를 리액트가 내부적으로 어떻게 관리하는지 알아보자. 다음은 리액트의 내부 구현을 보여 주는 의사코드(pseudo-code)다. 

```jsx
let hooks = null;

export function useHook() {
    // ...
    hooks.push(hookData);
}

function process_a_component_rendering(component) {
    hooks = [];
    component();
    let hooksForThisComponent = hooks;
    hooks = null;
    // ...
}
```

useHook은 리액트가 내장하고 있는 useState, useEffect와 같은 훅이다. 각 훅 함수에서는 hooks 배열에 자신의 데이터를 추가한다. process_a_component_rendering은 렌더링 과정에서 하나의 컴포넌트를 처리하는 함수다. hooks를 빈 배열로 초기화하고 컴포넌트 내부에서 훅을 사용한 만큼 hooks 배열에 데이터가 추가된다. hooksForThisComponent에서 생성된 배열을 저장한 후 hooks 변수를 초기화한다. 이처럼 리액트는 훅이 사용된 순서를 저장하고 배열에 저장된 순서를 기반으로 훅을 관리한다. 

### 콘텍스트 API로 데이터 전달하기

보통 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 속성값이 사용되는데, 가까운 거리에 있는 몇 개의 하위 컴포넌트로 전달할 때는 속성값으로 충분하다. 하지만 많은 수의 하위 컴포넌트로 전달할 때는 속성값을 내려 주는 코드를 반복적으로 작성해야 하는 문제가 있다. 특히 하위 컴포넌트가 상위 컴포넌트에서 상당히 멀리 떨어져 있다면 중간에 있는 컴포넌트에서 기계적으로 속성값을 전달하는 코드를 작성해야 한다. 이럴 때 콘텍스트 API를 사용하면 컴포넌트의 중첩 구조가 복잡한 상황에서도 비교적 쉽게 데이터를 전달할 수 있다. 콘텍스트 API를 사용하면 상위 컴포넌트에서 하위에 있는 모든 컴포넌트로 직접 데이터를 전달할 수 있다. 이때 중간에 있는 컴포넌트는 콘텍스트 데이터의 존재를 몰라도 되므로 속성값을 반복해서 내려 주던 문제가 사라진다. 

다음 코드는 App 컴포넌트에서 Greeting 컴포넌트로 속성값을 전달한다. 

```jsx
function App() {
    return (
    	<div>
        	<div>상단 메뉴</div>
            <Profile username="mike" />
            <div>하단 메뉴</div>
        </div>
    );
}

function Profile({ username }) {
    return (
    	<div>
        	<Greeting username={username} />
            {/* ... */}
        </div>
    );
}

function Greeting({ username }) {
    return <p>{`${username}님 안녕하세요`}</p>;
}
```

부모 컴포넌트에서 중간에 있는 Profile 컴포넌트로 속성값을 전달한다. Profile 컴포넌트는 username 속성값을 사용하지 않고 기계적으로 전달한다. 

#### 콘텍스트 API 이해하기

콘텍스트 API를 사용하면 Profile 컴포넌트가 중간에 개입하지 않고도 속성값을 전달할 수 있다. 다음은 위의 코드를 콘텍스트 API를 사용해서 다시 작성한 코드다. 

```jsx
const UserContext = React.createContext('');

function App() {
    return (
    	<div>
        	<UserContext.Provider value="mike">
            	<div>상단 메뉴</div>
                <Profile />
                <div>하단 메뉴</div>
            </UserContext.Provider>
        </div>
    );
}

function Profile() {
    return (
    	<div>
        	<Greeting />
            {/* ... */}
        </div>
    );
}

function Greeting() {
    return (
    	<UserContext.Consumer>
        	{username => <p>{`${username}님 안녕하세요`}</p>}
        </UserContext.Consumer>
    );
}
```

1행에서 createContext 함수를 호출하면 콘텍스트 객체가 생성된다. createContext 함수의 구조는 다음과 같다.

```jsx
React.createContext(defaultValue) => {Provider, Consumer}
```

6행의 상위 컴포넌트에서는 Provider 컴포넌트를 이용해서 데이터를 전달한다. Greeting()의 `<UserContext.Consumer>`는 Consumer 컴포넌트를 이용해서 데이터를 사용한다. Consumer 컴포넌트는 데이터를 찾기 위해 상위로 올라가면서 가장 가까운 Provider 컴포넌트를 찾는다. 만약 최상위에 도달할 때까지 Provider 컴포넌트를 찾지 못한다면 기본값이 사용된다. 기본값 덕분에 Provider 컴포넌트가 없어도 되므로, 어렵지 않게 Greeting 컴포넌트의 테스트 코드를 작성할 수 있다. 

Provider 컴포넌트의 속성값이 변경되면 하위의 모든 Consumer 컴포넌트는 다시 렌더링된다. 한 가지 중요한 점은 중간에 위치한 컴포넌트의 렌더링 여부와 상관없이 Consumer 컴포넌트는 다시 렌더링된다는 점이다. 

다음은 username을 수정할 때 React.memo를 사용해서 Profile 컴포넌트가 다시 렌더링되지 않도록 수정한 코드다.

```jsx
function App() {
    const [username, setUsername] = useState("");
    return (
    	<div>
        	<UserContext.Provider value={username}>
            	<Profile />
            </UserContext.Provider>
            <input type="text" value={username} onChange={e => setUsername(e.target.value)} />
        </div>
    );
}

const Profile = React.memo(() => {
    return (
    	<Greeting />
        {/* ... */}
    );
});

function Greeting() {
    return (
    	<UserContext.Consumer>
        	{username => <p>{`${username}님 안녕하세요`}</p>}
        </UserContext.Consumer>
    );
}
```

username 상탯값이 변경되면, App 컴포넌트는 다시 렌더링된다. Profile 컴포넌트는 React.memo로 만들어졌고 속성값이 없기 때문에 최초 한 번만 렌더링된다. Profile 컴포넌트의 렌더링 여부와 상관없이 Greeting 컴포넌트의 Consumer 컴포넌트는 다시 렌더링된다. 즉, 중간 컴포넌트의 렌더링 여부와 상관없이 Provider 컴포넌트로 새로운 데이터가 입력되면 Consumer 컴포넌트가 다시 렌더링되는 것이 보장된다. 

#### 콘텍스트 API 활용하기

콘텍스트 API를 본격적으로 사용하기 위해 필요한 몇 가지 활용법을 알아보자. 지금까지는 하나의 콘텍스트 객체만 사용하고, Provider 컴포넌트를 사용하는 쪽에서만 콘텍스트 데이터를 수정했다. 반대로 여러 콘텍스트 객체를 중첩해서 사용하고, Consumer 컴포넌트를 사용하는 하위 컴포넌트에서 콘텍스트 데이터를 수정하는 방법을 알아보자.

##### 여러 콘텍스트를 중첩해서 사용하기

여러 콘텍스트의 Provider, Consumer 컴포넌트를 중첩해서 사용할 수도 있다. 다음은 두 개의 콘텍스트를 중첩해서 사용한 코드다.

```jsx
const UserContext = React.createContext('');
const ThemeContext = React.createContext('dark');

function App() {
    return (
    	<div>
        	<ThemeContext.Provider value="light">
            	<UserContext.Provider value="mike">
                	<div>상단 메뉴</div>
                    <Provider />
                    <div>하단 메뉴</div>
                </UserContext.Provider>
            </ThemeContext.Provider>
        </div>
    );
}

function Profile() {
    return (
    	<div>
        	<Greeting />
            {/* ... */}
        </div>
    );
}

function Greeting() {
    return (
    	<ThemeContext.Consumer>
        	{theme => (
            	<UserContext.Provider>
              		{username => (
                    	<p style={{ color: theme === 'dark' ? 'gray' : 'green'}}>
                        	{`${username}님 안녕하세요`}
                        </p>
                    )}
                </UserContext.Provider>
            )}
        </ThemeContext.Consumer>
    );
}
```

App 컴포넌트에서 두 개의 Provider 컴포넌트를 중첩해서 사용할 수 있다. Greeting 컴포넌트에서도 마찬가지로 Consumer 컴포넌트도 중첩해서 사용할 수 있다. 렌더링 성능상 이점이 없긴 하지만 보통의 경우 이렇게 데이터의 종류별로 콘텍스트를 만들어서 사용하면 렌더링 성능상 이점이 있다. 이는 데이터 변경 시 해당 Consumer 컴포넌트만 렌더링되기 때문이다. 

##### 하위 컴포넌트에서 콘텍스트 데이터를 수정하기

하위 컴포넌트에서도 콘텍스트 데이터를 수정할 수 있다. 리덕스에서 상태를 변경하는 디스패치(dispatch) 함수를 여러 컴포넌트에서 사용할 수 있는 것처럼 콘텍스트 데이터도 원하는 곳에서 변경할 수 있다. 다음은 하위 컴포넌트가 콘텍스트 데이터를 수정할 수 있도록 함수를 전달하는 상위 컴포넌트 코드다. 

```jsx
const UserContext = React.createContext({ username: "", helloCount: 0 });
const SetUserContext = React.createContext(() => {});

function App() {
    const [user, setUser] = useState({ username: "mike", helloCount: 0 });
    return (
    	<div>
        	<SetUserContext.Provider value={setUser}>
            	<UserContext.Provider value={user}>
                	<Profile />
                </UserContext.Provider>
            </SetUserContext.Provider>
        </div>
    );
}
```

2행과 같이 사용자 데이터를 수정하는 함수를 전달하기 위해 콘텍스트를 생성한다. 5행과 같이 사용자 데이터를 하나의 상탯값으로 관리한다. 상탯값 변경 함수는 SetUserContext 콘텍스트로 전달할 예정이다. 하위 컴포넌트 `<SetUserContext.Provider>`에서 사용자 데이터를 수정할 수 있도록 콘텍스트 데이터로 전달한다.

다음은 App 컴포넌트와 자식 컴포넌트에서 콘텍스트 데이터를 수정하는 코드다.

```jsx
function Greeting() {
    return (
    	<SetUserContext.Consumer>
        	{setUser => {
                <UserContext.Consumer>
                	{({ username, helloCount }) => (
                    	<React.Fragment>
                        	<p>{`${username}님 안녕하세요`}</p>
                            <p>{`인사 횟수: ${helloCount}`}</p>
                            <button onClick={() => setUser({ username, helloCount: helloCount + 1 })}>
                            	인사하기
                            </button>
                        </React.Fragment>
                    )}
                </UserContext.Consumer>
            }}
        </SetUserContext.Consumer>
    );
}
```

App 컴포넌트로부터 전달된 setUser 함수를 이용해서 이벤트 처리 함수를 구현한다. 이제 Greeting 컴포넌트의 버튼을 클릭하면 콘텍스트 데이터가 수정된다. 

앞의 코드는 helloCount 속성만 변경하는데도, 사용자 데이터를 만들어서 setUser 함수에 입력해야 한다는 단점이 있다. 리액트에서 제공하는 useReducer 훅을 사용하면 이를 개선할 수 있다. 

#### 콘텍스트 API 사용 시 주의할 점

이제 콘텍스트 API 사용 시 주의할 점을 알아보자. 콘텍스트 데이터가 변경되지 않은 상황에서 불필요한 렌더링이 발생하거나, Consumer 컴포넌트와 Provider 컴포넌트의 잘못된 위치 때문에 콘텍스트 데이터가 전달되지 않을 수 있다. 

##### 불필요한 렌더링이 발생하는 경우

콘텍스트 데이터로 객체를 사용할 때 주의하지 않으면 불필요한 렌더링이 발생할 수 있다. 다음은 렌더링 할 때마다 콘텍스트 데이터로 새로운 객체를 전달해서 불필요한 렌더링이 발생하는 예다. 

```jsx
const UserContext = React.createContext({ username: "" });

function App() {
    const [username, setUsername] = useState("");
    return (
    	<div>
        	<UserContext.Provider value={{ username }}>
            	// ...
            </UserContext.Provider>
        </div>
    );
}
```

`UserContext.Provider`는 콘텍스트로 데이터로 객체를 전달하고 있다. 이처럼 작성하면 컴포넌트가 렌더링될 때마다 새로운 객체가 생성된다. 따라서 username 값이 변경되지 않아도, 컴포넌트가 렌더링될 때마다 하위의 Consumer 컴포넌트도 다시 렌더링된다. 다음은 이 문제를 해결하는 코드다.

```jsx
function App() {
    const [user, setUser] = useState({ username: "" });
    return (
    	<div>
      		<UserContext.Provider value={user}>
            	// ...
            </UserContext.Provider>  
        </div>
    );
}
```

2행과 같이 콘텍스트 데이터 전체를 상탯값으로 관리한다. `<UserContext.Provider>`에서 username 값이 변경될 때만 새로운 객체가 전달되므로 불필요한 렌더링이 발생하지 않는다. 

##### Provider 컴포넌트를 찾지 못하는 경우

Consumer 컴포넌트와 Provider 컴포넌트를 적절한 위치에서 사용하지 않으면 콘텍스트 데이터가 전달되지 않는다. 다음은 Consumer 컴포넌트가 상위 컴포넌트에서 Provider 컴포넌트를 찾지 못하는 경우를 보여 준다. 

```jsx
const UserContext = React.createContexxt('unknown');

function App() {
    return (
    	<div>
        	<UserContext.Provider value="mike">
            	{/* ... */}
            </UserContext.Provider>
            <Profile />
        </div>
    );
}
```

Profile 컴포넌트 안쪽에서 사용된 Consumer 컴포넌트는 최상위에 도달할 때까지 Provider 컴포넌트를 찾지 못한다. 따라서 콘텍스트 데이터의 기본값인 unknown이 사용된다. 

### ref 속성값으로 자식 요소에 접근하기

리액트로 작업하다 보면 돔 요소에 직접 접근해야 할 때가 있다. 예를 들어, 돔 요소에 포커스를 주거나 돔 요소의 크기나 스크롤 위치를 알고 싶은 경우다. 이때 ref 속성값을 이용하면 자식 요소에 직접 접근할 수 있따. 자식 요소는 컴포넌트일 수도 있고 돔 요소일 수도 있다. 

#### ref 속성값 이해하기

다음은 ref 속성값을 이용해서 돔 요소를 제어하는 코드다. 

```jsx
import React, { useRef, useEffect } from "react";

function TextInput() {
    const inputRef = useRef();
    
    useEffect(() => {
        inputRef.current.focus();
    }, []);
    
    return (
    	<div>
        	<input type="text" ref={inputref} />
            <button>저장</button>
        </div>
    );
}
```

4행에서 useRef 훅이 반환하는 ref 객체를 이용해서 자식 요소에 접근할 수 있다. input 태그에서 접근하고자 하는 자식 요소의 ref 속성값에 ref 객체를 입력한다. 해당 돔 요소 혹은 컴포넌트가 생성되면 ref 객체로 접근할 수 있다. useEffect에서 ref 객체의 current 속성을 이용하면 자식 요소에 접근할 수 있다. 

useEffect 훅 내부에서 자식 요소에 접근하고 있다는 점에 주목하자. 부수 효과 함수는 컴포넌트 렌더링 결과가 돔에 반영된 후에 호출되므로 해당 돔 요소는 이미 생성된 상태다. 

#### ref 속성값 활용하기

ref 속성값의 다양한 기능과 활용법을 알아보자. 함수형 컴포넌트에서 ref 속성값을 사용하는 방법, forwardRef 함수로 ref 속성값을 직접 처리하는 방법, ref 속성값으로 함수 사용하는 방법에 대해 알아본다. 

##### 함수형 컴포넌트에서 ref 속성값 사용하기

클래스형 컴포넌트에 ref 속성값을 입력하면 ref.current는 해당 컴포넌트의 인스턴스를 가리킨다. 따라서 ref.current로 해당 클래스의 메서드를 호출할 수 있다. 

함수형 컴포넌트는 인스턴스로 만들어지지 않지만 useImperativeHandle 훅을 사용하면 함수형 컴포넌트에서도 변수와 함수를 외부로 노출시킬 수 있다. 

함수형 컴포넌트에 ref 속성값을 입력할 수는 없지만, 다른 이름으로 ref 객체를 입력받아서 내부의 리액트 요소에 연결할 수는 있다. 다음은 inputRef라는 이름으로 속성값을 입력받아서 input 요소에 연결하는 코드다.

```jsx
function TextInput({ inputRef }) {
    return (
    	<div>
        	<input type="text" ref={inputRef} />
            <button>저장</button>
        </div>
    );
}

function Form() {
    const inputRef = useRef();
    useEffect(() => {
        inputRef.current.focus();
    }, []);
    
    return (
    	<div>
        	<TextInput inputRef={inputRef} />
            <button onClick={() => inputRef.current.focus()}>텍스트로 이동</button>
        </div>
    );
}
```

TextInput 컴포넌트는 inputRef 속성값을 input 요소의 ref 속성값으로 넣고 있다. 부모 컴포넌트 입장에서는 손자 요소에 ref 속성값을 넣는 형태가 된다. 이 방법은 TextInput 컴포넌트의 내부 구조를 외부에서 알아야 하므로 썩 좋지는 않다. 따라서 손자 요소의 ref 속성값을 이용하는 방법은 꼭 필요한 경우에만 사용하기 바란다. 

##### forwardRef 함수로 ref 속성값을 직접 처리하기

컴포넌트의 재사용성을 높이기 위해 Button처럼 단순한 컴포넌트를 만들어서 사용하는 경우가 많다. 이런 작은 컴포넌트는 돔 요소와 밀접하게 연관되어 있기 때문에 ref 속성값을 손자 요소로 연결하는 게 자연스럽다. 

위의 코드에서는 inputRef라는 독자적인 이름의 속성값을 사용했지만, 일관성을 위해 ref라는 이름을 사용하는 게 좋다. 하지만 컴포넌트에 ref 속성값을 사용하면 리액트가 내부적으로 처리하기 때문에 손자 요소에 연결할 수 없다. 이런 경우 forwardRef 함수를 사용하면 ref 속성값을 직접 처리할 수 있다. 

```jsx
const TextInput = React.forwardRef((props, ref) => {
   <div>
  		<input type="text" ref={ref} />
        <button>저장</button>
   </div> 
});

function Form() {
    // ...
    return (
    	<div>
        	<TextInput ref={inputRef} />
            <button onClick={() => inputRef.current.focus()}>텍스트로 이동</button>
        </div>
    );
}
```

forwardRef 함수를 이용하면 부모 컴포넌트에서 넘어온 ref 속성값을 직접 처리할 수 있다. 이전 코드에서 inputRef로 사용했던 이름을 리액트의 예약어인 ref로 사용할 수 있게 됐다.

#### ref 속성값으로 함수 사용하기

지금까지 useRef 훅으로 만들어진 ref 객체를 속성값에 연결하는 경우를 살펴봤다. ref 속성값에 함수를 입력하면 자식 요소가 생성되거나 제거되는 시점에 호출된다. 다음은 ref 속성값에 함수를 입력하는 경우를 보여준다.

```jsx
function Form() {
    const [text, setText] = useState(INITIAL_TEXT);
    const [showText, setShowText] = useState(true);
    return (
    	<div>
        	{showText && (
            	<input type="text" ref={ref => ref && setText(INITIAL_TEXT)} value={text} onChange={e => setText(e.target.value)} />
            )}
            <button onClick={() => setShowText(!showText)}>보이기/가리기</button>
        </div>
    );
}

const INITIAL_TEXT = "안녕하세요";
```

보이기/가리기 버튼을 누르면 input 요소가 제거되거나 생성된다. ref 속성값으로 입력한 함수는 해당 요소가 제거되거나 생성될 때마다 호출된다. 요소가 생성될 때는 해당 요소를 참조하는 변수가 넘어오고, 삭제될 때는 null 값이 넘어온다. 따라서 요소가 생성될 때만 INITIAL_TEXT가 입력되도록 했다. 

하지만 코드를 실행하면 의도한 대로 동작하지 않는다. input 요소에 텍스트를 입력해도 화면에는 INITIAL_TEXT만 보인다. 이는 컴포넌트가 렌더링될 때마다 새로운 함수를 ref 속성값으로 넣기 때문이다. 리액트는 ref 속성값으로 새로운 함수가 들어오면 이전 함수에 null 인수를 넣어서 호출하고, 새로운 함수에는 요소의 참조값을 넣어서 호출한다. 따라서 텍스트를 입력하면 컴포넌트가 렌더링되고, ref 속성값에 입력된 새로운 함수가 호출되면서 INITIAL_TEXT로 덮어쓰는 것이다. 

이 문제는 다음과 같이 고정된 함수를 입력하면 해결된다.

```jsx
import React, { useState, useCallback } from "react";

function Form() {
    const [text, setText] = useState(INITIAL_TEXT);
    const [showText, setShowText] = useState(true);
    
    const setInitialText = useCallback(ref => ref && setText(INITIAL_TEXT), []);
    
    return (
    	<div>
        	{showText && (
            	<input type="text" ref={setInitialText} value={text} onChange={e => setText(e.target.value)} />
            )}
            // ...
        </div>
    );
}
```

7행과 같이 리액트에서 제공하는 useCallback 훅을 이용해서 setInitialText 함수를 변하지 않게 만들었다. 여기서는 useCallback 훅의 메모이제이션 기능 덕분에 한 번 생성된 함수를 계속 재사용한다는 것만 알아두자. ref 속성값에 새로운 함수를 입력하지 않으므로 input 요소가 생성되거나 제거될 때만 setInitialText 함수가 호출된다. 

이렇게 ref 속성값으로 함수를 사용하면 돔 요소의 생성과 제거 시점을 알 수 있다. 

#### ref 속성값 사용 시 주의할 점

컴포넌트가 생성된 이후라도 ref 객체의 current 속성이 없을 수 있기 때문에 주의해야 한다. 

```jsx
function Form() {
    const inputRef = useRef();
    const [showText, setShowText] = useState(true);
    
    return (
    	<div>
        	{showText && <input type="text" ref={inputRef} />}
            <button onClick={() => inputRef.current.focus()}>텍스트로 이동</button>
        </div>
    );
}
```

ref 속성값을 입력한 input 요소는 showText 상탯값에 따라 존재하지 않을 수 있다. 이렇게 조건부 렌더링을 하는 경우에는 컴포넌트가 생성된 이후라 하더라도 ref 객체를 사용할 때 주의해야 한다. input 요소가 존재하지 않는 상태에서 텍스트로 이동 버튼을 누르면 inputRef 객체의 current 속성은 존재하지 않기 때문에 에러가 발생한다. 

따라서 조건부 렌더링이 사용된 요소의 ref 객체는 current 속성을 검사하는 코드가 필요하다. 

 ```jsx
<button onClick={() => inputRef.current && inputRef.current.focus()}>텍스트로 이동</button>
 ```

### 리액트 내장 훅 살펴보기

리액트는 useState, useEffect 외에도 다양한 훅을 제공한다. 리액트에 내장된 훅을 하나씩 살펴보자. 

#### Consumer 컴포넌트 없이 콘텍스트 사용하기: useContext

useContext 훅을 이용하면 Consumer 컴포넌트를 사용하지 않고도 부모 컴포넌트로부터 전달된 콘텍스트 데이터를 사용할 수 있다. 

다음은 훅을 사용하지 않고 기존 방식으로 콘텍스트 API를 사용한 코드다.

```jsx
const UserContext = React.createContext();
const user = { name: 'mike', age: 23 };

function ParentComponent() {
    return (
    	<UserContext.Provider value={user}>
        	<ChildComponent />
        </UserContext.Provider>
    );
}

function ChildComponent() {
    // ...
    return (
    	<div>
        	<UserContext.Consumer>
            	{user => {
                    <>
                    	<p>{`name is ${user.name}`}</p>
                    	<p>{`age is ${user.age}`}</p>
                    </>
                }}
            </UserContext.Consumer>
        </div>
    );
}
```

부모 컴포넌트에서는 Provider 컴포넌트를 통해서 데이터를 전달한다. 자식 컴포넌트에서는 Consumer 컴포넌트를 통해서 데이터를 사용한다. 이 방식은 Consumer 컴포넌트 안쪽에서만 콘텍스트 데이터에 접근할 수 있다는 한계가 있다. `// ...` 영역에서 콘텍스트 데이터를 사용하기 위해서는 복잡한 방법을 쓸 수 밖에 없다. 

다음과 같이 useContext 훅을 사용하면 `// ...` 영역에서도 콘텍스트 데이터에 접근할 수 있다.

```jsx
function ChildComponent() {
    const user = useContext(UserContext);
	console.log(`user: ${user.name}, ${user.age}`);
	// ...
}
```

Consumer 컴포넌트를 사용하면 JSX 부분이 복잡해지는 단점이 있지만, useContext 훅은 사용하기 간편하다는 장점이 있다.

#### 렌더링과 무관한 값 저장하기: useRef

useRef 훅은 자식 요소에 접근하는 것 외에도 중요한 용도가 한 가지 더 있다. 컴포넌트 내부에서 생성되는 값 중에는 렌더링과 무관한 값도 있는데, 이 값을 저장할 때 useRef 훅을 사용한다. 예를 들어 setTimeout이 반환하는 값은 어딘가에 저장해 두었다가 적절한 시점에서 clearTimeout을 호출할 때 사용해야 한다. 

다음은 useRef 훅을 이용해서 이전 상탯값을 저장하는 코드다. 

```jsx
import React, { useState, useRef, useEffect } from 'react';

function Profile() {
    const [age, setAge] = useState(20);
    const prevAgeRef = useRef(20);
    useEffect(
    	() => {
            prevAgeRef.current = age;
        }, 
        [age], 
    );
    const prevAge = prevAgeRef.current;
    const text = age === prevAge ? 'same' : age > prevAge ? 'older' : 'younger';
    return (
    	<div>
        	<p>{`age ${age} is ${text} than age ${prevAge}`}</p>
            <button 
                onClick={() => {
                    const age = Math.floor(Math.random() * 50 + 1);
                    setAge(age);
                }}>나이 변경</button>            
        </div>
    );
}
```

5행에서 age의 이전 상탯값을 저장하기 위한 용도로 useRef 훅을 사용한다. age 값이 변경되면 그 값을 prevAgeRef에 저장한다. const text에 age의 이전 상탯값을 이용한다. 나이 변경 button 클릭 시 age가 변경돼서 다시 렌더링할 때 const text의 prevAge는 age의 이전 상탯값을 나타낸다. 그리고 렌더링이 끝나면 prevAgeRef는 age의 최신 상탯값으로 변경된다.

#### 메모이제이션 훅: useMemo, useCallback

useMemo와 useCallback은 이전 값을 기억해서 성능을 최적화하는 용도로 사용된다. useMemo와 useCallback의 사용법을 알아보고 어떤 차이가 있는지 살펴보자.

##### useMemo

useMemo 훅은 계산량이 많은 함수의 반환값을 재활용하는 용도로 사용된다. 다음은 useMemo 훅의 사용 예다.

```jsx
import React, { useMemo } from 'react';
import { runExpensiveJob } from './util';

function MyComponent({ v1, v2 }) {
    const value = useMemo(() => runExpensiveJob(v1, v2), [v1, v2]);
    return <p>{`value is ${value}`}</p>;
}
```

useMemo 훅의 첫 번째 매개변수로 함수를 입력한다. useMemo 훅은 이 함수가 반환한 값을 기억한다. useMemo 훅의 두 번째 매개변수는 의존성 배열이다. 의존성 배열이 변경되지 않으면 이전에 반환된 값을 재사용한다. 만약 배열의 값이 변경됐으면 첫 번째 매개변수로 입력한 함수를 실행하고 그 반환값을 기억한다. 

##### useCallback

useMemo 훅은 로다시 같은 라이브러리에서 제공해 주는 메모이제이션과 비슷하다. 반면에 useCallback은 리액트의 렌더링 성능을 위해 제공되는 훅이다. 

컴포넌트가 렌더링될 때마다 새로운 함수를 생성해서 자식 컴포넌트의 속성값으로 입력하는 경우가 많다. 리액트 팀에서는 최근 브라우저에서 함수 생성이 성능에 미치는 영향은 작다고 주장한다. 그보다는 속성값이 매번 변경되기 때문에 자식 컴포넌트에서 React.memo를 사용해도 불필요한 렌더링이 발생한다는 문제점이 있다. 리액트에서는 이 문제를 해결하기 위해 useCallback 훅을 제공한다. 

다음은 useCallback 훅이 필요한 예다. 

```jsx
import React, { useState } from 'react';
import { saveToServer } from './api';
import UserEdit from './UserEdit';

function Profile() {
    const [name, setName] = useState('');
    const [age, setAge] = useState(0);
    return (
    	<div>
        	<p>{`name is ${name}`}</p>
        	<p>{`age is ${age}`}</p>
            <UserEdit 
            	onSave={() => saveToServer(name, age)}
                setName={setName}
                setAge={setAge}
            />
        </div>
    );
}
```

Profile 컴포넌트가 렌더링될 때마다 UserEdit 컴포넌트의 onSave 속성값으로 새로운 함수가 입력된다. 따라서 UserEdit 컴포넌트에서 React.memo를 사용해도 onSave 속성값이 항상 변경되고 그 때문에 불필요한 렌더링이 발생한다. onSave 속성값은 name이나 age 값이 변경되지 않으면 항상 같아야 한다.

useCallback 훅을 사용하면 불필요한 렌더링을 막을 수 있다. 다음은 useCallback 훅을 사용한 코드다.

```jsx
// ...
function Profile() {
    const [name, setName] = useState('');
    const [age, setAge] = useState(0);
    const onSave = useCallback(() => saveToServer(name, age), [name, age]);
    return (
    	<div>
        	<p>{`name is ${name}`}</p>
        	<p>{`age is ${age}`}</p>
            <UserEdit 
            	onSave={onSave}
                setName={setName}
                setAge={setAge}
            />
        </div>
    );
}
```

이전에 onSave 속성값으로 전달했던 것과 같은 함수를 useCallback 훅의 첫 번째 매개변수로 입력한다. useCallback 훅의 두 번째 매개변수는 의존성 배열이다. 의존성 배열이 변경되지 않으면 이전에 생성한 함수가 재사용된다. 따라서 name과 age 값이 변경되지 않으면, UserEdit 컴포넌트의 onSave 속성값으로 항상 같은 함수가 전달된다. 

#### 컴포넌트의 상탯값을 리덕스처럼 관리하기: useReducer

useReducer 훅을 사용하면 컴포넌트의 상탯값을 리덕스의 리듀서처럼 관리할 수 있다. 다음은 useReducer 훅의 사용 예다.

```jsx
import React, { useReducer } from 'react';

const INITIAL_STATE = { name: 'empty', age: 0 };
function reducer(state, action) {
    switch (action.type) {
        case 'setName':
            return { ...state, name: action.name };
        case 'setAge':
            return { ...state, age: action.age};
        default: 
            return state;
    }
}

function Profile() {
    const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
    return (
    	<div>
        	<p>{`name is ${state.name}`}</p>
        	<p>{`age is ${state.age}`}</p>
            <input type="text" value={state.name} 
                onChange={e => dispatch({ type: 'setName', name: e.currentTarget.value })}
            />
            <input type="number" value={state.age} 
                onChange={e => dispatch({ type: 'setAge', age: e.currentTarget.value })}
            />
        </div>
    );
}
```

INITIAL_STATE는 리덕스의 리듀서와 같은 방식으로 작성한 리듀서 함수다. Profile 컴포넌트에서 useReducer 훅의 매개변수로 앞에서 작성한 리듀서와 초기 상탯값을 입력한다. useReducer 훅은 상탯값과 dispatch 함수를 차례대로 반환한다. dispatch 함수는 리덕스의 dispatch 함수와 같은 방식으로 사용된다. 

##### 트리의 깊은 곳으로 이벤트 처리 함수 전달하기

보통 상위 컴포넌트에서 다수의 상탯값을 관리한다. 이때 자식 컴포넌트로부터 발생한 이벤트에서 상위 컴포넌트의 상탯값을 변경해야 하는 경우가 많다. 이를 위해 상위 컴포넌트에서 트리의 깊은 곳까지 이벤트 처리 함수를 전달한다. 이 작업은 상당히 손이 많이 가고, 코드의 가독성도 떨어진다. 

useReducer 훅과 콘텍스트 API를 이용하면 다음과 같이 상위 컴포넌트에서 트리의 깊은 곳으로 이벤트 처리 함수를 쉽게 전달할 수 있다. 

```jsx
// ...
export const ProfileDispatch = React.createContext(null);
// ...
function Profile() {
    const [state, dispatch] = usereducer(reducer, INITIAL_STATE);
    return (
    	<div>
        	<p>{`name is ${state.name}`}</p>
        	<p>{`age is ${state.age}`}</p>
            <ProfileDispatch.Provider value={dispatch}>
            	<SomeComponent />
            </ProfileDispatch.Provider>
        </div>
    );
}
```

2행은 dispatch 함수를 전달해 주는 콘텍스트 객체를 생성한다. Provider를 통해서 dispatch 함수를 데이터로 전달한다. SomeComponent 하위에 있는 모든 컴포넌트에서는 콘텍스트를 통해서 dispatch 함수를 호출할 수 있다.

useReducer 훅의 dispatch 함수는 값이 변하지 않는 특징이 있어서 콘텍스트의 Consumer 컴포넌트가 불필요하게 자주 렌더링되는 일이 발생하지 않는다. 

