## 중요하지만 헷갈리는 리액트 개념

프레임워크나 라이브러리를 온전히 이해하지 못한 채로 프로젝트를 시작하면 기술 부채가 늘어난다. 어설프게 알고 있던 내용이 있다면 이 기회에 확실히 이해하자.

### 상탯값과 속성값으로 관리하는 UI 데이터

UI 라이브러리인 리액트는 UI 데이터를 관리하는 방법을 제공한다. UI 데이터는 컴포넌트 내부에서 관리되는 상탯값과 부모 컴포넌트에서 내려 주는 속성값으로 구성된다. 리덕스와 같이 전역 데이터를 관리해 주는 라이브러리를 리액트에 적용할 때도 결국에는 컴포넌트의 상탯값과 속성값을 이용해서 구현한다.

UI 데이터가 변경되면 화면을 다시 그려야 하낟. 리액트와 같은 UI 라이브러리를 사용하지 않는다면 UI 데이터가 변경될 때마다 돔 요소를 직접 수정해야 한다. 그런데 돔 요소를 직접 수정하다 봄녀 비즈니스 로직과 UI를 수정하는 코드가 뒤섞여지고, 코드가 복잡해진다. 그래서 리액트는 화면을 그리는 모든 코드를 컴포넌트 함수에 선언형으로 작성하도록 했다. UI 데이터가 변경되면 리액트가 컴포넌트 함수를 이용해서 화면을 자동으로 갱신해 주며, 이것이 리액트의 가장 중요한 역할이다. 

#### 리액트를 사용한 코드의 특징

리액트 코드와 리액트를 사용하지 않은 코드를 비교해 보면서 리액트의 특징을 살펴보자. 다음은 리액트와 같은 라이브러리를 사용하지 않고 직접 UI를 관리하는 코드다. 할 일 목록을 추가하거나 삭제할 수 있는 간단한 프로그램이다. 

```html
<html>
	<body>
    	<div class="todo">
        	<h3>할 일 목록</h3>
            <ul class="list"></ul>
            <input class="desc" type="text" />
            <button onClick="onAdd()">추가</button>
            <button onClick="onSaveToServer()">서버에 저장</button>
        </div>
        <script>
        	let currentId = 1;
            const todoList = [];
            function onAdd() {
                const inputEl = document.querySelector('.todo .desc');
                const todo = { id: currentId, desc: inputEl.value };
                todoList.push(todo);
                currentId += 1;
                const elemList = document.querySelector('.todo .list');
                const liEl = makeTodoElement(todo);
                elemList.appendChild(liEl);
            }
            function makeTodoElement(todo) {
                const liEl = document.createElement('li');
                const spanEl = document.createElement('span');
                const buttonEl = document.createElement('button');
                spanEl.innerHTML = todo.desc;
                buttonEl.innerHTML = '삭제';
                buttonEl.dataset.id = todo.id;
                liEl.appendChild(spanEl);
                liEl.appendChild(buttonEl);
                return liEl;
            }
            function onDelete(e) {
                const id = Number(e.target.dataset.id);
                const index = todoList.findIndex(item => item.id === id);
                if (index >= 0) {
                    todoList.splice(index, 1);
                    conse elemList = document.querySelector('.todo .list');
                    const liEl = e.target.parentNode;
                    elem.removeChild(liEl);
                }
            }
            function onSaveToServer() {
                // todoList 전송
            }
        </script>
    </body>
</html>
```

`<div class="todo">`로 초기화면을 정의한다. const todoList = []로 배열에 할일 목록을 저장한다. onAdd()로 할 일을 추가하는 함수를 정으히ㅏㄴ다. 로직과 UI 코드가 복잡하게 얽혀 있다. onDelete로 할 일을 삭제하는 코드도 가독성이 낮다. 

다음은 같은 기능을 리액트로 작성한 코드다.

```jsx
function MyComponent() {
    const [desc, setDesc] = useState("");
    const [currentId, setCurrentId] = useState(1);
    const [todoList, setTodoList] = useState([]);
    function onAdd() {
        const todo = { id: currentId, desc };
        setCurrentId(currentId + 1);
        setTodoList([...todoList, todo]);
    }
    function onDelete(e) {
        const id = Number(e.target.dataset.id);
        const newTodoList = todoList.filter(todo => todo.id !== id);
        setTodoList(newTodoList);
    }
    function onSaveToServer() {
        // todoList 전송
    }
    return (
    	<div>
        	<h3>할 일 목록</h3>
            <ul>
            	{todoList.map(todo => {
                    <li key={todo.id}>
                    	<span>{todo.desc}</span>
                        <button data-id={todo.id} onClick={onDelete}>삭제</button>
                    </li>
                })}
            </ul>
            <input type="text" value={desc} onChange={e => setDesc(e.target.value)} />
            <button onClick={onAdd}>추가</button>
            <button onClick={onSaveToServer}>서버에 저장</button>
        </div>
    );
}
```

컴포넌트가 반환하는 값은 화면에 무엇을 그려야 하는지 설명하는 UI 코드로 이루어져 있다. UI 코드는 할 일을 추가하고 삭제하는 코드와 분리되어 있다. MyComponent 컴포넌트는 상탯값 todoList, desc를 기반으로 UI를 정의한다. 리액트는 상탯값이 수정되면 컴포넌트 함수를 실행해서 화면을 갱신할 수 있다. 

리액트를 사용하지 않은 코드는 화면을 어떻게 그리는지 나타낸다. 이와 대조적으로 리액트를 사용한 코드는 화면에 무엇을 그리는지 나타낸다. 전자를 명령형(imperative) 프로그래밍이라 부르고, 후자를 선언형(declarative) 프로그래밍이라 부른다. 

리액트를 사용하지 않은 코드는 돔을 직접 수정하면서 화면을 어떻게 그리는지 구체적으로 나타낸다. 상당히 구체적이기 때문에 돔 환경이 아닌 곳에서는 사용하기 힘들다. 반면에 리액트를 사용한 코드는 무엇을 그리는지만 나타내기 때문에 다양한 방식으로 그릴 수 있다. 컴포넌트 함수가 반환하는 코드는 선언형으로 작성되기 때문에 리액트는 돔 환경 뿐만 아니라 모바일 네이티브의 UI도 표현할 수 있다. 따라서 선언형 프로그래밍은 명령형 프로그래밍보다 추상화 단계가 높다고 할 수 있다. 추상화 단계가 높을수록 비즈니스 로직에 좀 더 집중할 수 있다는 장점이 있다. 

#### 컴포넌트의 속성값과 상탯값

##### 속성값과 상탯값으로 관리하는 UI 데이터

컴포넌트의 상탯값은 해당 컴포넌트가 관리하는 데이터이고, 컴포넌트의 속성값은 부모 컴포넌트로부터 전달받는 데이터다. 리액트에서 UI 데이터는 반드시 상탯값과 속성값으로 관리해야 한다. UI 데이터를 상탯값과 속성값으로 관리하지 않으면 UI 데이터가 변경돼도 화면이 갱신되지 않을 수 있다. 

다음 코드는 화면에서 버튼 하나를 보여 주고, 버튼을 누르면 color 변수의 값을 수정한다. 속성값과 상탯값을 사용하지 않았기 때문에 화면이 제대로 갱신되지 않는다. 

```jsx
let color = "red";
function MyComponent() {
    function onClick() {
        color = "blue";
    }
    return (
    	<button style={{ backgroundColor: color}}>좋아요</button>
    );
}
```

1행의 color 데이터는 버튼의 배경색을 나타낸다. 초기 화면은 의도한 대로 빨간색으로 잘 나온다. 버튼을 클릭하면 color 데이터는 파란색으로 변경되지만, 화면에 보이는 버튼의 배경색은 여전히 빨간색이다. 이는 리액트가 UI 데이터가 변경됐다는 사실을 모르기 때문이다. 

컴포넌트의 상탯값을 이용하면 리액트가 UI 데이터의 변경을 알 수 있다. 다음은 컴포넌트의 상탯값을 사용하도록 수정한 코드다. 

```jsx
import React, { useState } from "react";

function MyComponent() {
    const [color, setColor] = useState("red");
    function onClick() {
        setColor("blue");
    }
    return (
    	<button style={{ backgroundColor: color }} onClick={onClick}>좋아요</button>
    )
}
```

컴포넌트에 상탯값을 추가할 때는 useState 훅을 사용한다. useState 훅의 인자는 초깃값을 의미한다. useState가 반환하는 배열의 첫 번째 원소는 상탯값이고, 두 번째 원소는 상탯값 변경 함수다. 이처럼 훅에서는 배열 비구조화 문법을 자주 사용한다. 리액트는 setColor 함수가 호출되면 상탯값을 변경하고, 해당 컴포넌트를 다시 렌더링한다. 

속성값은 부모 컴포넌트가 전달해 주는 데이터이고, 대부분의 경우 UI 데이터를 포함한다. 다음은 컴포넌트의 속성값을 이용한 코드다. 

```jsx
function Title(props) {
    return <p>{props.title}</p>
}
```

Title 컴포넌트는 부모 컴포넌트로부터 title이라는 속성값을 받는다. Title 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링되므로 title 속성값의 변경 사항이 바로 화면에 반영된다. 

다음은 title 속성값을 내려 주는 부모 컴포넌트의 코드다.

```jsx
function Todo() {
    const [count, setCount] = useState(0);
    function onClick() {
        setCount(count + 1);
    }
    return (
    	<div>
        	<Title title={`현재 카운트: ${count}`} />
            <button onClick={onClick}>증가</button>
        </div>
    );
}
```

버튼을 클릭할 때마다 count 상탯값을 변경하고, Todo 컴포넌트는 다시 렌더링된다. 이때 Title 컴포넌트는 새로운 title 속성값을 내려받는다. 이렇게 상탯값과 속성값으로 UI 데이터를 관리하는 것이 리액트의 핵심이다. 

Title 컴포넌트는 부모 컴포넌트가 렌더링될 때마다 같이 렌더링된다. 만약 title 속성값이 변경될 때만 렌더링되길 원한다면 React.memo를 이용할 수 있다. 

```jsx
function Title(props) {
    return <p>{props.title}</p>;
}
export default React.memo(Title);
```

4행에서 memo 함수의 인수로 컴포넌트를 입력하면, 컴포넌트의 속성값이 변경되는 경우에만 렌더링된다.

같은 컴포넌트를 여러 번 사용할 수도 있다. 사용된 각 컴포넌트는 상탯값을 위한 자신만의 메모리 공간이 있어서 같은 컴포넌트라도 자신만의 상탯값이 존재한다. 다음과 같이 컴포넌트를 두 번 사용하면 두 개의 상탯값이 따로 관리된다. 

```jsx
function App() {
    return (
    	<div>
        	<MyComponent />
            <MyComponent />
        </div>
    );
}
```

##### 불변 객체로 관리하는 속성값과 상탯값

속성값은 불변(immutable) 변수이지만 상탯값은 불변 변수가 아니다. 하지만 상탯값도 불변 변수로 관리하는 게 좋다. 

속성값은 불변 변수이기 때문에 값을 변경하려고 시도하면 에러가 발생한다. 

```jsx
function Title(props) {
    props.title = 'abc';
    // ...
}
```

자식 컴포넌트에 전달되는 속성값은 상위 컴포넌트에서 관리하기 때문에 수정하지 못하도록 막혀 있다. 따라서 title이라는 데이터를 수정하고 싶다면 title 상탯값을 가진 컴포넌트에서 관리하는 상탯값 변경 함수를 이용해야 한다. 

속성값과 달리 상탯값은 직접 수정이 가능하다. 다음은 상탯값을 직접 수정하는 코드다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState({ value: 0 });
    
    function onClick() {
        const.value = 2;
        // ...
        setCount(count);
    }
}
// ...
```

onClick 함수 내에서 `const.value`와 같이 상탯값을 직접 수정할 수는 있지만 화면이 갱신되지 않는다. 리액트는 아직 상탯값이 변경된 사실을 모른다. `setCount(count)`와 같이 상탯값 변경 함수를 호출해도 화면은 갱신되지 않는다. 리액트는 상탯값 변경 유무를 이전 값과 단순 비교로 판단하는데, count 객체의 참조값은 그대로이므로 변경 사항이 없다고 판단하고 해당 요청을 무시한다. 

따라서 상탯값도 속성값과 같이 불변 변수로 관리하는 게 좋다. 불변 변수로 관리하면 코드의 복잡도가 낮아지는 장점도 있다. 

#### 컴포넌트 함수의 반환값

다음은 컴포넌트 함수에서 반환할 수 있는 다양한 값을 보여 주는 예제 코드다.

```jsx
return <MyComponent title="안녕하세요" />;
return <p>안녕하세요</p>;
return '안녕하세요';
return 123;
return [<p key="a">안녕하세요</p>, <p key="b">반갑습니다</p>];
return (
	<React.Fragment>
    	<p>안녕하세요</p>
    	<p>반갑습니다</p>
    </React.Fragment>
);
return (
	<>
    	<p>안녕하세요</p>
    	<p>반갑습니다</p>
    </>
);
return null;
return false;
return ReactDOM.createPortal(<p>안녕하세요</p>, domNode);
```

1-2행을 보면 우리가 작성한 컴포넌트와 HTML에 정의된 거의 모든 태그를 사용할 수 있다. 3-4행처럼 문자열과 숫자를 반환할 수 있다. 5행은 배열을 반환할 수 있다. 6-11행은 프래그먼트(fragment)를 사용하여 배열을 사용하지 않고도 여러 개의 요소를 표현할 수 있다. 그리고 프래그먼트 내부의 리액트 요소에 key 속성값을 부여하지 않아도 되므로 배열보다 편하게 작성할 수 있다. 12-17행은 보통 바벨을 이용해서 이렇게 프래그먼트를 축약해서 작성한다. 18-19행은 null 또는 불(boolean)을 반환하면 아무것도 렌더링하지 않는다. 20행은 리액트 포털(portal)을 사용하면 컴포넌트의 현재 위치와는 상관없이 특정 돔 요소에 렌더링할 수 있다. 

다ㅇ므은 컴포넌트 함수가 불을 반환할 수 있다는 점을 이용한 코드다. 

```jsx
function MyComponent({ title }) {
    return title.length > 0 && <p>{title}</p>;
}
```

title 속성값의 길이가 0이면 거짓(false)를 반환하고, 결과적으로 아무것도 렌더링되지 않는다. 반대로 title 속성값의 길이가 1 이상이면 우측으 p 요소가 반환된다. 

다음은 리액트 포털을 사용하는 코드다.

```jsx
function Modal({ title, desc }) {
    const domNode = document.getElementById('modal');
    return ReactDOM.createPortal(
    	<div>
        	<p>{title}</p>
        	<p>{desc}</p>
        </div>,
        domNode,
    );
}
```

3행은 리액트 포털을 이용해서 특정 돔 요소에 리액트 요소를 랜더링할 수 있다. Modal 컴포넌트가 사용된 위치와 상관없이 렌더링할 위치를 선택할 수 있다. 

### 리액트 요소와 가상 돔

리액트 요소(element)는 리액트가 UI를 표현하는 수단이다. 보통 우리는 JSX 문법을 사용하기 때문에 리액트 요소의 존재를 잘 모른다. 하지만 리액트 요소를 이해한다면 리액트가 내부적으로 어떻게 동작하는지 알 수 있다. 

리액트는 렌더링 성능을 위해 가상 돔을 사용한다. 브라우저에서 돔을 변경하는 것은 비교적 오래 걸리는 작업이다. 따라서 빠른 렌더링을 위해서는 돔 변경을 최소화해야 한다. 그래서 리액트는 메모리에 가상 돔을 올려 놓고 이전과 이후의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영하는 전략을 채택했다.

리액트 요소로부터 가상 돔을 만들고, 실제 돔에 반영할 변경 사항을 찾는 과정을 따라가 보자. 

#### 리액트 요소 이해하기

JSX 문법으로 작성된 코드는 createElement 함수로 변경된다는 사실을 배웠다. 이름에서 알 수 있듯이 createElement 함수는 리액트 요소를 반환한다. 따라서 대부분의 경우 컴포넌트 함수는 리액트 요소를 반환한다. 리액트가 UI를 표현하기 위해 사용하는 리액트 요소의 구조를 살펴보자. 

다음은 JSX 코드가 createElement 함수를 사용하는 코드로 변경된 예다. 

```jsx
const element = <a href="http://google.com">click here</a>;
const element = React.createElement(
	'a',
    { href: 'http://google.com' },
    'click here',
);
```

첫 번째 줄의 코드는 그 다음 줄의 코드로 변경된다.

다음 코드는 createElement 함수가 반환하는 리액트 요소의 구조를 보여 준다.

```jsx
const element = (
	<a key="key1" style={{ width: 100 }} href="http://google.com">click here</a>
);

console.log(element);
const consoleLogResult = {
    type: 'a',
    key: 'key1',
    ref: null,
    props: {
        href: 'http://google.com',
        style: {
            width: 100,
        },
        children: 'click here',
    },
    // ...
};
```

1행부터 3행까지의 element 변수는 createElement 함수가 반환한 리액트 요소다. consoleLogRsult 변수는 리액트 요소를 로그로 출력한 결과를 표현한 것이다. type 속성값이 문자열이면 HTML 태그를 나타낸다. type 속성값이 함수이면 우리가 작성한 컴포넌트를 나타낸다. key: 'key1'은 JSX 코드에서 key 속성값을 입력하면 리액트 요소의 ref 속성값으로 들어간다. key와 ref를 제외한 나머지 속성값은 리액트 요소의 props 속성값으로 들어간다. 그 밖에도 리액트 요소가 가진 속성값이 더 있지만, 이정도만 이해해도 충분하다.

JSX 코드에서 태그 사이에 표현식이 들어가면, 리액트 요소에는 이 표현식이 여러 개로 분할되어 들어간다.

```jsx
const element = <h1>제 나이는 {20 + 5} 세입니다</h1>;
console.log(element);
const consoleLogResult = {
    type: 'h1',
    props: { children: ['제 나이는 ', 25, ' 세입니다'] },
    // ...
}
```

1행의 코드에서 태그 사이의 값은 5행의 코드와 같이 표현식을 기준으로 분할돼서 들어간다.

JSX 코드에서 컴포넌트가 사용되면, 리액트 요소의 type 속성값은 해당 컴포넌트 함수가 된다. 

```jsx
function Title({ title, color }) {
    return <p style={{ color }}>{title}</p>;
}
const element = <Title title="안녕하세요" color="blue" />;
console.log(element);
const consoleLogResult = {
    type: Title,
    props: { title: '안녕하세요', color: 'blue' },
    // ...
}
```

4행에서 JSX에 사용된 Title 컴포넌트는 consoleLogResult에서 리액트 요소의 type 속성값에 입력된다. 리액트는 type 속성값으로 전달된 함수를 호출해서 화면을 그리기 위한 충분한 정보를 얻을 수 있다. 

리액트 요소는 불변 객체이기 때문에 속성값을 변경할 수 없다.

```jsx
const element = <a href="http://google.com">click hire</a>;
elements.type = 'b'; // 에러 발생
```

리액트는 전달된 리액트 요소를 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다. 

```jsx
let seconds = 0;
function update() {
    seconds += 1;
    const element = {
        <div>
        	<h1>안녕하세요</h1>
            <h2>지금까지 {seconds}초가 지났습니다.</h2>
        </div>
    };
    ReactDOM.render(element, document.getElementByID('root'));
}

setInterval(update, 1000);
```

setInterval로 1초마다 update 함수를 호출해서 화면을 갱신한다. 리액트 요소에서 변경되는 부분은 seconds 변수로 표현된 숫자가 유일하다. ReactDOM.render로 리액트가 새로운 리액트 요소를 받으면 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영한다. 따라서 앞의 코드에 의해 업데이트되는 과정에서 리액트는 실제 돔의 h1 요소는 건드리지 않는다. 

#### 리액트 요소가 돔 요소로 만들어지는 과정

하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 트리(tree) 구조로 구성된다. 프로그램 화면은 여러 가지 이벤트를 통해서 다양한 모습으로 변화한다. 하나의 리액트 트리 요소는 시간에 따라 변화하는 화면의 한순간을 나타낸다. 

리액트에서 데이터 변경에 의한 화면 업데이트는 렌더 단계(render phase, reconciliation phase라고도 불린다)와 커밋 단계(commit phase)를 거친다. 렌더는 실제 돔에 반영할 변경 사항을 파악하는 단계이고, 커밋은 파악된 변경 사항을 실제 돔에 반영하는 단계이다. 렌더 단계에서는 변경 사항을 파악하기 위해 가상 돔을 이용한다. 

가상 돔은 리액트 요소로부터 만들어진다. 리액트는 렌더링을 할 때마다 가상돔을 만들고 이전의 가상 돔과 비교한다. 이는 실제 돔의 변경 사항을 최소화하기 위한 과정이다. 

다음 코드는 할 일의 우선순위를 상탯값으로 관리하는 코드다. 할 일의 제목과 내용은 부모 컴포넌트가 속성값으로 내려준다. 이 코드를 기반으로 리액트 요소가 실제 돔으로 만들어지는 괒어을 이해해 보자. 

```jsx
function Todo({ title, desc }) {
    const [priority, setPriority] = useState("high");
    function onClick() {
        setPriority(priority === "high" ? "low" : "high");
    }
    return (
    	<Title title={title} />
        <p>{desc}</p>
        <p>{priority === "high" ? "우선순위 높음" : "우선순위 낮음"}</p>
        <button onClick={onClick}>우선순위 변경</button>
    );
}

const Title = React.memo(({ title }) => {
    return <p style={{ color: "blue" }}>{title}</p>;
});

ReactDOM.render(
	<Todo title="리액트 공부하기" desc="실전 리액트 프로그래밍을 열심히 읽는다" />,
    document.getElementById('root');
);
```

Todo 컴포넌트는 Title 컴포넌트를 자식으로 사용한다. 버튼을 클릭하면 priority 상탯값이 변경되고 화면을 다시 그린다. React.memo로 만들어진 Title 컴포넌트는 속성값이 변경될 때만 호출된다.

ReactDOM.render 함수로 전달된 리액트 요소 트리의 구조는 다음과 같다.

```jsx
const initialElementTree = {
    type: Todo,
    props: {
        title: '리액트 공부하기',
        desc: '실전 리액트 프로그래밍을 열심히 읽는다',
    },
    // ...
};
```

리액트가 initialElementTree를 이용해서 실제 돔을 만드는 과정을 따라가 보자. 먼저 Todo 컴포넌트의 렌더링 결과를 얻기 위해 Todo 컴포넌트 함수를 호출한다. 그 결과는 다음과 같다.

```jsx
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: Title,
                props: { title: '리액트 공부하기' },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 높음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: funcion() {
                    	/* Todo 컴포넌트의 onClick 함수 */
                	},
                	children: '우선순위 변경',
                },
            	// ...
            },
        ],
    },
    // ...
}
```

2행에서 트리의 루트는 div 태그로 변경된다. 6행에서는 아직 Title 컴포넌트가 존재하기 때문에 이 트리를 실제 돔으로 만들 수는 없다. 리액트 요소 트리가 실제 돔으로 만들어지기 위해서는 모든 리액트 요소의 type 속성값이 문자열이어야 한다. 이는 type 속성값이 문자열이어야 HTML 태그로 변환할 수 있기 때문이다. 그러기 위해서는 모든 컴포넌트 함수가 호출되어야 한다. 

Title 컴포넌트를 렌더링한 결과는 다음과 같다.

```jsx
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: 'p',
                props: { 
                    style: { color: 'blue' },
                    children: '리액트 공부하기', 
                },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 높음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: funcion() {
                    	/* Todo 컴포넌트의 onClick 함수 */
                	},
                	children: '우선순위 변경',
                },
            	// ...
            },
        ],
    },
    // ...
}
```

6행부터 Title 컴포넌트로 표현됐던 리액트 요소가 p 태그로 변경됐다. 이제 모든 리액트 요소의 type 속성값이 문자열이므로 실제 돔을 만들 수 있다. 이와 같이 실제 돔을 만들 수 있는 리액트 요소 트리를 가상 돔이라고 한다. 최초의 리액트 요소 트리로부터 가상 돔을 만들고 이전 가상 돔과 비교해서 실제 돔에 반영할 내용을 결정하는 단계를 렌더라고 한다. 

리액트는 화면을 업데이트할 때 이전의 가상 돔과 현재의 가상 돔을 비교해서 변경된 부분만 실제 돔에 반영한다. 브라우저에서 실제 돔을 변경하는 작업은 다른 작업에 비해 시간이 오래 걸리기 때문에 꼭 필요한 부분만 변경하는 것이 중요하다. 이렇듯 중요하지만 직접 하기는 귀찮은 작업을 리액트가 알아서 해준다. 

렌더 단계는 ReactDOM.render 함수와 상탯값 변경 함수에 의해 시작된다. 위에서 ReactDOM.render 함수에 의해 시작된 렌더 단계를 살펴봤다. 이제 상탯값 변경 함수에 의해 수행되는 렌더 단계를 따라가 보자.

Todo 컴포넌트는 상탯값을 갖고 있다. 버튼을 클릭하면 setPriority 함수가 호출되고 또다시 렌더 단계가 시작된다. Todo 컴포넌트의 priority 상탯값이 변경되면 Todo 컴포넌트 함수가 호출된다. 그 결과로 만들어지는 리액트 요소 트리는 다음과 같다.

```jsx
const elementTree = {
    type: 'div',
    props: {
        children: [
            {
                type: title,
                props: { title: '리액트 공부하기' },
                // ...
            },
            {
                type: 'p',
                props: { children: '실전 리액트 프로그래밍을 열심히 읽는다' },
                // ...
            },
            {
                type: 'p',
                props: { children: '우선순위 낮음' },
                // ...
            },
            {
                type: 'button',
                props: {
                    onClick: funcion() {
                    	/* Todo 컴포넌트의 onClick 함수 */
                	},
                	children: '우선순위 변경',
                },
            	// ...
            },
        ],
    },
    // ...
}
```

Title 컴포넌트는 React.memo로 만들어졌고, 속성값이 변하지 않았기 때문에 이전 결과가 재사용된다. 이렇게 두 번째 가상 돔이 만들어졌다. 이전의 가상 돔과 비교해 보면 '우선순위 낮음' 문자열만 변경됐다는 사실을 알 수 있다. 따라서 실제 돔에서도 해당 p 태그의 문자열만 수정된다. 

지금까지의 과정을 정리해 보자. ReactDOM.render 함수가 호출되고 최초의 렌더 단계가 실행됐다. 그리고 이렇게 만들어진 가상 돔이 실제 돔으로 만들어졌다. 사용자의 버튼 클릭으로 Todo 컴포넌트의 상탯값이 변경된다. 곧 두 번째 렌더 단계가 실행되고 새로운 가상 돔이 만들어진다. 이때 이전의 가상 돔과 비교해서 변경된 부분만 실제 돔에 반영된다. 

지금까지 리액트 요소를 이용해서 렌더 단계를 설명했지만, 엄밀히 말하면 리액트 요소는 파이버(fiber)라는 구조체로 변환된다. 파이버는 리액트 버전 16부터 도입된 구조체 이름이다. 파이버도 리액트 요소와 같이 type, props 속성값을 가진다. 파이버로 동작할 때도 모든 type 속성값이 문자열이 될 때까지 연산한다는 사실에는 변함이 없다. 

### 리액트 훅 기초 익히기

훅은 함수형 컴포넌트에 기능을 추가할 때 사용하는 함수다. 훅을 이용하면 함수형 컴포넌트에서 상탯값을 사용할 수 있고, 자식 요소에 접근할 수 있다. 

훅은 비교적 최근(리액트 16.8)에 추가된 기능이며 기존에 리액트가 가지고 있던 여러 가지 문제를 해결해 준다. 새로 작성하는 컴포넌트는 되도록 클래스형 컴포넌트보다 훅을 사용해서 함수형 컴포넌트로 작성하는 게 좋다. 훅이 주는 장점이 매우 크고, 리액트 팀에서도 적극적으로 훅과 관련된 기능 개발에 많은 시간을 투자하고 있다. 

#### 상탯값 추가하기: useState

useState 훅을 이용하면 컴포넌트에 상탯값을 추가할 수 있다. useState 훅의 사용법은 앞서 간단하게 살펴봤다. 이제 useState 훅을 좀 더 깊이 이해해 보자. 

##### 배치로 처리되는 상탯값 변경 함수

useState 훅이 반환하는 배열의 두 번째 원소는 상탯값 변경 함수다. 리액트는 상탯값 변경 함수가 호출되면 해당 컴포넌트를 다시 그린다. 그 과정에서 자식 컴포넌트도 같이 렌더링된다. 

리액트는 가능하다면 상탯값 변경을 배치(batch)로 처리한다. 다음은 상탯값 변경 함수를 연속해서 호출하는 코드다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState({ value: 0 });
    function onClick() {
        setCount({value: count.value + 1});
        setCount({value: count.value + 1});
    }
    console.log('render called');
    return (
    	<div>
        	<h2>{count.value}</h2>
            <button onClick={onClick}>증가</button>
        </div>
    );
}
```

count.value 상탯값을 두 번 증가시키려고 했다. 하지만 의도와 달리 1만큼만 증가한다. 이는 상탯값 변경 함수가 비동기로 동작하기 때문이다. 리액트는 효율적으로 렌더링하기 위해 여러 개의 상탯값 변경 요청을 배치로 처리한다. 따라서 onClick 함수가 호출되어도 7행의 로그는 한 번만 출력된다. 

리액트가 상탯값 변경 함수를 동기로 처리하면 하나의 상탯값 변경 함수가 호출될 때마다 화면을 다시 그리기 때문에 성능 이슈가 생길 수 있다. 만약 동기로 처리하지만 매번 화면을 다시 그리지 않는다면 UI 데이터와 화면 간의 불일치가 발생해서 혼란스러울 수 있다. 

##### 상탯값 변경 함수에 함수 입력하기

위의 코드에서 생긴 문제를 해결하기 위해 다음과 같이 상탯값 변경 함수의 인수로 함수를 입력할 수 있다. 이전 코드에서는 상탯값이 객체였지만 여기서는 가독성을 위해 숫자로 변경했다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState(0);
    function onClick() {
        setCount(prev => prev + 1);
        setCount(prev => prev + 1);
    }
    // ...
}
```

상탯값 변경 함수로 입력된 함수는 자신이 호출되기 직전의 상탯값을 매개변수로 받는다. 이 코드에서는 첫 번째 호출에서 변경된 상탯값이 두 번째 호출의 인수로 사용된다. 따라서 onClick 함수를 호출하면 count 상탯값은 2만큼 증가한다. 

##### 호출 순서가 보장되는 상탯값 변경 함수

상탯값 변경 함수는 비동기로 처리되지만 그 순서가 보장된다. 

```jsx
function MyComponent() {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);
    function onClick() {
        setCount1(count1 + 1);
        setCount2(count2 + 1);
    }
    const result = count1 >= count2;
    // ...
}
```

count1 상탯값이 먼저 증가하고 count2 상탯값은 나중에 증가한다. 상탯값 변경 함수의 호출 순서대로 상탯값이 변경되기 때문에 result 변수는 항상 참이다. 

##### useState 훅 하나로 여러 상탯값 관리하기

상탯값 변경 함수는 클래스형 컴포넌트의 setState 메서드와 조금 다르게 동작한다. setState 메서드는 기존 상탯값과 새로 입력된 값을 병합하지만 useState 훅의 상탯값 변경 함수는 이전 상탯값을 덮어쓴다. 

다음은 여러 상탯값을 객체에 담아서 관리하는 코드다.

```jsx
import React, { useState } from 'react';

function Profile() {
    const [state, setState] = useState({ name: '', age: 0 });
    return (
    	<div>
        	<p>{`name is ${state.name}`}</p>
        	<p>{`age is ${state.age}`}</p>
            <input type="text" value={state.name} onChange={e => setState({ ...state, name: e.target.value })} />
            <input type="number" value={state.age} onChange={e => setState({ ...state, age: e.target.value })} />
        </div>
    );
}
```

4행과 같이 두 상탯값을 하나의 객체로 관리한다. onChange를 보면 useState 훅은 이전 상탯값을 덮어쓰기 때문에 ...state와 같은 코드가 필요하다. 이렇게 상탯값을 하나의 객체로 관리할 때는 useReducer 훅을 사용하는 게 좋다.

> **상탯값 변경이 배치로 처리되지 않는 경우**
>
> 리액트는 내부에서 관리하는 이벤트 처리 함수에 대해서만 상탯값 변경을 배치로 처리한다. 다음과 같이 리액트 외부에서 관리되는 이벤트 처리 함수의 경우에는 상탯값 변경이 배치로 처리되지 않는다. 
>
> ```jsx
> function MyComponent() {
>     const [count, setCount] = useState(0);
>     useEffect(() => {
>         function onClick() {
>             setCount(prev => prev + 1);
>             setCount(prev => prev + 1);
>         }
>         window.addEventListner("click", onClick);
>         return () => window.removeEventListner("click", onClick);
>     }, []);
>     console.log("render called");
>     // ...
> }
> ```
>
> useEffect 훅은 부수 효과를 처리하는 용도로 사용된다. 컴포넌트 최초 렌더링 후, useEffect에 입력된 함수가 한 번만 호출되도록 작성한 코드다. useEffect 훅에 대한 내용은 우선 이 정도만 이해하자. 자세한 내용은 바로 뒤에서 설명한다. window 객체에 이벤트 처리 함수를 등록한다. 리액트 요소에 등록되지 않은 이벤트 처리 함수는 리액트 내부에서 관리되지 않는다. 이처럼 리액트 외부에 등록된 이벤트 처리 함수에서 상탯값 변경 함수를 호출하면 배치로 처리되지 않는다. 따라서 화면을 한 번 클릭하면 로그가 두 번 출력된다. 
>
> 리액트 외부에서 관리되는 이벤트 처리 함수에서도 원한다면 상탯값 변경을 배치로 처리할 수 있다. 다음과 같이 unstable_batchedUpdates 함수를 이용하면 상탯값 변경 함수는 모두 배치로 처리된다. 
>
> ```jsx
> function onClick() {
>     ReactDOM.unstable_batchedUpdates(() => {
>         setCount(prev => preev + 1);
>         setCount(prev => preev + 1);
>     });
> }
> ```
>
> 이름에서 알 수 있듯이 안정화된 API가 아니므로 꼭 필요한 경우가 아니라면 사용하지 않는 게 좋다. 
>
> 참고로 concurrent 모드로 동작할 미래의 리액트는 외부에서 관리되는 이벤트 처리 함수도 배치로 처리할 것으로 예상된다. 

#### 컴포넌트에서 부수 효과 처리하기: useEffect

함수 실행 시 함수 외부의 상태를 변경하는 연산을 부수 효과라고 한다. 특별한 이유가 없다면 모든 부수 효과는 useEffect 훅에서 처리하는 게 좋다.

API를 호출하는 것과 이벤트 처리 함수를 등록하고 해제는 것 등이 부수 효과의 구체적인 예다. 이 두 가지 기능을 각각 useEffect 훅으로 구현해 볼 텐데, 그 전에 우선 useEffect 훅의 사용법을 알아보자. 다음은 useEffect 훅의 사용 예다.

```jsx
import React, { useState, useEffect } from 'react';

function MyComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
        document.title = `업데이트 횟수: ${count}`;
    });
    return <button onClick={() => setCount(count + 1)}>increase</button>;
}
```

useEffect 훅에 입력하는 함수를 부수 효과 함수라고 한다. 부수 효과 함수는 렌더링 결과가 실제 돔에 반영된 후 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 호출된다. 버튼을 클릭할 때마다 다시 렌더링되고, 렌더링이 끝나면 부수 효과 함수가 호출된다. 

##### 컴포넌트 API 호출하기

useEffect 훅을 이용해서 다음과 같이 API를 호출할 수 있다.

```jsx
import React, { useEffect, useState } from 'react';

function Profile({ userId }) {
    const [user, setUser] = useState(null);
    useEffect(() => {
       getUserApi(userId).then(data => setUser(data)); 
    }, [userId]);
    
    return (
    	<div>
        	{!user && <p>사용자 정보 가져오는 중...</p>}
            {user && (
            	<>
                	<p>{`name is ${user.name}`}</p>
                	<p>{`age is ${user.age}`}</p>
                </>
            )}
        </div>
    );
};
```

4행은 API 결괏값을 저장할 상탯값이다. useEffect의 부수 효과 함수에서 API 통신을 하며, 받아온 데이터는 user 상탯값에 저장한다. 부수 효과 함수는 렌더링할 때마다 호출되기 때문에 API 통신을 불필요하게 많이 하게 된다. 이를 방지하기 위해 useEffect 훅의 두 번째 매개변수로 배열을 입력하면, 배열의 값이 변경되는 경우에만 함수가 호출된다. 이 배열을 의존성 배열이라고 한다. 여기서는 userId 값이 변경되는 경우에만 API 통신을 하도록 설정한다.

대개의 경우 의존성 배열을 입력할 필요가 없다. useEffect 훅을 사용할 때 많은 버그가 의존성 배열을 잘못 입력하면서 발생한다. 

##### 이벤트 처리 함수를 등록하고 해제하기

다음은 useEffect 훅을 이용해서 이벤트 처리 함수를 등록하고 해제하는 코드다. 

```jsx
import React, { useEffect, useState } from 'react';

function WidthPrinter() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner('resize', onResize);
        return () => {
            window.removeEventListner('resize', onResize);
        };
    }, []);
    return <div>{`width is ${width}`}</div>;
}
```

window.addEventListner를 통해 창 크기가 변경될 때마다 onResize 이벤트 처리 함수가 호출되도록 등록한다. return에서 부수 효과 함수는 함수를 반환할 수 있다. 반환된 함수는 부수 효과 함수가 호출되기 직전에 호출되고, 컴포넌트가 사라지기 직전에 마지막으로 호출된다. 따라서 부수 효과 함수가 반환한 함수는 프로그램이 비정상적으로 종료되지 않는다면 반드시 호출될 것이 보장된다. 의존성 배열로 빈 배열을 입력하면 컴포넌트가 생성될 때만 부수 효과 함수가 호출되고, 컴포넌트가 사라질 때만 반환된 함수가 호출된다. 

#### 훅 직접 만들기

리액트가 제공하는 훅을 이용해서 커스텀(custom) 훅을 만들 수 있다. 그리고 커스텀 훅을 이용해서 또 다른 커스텀 훅을 만들 수도 있다. 훅을 직접 만들어서 사용하면 쉽게 로직을 재사용할 수 있다. 

리액트의 내장 훅처럼 커스텀 훅의 이름은 use로 시작하는 게 좋다. 그러면 코드 가독성이 좋아지고, 여러 리액트 개발 도구의 도움도 쉽게 받을 수 있다.

##### useUser 커스텀 훅

위의 코드에서 작성했던 사용자 데이터를 관리하는 로직을 다음과 같이 커스텀 훅으로 분리할 수 있다.

```jsx
function useUser(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    return user;
}

function Profile({ userId }) {
    const user = useUser(userId);
    // ...
}
```

useState 훅과 useEffect 훅을 이용해서 커스텀 훅을 만들었다. 이렇게 레고 블록처럼 기존 훅을 이용해서 새로운 훅을 만들 수도 있다는 점은 매력적이다. useUser 훅은 userId를 입력으로 받아서 user 객체를 출력해준다. 커스텀 훅도 리액트에서 제공하는 내장 훅과 마찬가지로 단순히 함수를 호출하는 방식으로 간단하게 사용할 수 있다. 

userId가 변경되면 자동으로 사용자 데이터를 받아온다. useUser 훅을 사용하는 코드를 보면 동기 방식으로 사용자 데이터를 가져오는 것처럼 보인다. 물론 사용자 데이터는 비동기로 받아온다. 커스텀 훅은 이렇게 내부 구현을 숨기면서 사용 편의성을 높였다. 

##### useWindowWidth 커스텀 훅

이전에 작성했던 창의 너비를 관리하는 로직을 useWindowWidth 커스텀 훅으로 만들어 보자. 

```jsx
import { useEffect, useState } from 'react';

function useWindowWidth() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner('resize', onResize);
        return () => {
            window.removeEventListner('resize', onResize);
        };
    }, []);
    return width;
}

function WidthPrinter() {
    const width = useWindowWidth();
    return <div>{`width is ${width}`}</div>;
}
```

useWindowWidth 훅은 창의 너비를 저장해 두고 필요할 때마다 값을 제공한다. 창의 너비가 변경되면 새로운 창의 너비로 다시 렌더링된다. 

##### useMounted 커스텀 훅

리액트에서 마운트란 컴포넌트의 첫 번째 렌더링 결과가 실제 돔에 반영된 상태를 말한다. 컴포넌트 마운트 여부를 알려 주는 useMounted 훅은 다음과 같이 작성할 수 있다. 

```jsx
function useMounted() {
    const [mounted, setMounted] = useState(false);
    useEffect(() => setMounter(true), []);
    return mounted;
}
```

mounted 상탯값은 첫 번째 렌더링 결과가 실제 돔에 반영된 후에 항상 참을 반환한다. setMounted 함수는 한 번만 호출해도 충분하므로 의존성 배열에 빈 배열을 입력한다. 

