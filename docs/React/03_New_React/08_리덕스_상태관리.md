## 리덕스로 상태 관리하기

리덕스(redux)는 자바스크립트를 위한 사애 관리 프레임워크다. 리액트를 사용하는 많은 프로젝트에서 리덕스도 같이 사용하는데, 그 이유는 다음과 같다.

+ 컴포넌트 코드로부터 상태 관리 코드를 분리할 수 있다.
+ 서버 렌더링 시 데이터 전달이 간편하다.
+ 로컬 스토리지에 데이터를 저장하고 불러오는 코드를 쉽게 작성할 수 있다.
+ 같은 상탯값을 다수의 컴포넌트에서 필요로 할 때 좋다.
+ 부모 컴포넌트에서 깊은 곳에 있는 자식 컴포넌트에 상탯값을 전달할 때 좋다.
+ 알림창과 같은 전역 컴포넌트의 상탯값을 관리할 때 좋다.
+ 페이지가 전환되어도 데이터는 살아 있어야 할 때 좋다.

이러한 리덕스의 장점을 잘 활용할 수 있는 사용법을 리덕스의 기본 개념과 함께 살펴보자. 또한 같이 사용하면 좋을 몇 가지 라이브러리도 알아 보자.

### 리덕스 사용 시 따라야 할 세 가지 원칙

리덕스 공식 문서에서는 리덕스 사용 시 따라야 할 세 가지 원칙을 설명한다.

+ 전체 상탯값을 하나의 객체에 저장한다.
+ 상탯값은 불변 객체다.
+ 상탯값은 순수 함수에 의해서만 변경되어야 한다.

##### 하나의 객체에 프로그램의 전체 상탯값을 저장한다.

전체 상탯값이 하나의 자바스크립트 객체로 표현되기 때문에 활용도가 높아진다. 리덕스를 사용하면 하나의 객체를 직렬화(serialize)해서  서버와 클라이언트가 프로그램의 전체 상탯값을 서로 주고받을 수 있다. 프로그램이 특정한 상태에 있을 때 발생하는 버그를 확인하기 위해 그 상탯값을 저장한 후 반복해서 재현할 수 있다. 최근의 상탯값을 버리지 않고 저장해 놓으면 실행 취소(undo)와 다시 실행(redo) 기능을 쉽게 구현할 수 있다.

하지만 프로그램의 전체 상탯값을 리덕스로 관리하는 것은 쉬운 일이 아니다. 애니메이션을 위한 데이터나 문자열 입력창의 상탯값은 컴포넌트에서 관리하는 게 더 나을 수도 있다. 프로그램의 일부 상태만 리덕스를 활용해도 된다. 특별히 로직이 복잡하지 않은 페이지에서는 컴포넌트의 상탯값을 활용하는 게 생산성을 더 높일 수도 있다. 전체 상탯값을 리덕스로 관리하면 시간 여행(time travel)과 같은 기능을 쉽게 구현할 수 있지만, 그런 기능을 사용하지 않는다면 필요한 곳에서만 리덕스를 사용해도 된다. 

##### 상탯값을 불변 객체로 관리한다

다음과 같이 상탯값은 오직 액션 객체에 의해서만 변경되어야 한다.

```jsx
const incrementAction = {
    type: 'INCREMENT',
    amount: 123,
};
const conditionalIncrementAction = {
    type: 'CONDITIONAL_INCREMENT',
    amount: 2,
    gt: 10,
    lt: 100,
};
store.dispatch(incrementAction);
store.dispatch(conditionalIncrementAction);
```

액션 객체는 type 속성값이 존재해야 한다. type 속성값으로 액션 객체를 구분한다. type 속성값을 제외한 나머지는 상탯값을 수정하기 위해 사용되는 정보다. 액션 객체와 함께 dispatch 메서드를 호출하면 상탯값이 변경된다. 

리덕스의 상탯값을 수정하는 유일한 방법은 액션 객체와 함께 dispatch에서 메서드를 호출하는 것이다. 다른 어떤 방법으로도 상탯값을 수정하면 안된다. 상탯값은 dispatch 메서드가 호출된 순서대로 리덕스 내부에서 변경되기 때문에 상탯값이 변화되는 과정을 쉽게 이해할 수 있다. 게다가 액션 객체는 평범한 자바스크립트 객체이기 때문에 입력된 순서를 저장해 놓고 나중에 그 과정을 쉽게 재현할 수 있다. 

상탯값 수정이라는 하나의 목적만 놓고 보면 불변 객체를 사용하는 것보다는 상탯값을 직접 수정하는 게 더 빠르다. 하지만 이전 상탯값과 이후 상탯값을 비교해서 변경 여부를 파악할 때는 불변 객체가 훨씬 유리하다. 상탯값 변경을 빠르게 확인할 수 있으면 메모이제이션과 같은 기능을 활용하기 좋고, 리액트의 렌더링 성능을 올리는 데도 유리하다. 

##### 오직 순수 함수에 의해서만 상탯값을 변경해야 한다

리덕스에서 상탯값을 변경하는 함수를 리듀서(reducer)라고 부른다. 리듀서의 구조는 다음과 같다.

```jsx
(state, action) => nextState
```

리듀서는 이전 상탯값과 액션 객체를 입력으로 받아서 새로운 상탯값을 만드는 순수 함수다. 순수 함수는 부수 효과(side effect)를 발생시키지 않아야 한다. 또한 순수 함수는 같은 인수에 대해 항상 같은 값을 반환해야 한다. 다음과 같이 반환값을 계산할 때 랜덤 함수나 시간 함수를 이용하면 순수 함수가 아니다.ㅗ

```jsx
// 홍길동님 안녕하세요. 지금은 11시 30분입니다.
sayHello1('홍길동');
sayHello2('홍길동', '11: 30');
```

두 함수는 주석의 내용과 같은 문자열을 반환한다. sayHello1 함수는 내부적으로 시간 함수를 호출하기 때문에 순수 함수가 아니다. 같은 인수를 입력해도 호출하는 시점에 따라 다른 값을 반환하기 때문이다. 반대로 sayHello2 함수는 순수 함수다. 같은 인수를 입력하면 항상 같은 값을 반환한다. 이러한 특성 덕분에 순수 함수는 테스트 코드를 작성하기 쉽다. 

```jsx
const now = new Date();
const hour = now.getHours();
const minute = now.getMinutes();
expect(sayHello1('홍길동')).toBe(
	'홍길동님 안녕하세요. 지금은 ${hour}시 ${minute}분입니다.',
);

expect(sayHello2('홍길동', '11:30')).toBe(
	'홍길동님 안녕하세요. 지금은 11시 30분입니다.',
);
```

sayHello1 함수는 내부적으로 현재 시각을 사용하기 때문에 테스트 코드에서도 현재 시각을 가져와야 한다. 하지만 현재 시각을 가져오는 시점이 서로 다르기 때문에 간헐적으로 테스트가 실패할 수 있다. 일정 수준의 오차는 허용하도록 테스트 코드를 작성할 수도 있지만 번거롭다. 순수 함수로 작성한 코드는 별다른 고민 없이 쉽게 테스트 코드를 작성할 수 있다. 

리듀서는 순수 함수이기 때문에 같은 상탯값과 액션 객체를 입력하면 항상 똑같은 다음 상탯값을 반환한다. 따라서 실행된 액션 객체를 순서대로 저장했다가 나중에 똑같은 순서대로 dispatch 메서드를 호출하면 쉽게 리플레이(replay) 기능을 구현할 수 있다. 

### 리덕스의 주요 개념 이해하기

리덕스에서 상탯값이 변경되는 과정은 다음과 같다.

> 액션 -> 미들웨어 -> 리듀서 -> 스토어 -> 뷰 -> 액션

뷰는 리액트의 컴포넌트라고 생각할 수 있다. 지금부터 상탯값을 변경하는 과정에서 거치게 되는 리덕스의 네 가지 요소인(액션, 미들웨어, 리듀서, 스토어)를 순서대로 살펴보자.

#### 액션

액션(action)은 type 속성값을 가진 자바스크립트 객체다. 액션 객체를 dispatch 메서드에 넣어서 호출하면 리덕스는 상탯값을 변경하기 위해 위의 과정을 수행한다. 액션 객체에는 type 속성값 외에도 원하는 속성값을 얼마든지 넣을 수 있다.

다음 코드는 할 일 목록을 관리하기 위해 세 가지 액션을 사용하고 있다.

```jsx
store.dispatch({ type: 'ADD', title: '영화 보기', priority: 'high' });
store.dispatch({ type: 'REMOVE', id: 123 });
store.dispatch({ type: 'REMOVE_ALL' });
```

각 액션은 고유한 type 속성값을 사용해야 하는데 ADD라는 단어 하나만으로는 중복 가능성이 높다. type 이름의 충돌을 피하기 위해서는 다음과 같이 접두사를 붙이는 방법이 많이 사용된다.

```jsx
store.dispatch({ type: 'todo/ADD', title: '영화 보기', priority: 'high' });
store.dispatch({ type: 'todo/REMOVE', id: 123 });
store.dispatch({ type: 'todo/REMOVE_ALL' });
```

dispatch 메서드를 호출할 때 직접 액션 객체를 입력하는 방법은 사용하지 않는 게 좋다. 'todo/ADD' 액션의 경우 title, priority라는 두 속성값이 항상 존재하도록 강제할 필요가 있다. 이는 다음과 같이 액션 생성자 함수를 이용해서 해결할 수 있다.

```jsx
function addTodo({ title, priority }) {
    return { type: 'todo/ADD', title, prioirty };
}
function removeTodo({ id }) {
    return { type: 'todo/REMOVE', id };
}
function removeAllTodo() {
    return { type: 'todo/REMOVE_ALL' };
}

store.dispatch(addTodo({ title: '영화 보기', priority: 'high' }));
store.dispatch(removeTodo({ id: 123 }));
store.dispatch(removeAllTodo());
```

세 개의 액션 생성자 함수를 정의했다. 액션 생성자 함수를 필요한 인수와 함께 호출하면 항상 같은 구조의 액션 객체가 만들어진다. 나중에 액션 객체의 구조를 변경할 때는 액션 생성자 함수만 수정하면 된다. dispatch 메서드를 호출할 때는 액션 생성자 함수를 이용한다. 

type 속성값은 리듀서에서 액션 객체를 구분할 때도 사용되기 때문에 상수 변수로 만드는 게 좋다.

```jsx
export const ADD = 'todo/ADD';
export const REMOVE = 'todo/REMOVE';
export const REMOVE_ALL = 'todo/REMOVE_ALL';

export function addTodo({ title, prioirty }) {
    return { type: ADD, title, priority };
}
export function removeTodo({ id }) {
    return { type: REMOVE, id };
}
export function removeAllTodo() {
    return { type: REMOVE_ALL };
}
```

tpe 이름을 상수 변수로 만들었다. 이 변수는 리듀서에서도 필요하기 때문에 export 키워드를 이용해서 외부에 노출한다. 액션 생성자 함수도 외부에서 호출해야 하므로 외부로 노출한다.

앞에서 살펴본 리덕스의 세 가지 원칙에 위배되지 않으므로 액션 생성자 함수에서는 부수 효과를 발생시켜도 괜찮다. 예를 들어 addTodo 함수에서 새로운 할 일을 서버에 저장하기 위해 API 호출을 할 수 있다. 

#### 미들웨어

미들웨어(middleware)는 리듀서가 액션을 처리하기 전에 실행되는 함수다. 디버깅 목적으로 상탯값 변경 시 로그를 출력하거나, 리듀서에서 발생한 예외를 서버로 전송하는 등의 목적으로 미들웨어를 활용할 수 있다. 리덕스 사용 시 특별히 미들웨어를 설정하지 않았다면 발생한 액션은 곧바로 리듀서로 보내진다.

미들웨어의 기본 구조는 다음과 같다.

```jsx
const myMiddleware = store => next => action => next(action);
```

미들웨어는 함수 세 개가 중첩된 구조로 되어 있다. 화살표 함수가 연속으로 표현된 코드가 익숙하지 않는다면 헷갈릴 수도 있다. 다음은 위의 코드를 화살표 함수를 사용하지 않고 작성한 코드다.

```jsx
const myMiddleware = function(store) {
    return function(next) {
        return function(action) {
            return next(action);
        };
    };
};
```

코드에서 알 수 있듯이 미들웨어는 스토어와 액션 객체를 기반으로 필요한 작업을 수행할 수 있다. next 함수를 호출하면 다른 미들웨어 함수가 호출되면서 최종적으로 리듀서 함수가 호출된다. 위의 코드는 아무런 작업도 수행하지 않고 next 함수를 호출하기 때문에 무의미한 미들웨어 함수다.

다음은 미들웨어를 사용하기 위해 리덕스를 설정하는 코드다.

```jsx
import { createStore, applyMiddleware } from 'redux';
const middleware1 = store => next => action => {
    console.log('middleware1 start');
    const result = next(action);
    console.log('middleware1 end');
    return result;
}
const middleware2 = store => next => action => {
    console.log('middleware2 start');
    const result = next(action);
    console.log('middleware2 end');
    return result;
}
const myReducer = (state, action) => {
    console.log('myReducer');
    return state;
};
const store = createStore(myReducer, applyMiddleware(middleware1, middleware2));
store.disaptch({ type: 'someAction' });
```

간단히 두 개의 미들웨어를 정의했다. 그리고 아무 일도 하지 않는 리듀서를 정의했다. applyMiddleware 함수를 이용해서 미들웨어가 입력된 스토어를 생성했다. 

맨 마지막 행 코드에 의해서 출력되는 로그를 순서대로 나열하면 다음과 같다.

```jsx
middleware1 start
middleware2 start
myReducer
middleware2 end
middleware1 end
```

middleware1 미들웨어에서 호출한 next 함수는 middleware2 미들웨어 함수를 실행한다. middleware2 미들웨어에서 호출한 next 함수는 스토어가 원래 갖고 있던 dispatch 메서드를 호출한다. 최종적으로 스토어의 dispatch 메서드는 리듀서를 호출한다. 각 미들웨어에서는 리듀서 호출 전후에 필요한 작업을 정의할 수 있다. 

> **리덕스의 applyMiddleware 함수**
>
> 리덕스의 applyMidleware 함수를 이해하기 위해 다음의 간소화된 코드를 살펴보자.
>
> ```jsx
> const applyMiddleware = (...middlewares) => createStore => (...args) => {
>     const store = createStore(...args);
>     const funcWithStore = middlewares.map(middleware => middleware(store));
>     const chainedFun = funcsWithStore.reduce((a, b) => next => a(b(next)));
>     
>     return {
>         ...store,
>         dispatch: chainedFunc(store.dispatch),
>     };
> };
> ```
>
> 입력된 createStore 함수를 호출해서 스토어를 생성한다. 생성된 스토어와 함께 모든 미들웨어의 첫 번째 함수를 호출한다. 미들웨어의 첫 번째 함수를 호출하면 next 매개변수를 갖는 두 번째 함수가 만들어진다. funcWithStore의 모든 함수는 클로저를 통해서 store 객체에 접근할 수 있다. 모든 미들웨어의 두 번째 함수를 체인으로 연결했다. 만약 미들웨어가 세 개였다면 chainedFunc 함수는 next => a(b(c(next)))와 같다. 외부에 노출되는 스토어의 dispatch 메서드는 미들웨어가 적용된 버전으로 변경된다. 만약 미들웨어가 두 개였다면 a(b(store.dispatch))와 같다. 따라서 사용자가 dispatch 메서드를 호출하면 첫 번째 미들웨어 함수부터 실행된다. 그리고 마지막 미들웨어가 store.dispatch 메서드를 호출한다. 
>
> 다음은 리덕스 스토어의 dispatch 메서드를 간소화한 코드다.
>
> ```jsx
> function dispatch(action) {
>     currentState = currentReducer(currentState, action);
>     for (let i = 0; i < listeners.length; i++) {
>         listners[i]();
>     }
>     return action;
>  }
> ```
>
> 리듀서 함수를 호출해서 상탯값을 변경한다. dispatch 메서드가 호출될 때마다 등록된 모든 이벤트 처리 함수를 호출한다. 상탯값이 변경되지 않아도 이벤트 처리 함수를 호출하는 것에 주목하자. 상탯값 변경을 검사하는 코드는 각 이벤트 처리 함수에서 구현해야 한다. 참고로 react-redux 패키지의 connect 함수에서는 자체적으로 상탯값 변경을 검사한다.

##### 미들웨어 활용 예

개발 환경에서 디버깅 목적으로 미들웨어를 활용할 수 있다. 다음은 액션이 발생할 때마다 이전 상탯값과 이후 상탯값을 로그로 출력하는 미들웨어 코드다.

```jsx
const printLog = store => next => action => {
    console.log(`prev state = ${store.getState()}`);
    const result = next(action);
    console.log(`next state = ${store.getState()}`);
    return result;
};
```

next 함수를 호출하면 리듀서가 호출되기 때문에 next 함수 호출 전후로 로그를 출력하고 있다.

다음은 리듀서에서 예외가 발생하면 자동으로 서버에 에러 정보를 전송하는 미들웨어 코드다.

```jsx
const reportCrash = store => next => action => {
    try {
        return next(action);
    } catch (err) {
        // 서버로 예외 정보 전송
    }
};
```

참고로 리듀서뿐만 아니라 하위의 미들웨어 코드에서 발생하는 예외도 catch 문으로 들어온다.

다음은 사용자가 원하는 경우 액션 처리를 일정 시간 동안 연기할 수 있는 미들웨어 코드다.

```jsx
const delayAcion = store => next => action => {
    const delay = action.meta && action.meta.delay;
    if (!delay) {
        return next(action);
    }
    const timeoutId = setTimeout(() => next(action), delay);
    return function cancel() {
        clearTimeout(timeoutId);
    };
};
```

액션 객체에 delay 정보가 포함되어 있지 않다면 아무 일도 하지 않는다. 만약 delay 정보가 포함되어 있다면 정해진 시간만큼 연기한다. 반환된 함수를 호출하면 next 함수의 호출을 막을 수 있다. 

다음은 delayAction 미들웨어를 활용하는 코드다.

```jsx
const cancel = store.dispatch({
    type: 'SomeAction',
    meta: { delay: 1000 },
});
// ...
cancel();
```

액션 처리를 1초 동안 연기하기 위해 delay 정보를 입력했다. 원하는 순간에 액션 처리를 취소할 수 있다.

다음은 특정 액션이 발생하면 로컬 스토리지(localStorage)에 값을 저장하는 미들웨어 코드다.

```jsx
const saveToLocalStorage = store => next => action => {
    if (action.type === 'SET_NAME') {
        localStorage.setItem('name', action.name);
    }
    return next(action);
};
```

'SET_NAME' 액션이 발생할 때마다 로컬 스토리지에 값을 저장한다.

#### 리듀서

리듀서(reducer)는 액션이 발생했을 때 새로운 상탯값을 만드는 함수다. 리듀서의 구조는 다음과 같다.

```jsx
(state, action) => nextState
```

 다음은 할 일 목록 데이터를 처리하는 리듀서 함수다.

```jsx
function reducer(state = INITIAL_STATE, action) {
    switch (action.type) {
    	// ...
        case REMOVE_ALL:
            return {
                ...state,
                todos: [],
            };
        case REMOVE:
            return {
                ...state,
                todos: state.todos.filter(todo => todo.id !== action.id),
            };
        default: 
            return state;
    }
}

const INITIAL_STATE = { todos: [] }
```

리덕스는 스토어를 생성할 때 상탯값이 없는 상태로 리듀서를 호출하므로, 매개변수의 기본값을 사용해서 초기 상탯값을 정의한다. 각 액션 타입별로 case 문을 만들어서 처리한다. 상탯값은 불변 객체로 관리해야 하므로 수정할 때마다 새로운 객체를 생성한다. 전개 연산자를 사용하면 상탯값을 불변 객체로 관리할 수 있다. 처리할 액션이 없다면 상탯값을 변경하지 않는다. 

전개 연산자를 사용하더라도 수정하려는 값이 상탯값의 깊은 곳에 있다면 수정이 쉽지 않다. 다음은 할일 목록을 추가하는 리듀서 코드다.

```jsx
function reducer(state = INITIAL_STATE, action) {
    switch (action.type) {
        case ADD:
            return {
                ...state,
                todos: [
                    ...state.todos,
                    { id: getNewId(), title: action.title, priority: action.prioirty },
                ],
            };
    	// ...
    }
}
```

할 일 목록을 추가하기 위해 전개 연산자를 두 번 사용했다. 지금은 두 단계 밑에 있는 값을 수정하고 있지만, 더 깊은 곳에 있는 값을 수정할 때는 코드의 가독성이 많이 떨어진다. 자바스크립트에서 불변 객체를 관리할 목적으로 나온 여러 패키지가 있는데 여기서는 이머(immer) 패키지를 사용해서 설명한다.

##### 이머를 이용해서 리듀서 작성하기

다음은 사람 객체에서 나이를 수정하기 위해 이머를 사용한 코드다.

```jsx
import produce from 'immer';

const person = { name: 'mike', age: 22 };
const newPerson = produce(person, draft => {
    draft.age = 32;
});
```

produce 함수의 첫 번째 매개변수는 변경하고자 하는 객체를 나타낸다. 두 번째 매개변수는 첫 번째 매개변수로 입력된 객체를 수정하는 함수다. 위의 코드에서 draft 매개변수는 person 객체라고 생각하고 코드를 작성하면 된다. draft.age를 수정해도 person 객체의 값은 변경되지 않는다. draft 객체를 수정하면 produce 함수가 새로운 객체를 반환한다.

다음은 리듀서 함수를 이머를 사용해서 리팩토링한 코드다.

```jsx
function reducer(state = INITIAL_STATE, action) {
    return produce(state, draft => {
        switch (action.type) {
            case ADD:
                draft.todos.push(action.todo);
                break;
            case REMOVE_ALL:
                draft.todos = [];
                break;
            case REMOVE:
                draft.todos = draft.todos.filter(todo => todo.id !== action.id);
                break;
            default:
                break;
        }
    });
}
```

switch 문 전체를 produce로 감싼다. 이머를 사용했기 때문에 배열의 push 메서드를 사용해도 기존 상탯값은 직접 수정되지 않고 새로운 객체가 생성된다.

##### 리듀서 작성 시 주의할 점: 데이터 참조

리덕스의 상탯값은 불변 객체이기 때문에 언제든지 객체의 참조값이 변경될 수 있다. 따라서 객체를 참조할 때는 객체의 참조값이 아니라 고유한 ID 값을 이용하는 게 좋다. 다음은 데이터 참조의 잘못된 예다.

```jsx
function reducer(state = INITIAL_STATE, action) {
    return produce(state, drafy => {
        switch (action.type) {
            case SET_SELECTED_PEOPLE:
                draft.selectedPeople = draft.peopleList.find(
                	item => item.id === action.id,
                );
                break;
            case EDIT_PEOPLE_NAME:
                const people = draft.peopleList.find(item => item.id === action.id);
                people.name = action.name;
                break;
            // ...
        }
    });
}
```

selectedPeople 변수는 현재 선택된 사람을 참조한다. 만약 selectedPeople 변수가 참조하는 사람의 정보가 수정되면 selectedPeople 변수는 더 이상 그 사람을 참조하지 못한다. 이는 사람의 정보가 수정될 때 새로운 객체가 생성되는데, selectedPeople 변수는 오래된 객체를 참조하기 때문이다. 

따라서 데이터를 참조할 때는 객체의 참조값이 아니라 다음과 같은 ID 값으로 참조해야 한다.

```jsx
function reducer(state = INITIAL_STATE, action) {
    return produce(state, draft => {
        switch (action.type) {
            case SET_SELECTED_PEOPLE:
                draft.selectedPeople = action.id;
                break;
            // ...
        }
    });
}
```

ID 값으로 참조하면 객체의 데이터가 변경되어도 별 문제 없이 데이터를 가리킬 수 있다.

```jsx
function reducer(state = INITIAL_STATE, action) {
    return produce(state, draft) => {
        switch (action.type) {
            case SAY_HELLO:
                const random = Math.floor(Math.random() * 10 + 1);
                draft.msg = `안녕하세요, ${action.name}님의 행운의 숫자는 ${random}입니다.`;
                break;
            case INCREMENT:
                callApi({ url: '/sendActionLog', data: action });
                draft.value += 1;
                break;
            // ...
        }
    });
}
```

랜덤 함수를 이용해서 다음 상탯값을 만들면 안 된다. 랜덤 함수를 사용하면 같은 인수로 호출해도 다른 값이 반환될 수 있기 때문에 순수 함수가 아니다. API 호출은 부수 효과이기 때문에 API를 호출하는 함수는 순수 함수가 아니다. API 호출은 액션 생성자 함수나 미들웨어에서 하면 된다.

##### createReducer 함수로 리듀서 작성하기

지금까지 리듀서 함수를 작성할 때 switch 문을 사용했지만, createReducer 함수를 이용하면 switch 문보다 더 간결하게 리듀서 함수를 작성할 수 있다. createReducer 함수는 리덕스에서 제공하는 함수는 아니지만 리덕스 생태계에서 많이 쓰인다.

다음은 할 일 목록 데이터를 처리하는 리듀서 함수를 createReducer 함수로 작성한 코드다.

```jsx
const reducer = createReducer(INITIAL_STATE, {
    [ADD]: (state, action) => state.todos.push(action.todo),
    [REMOVE_ALL]: state => (state.todos = []),
    [REMOVE]: (state, action) =>
    	(state.todos = state.todos.filter(todo => todo.id !== action.id)),
});
```

createReducer 함수의 첫 번째 인자로 초기 상탯값을 입력했다. createReducer 함수의 두 번째 인자는 액션 처리 함수를 담고 있는 객체다. 이전에 switch 문으로 작성했던 코드보다 더 간결해진 것을 확인할 수 있다.

다음은 createReducer 함수를 정의한 코드다.

```jsx
import produce from 'immer';

function createReducer(initialState, handleMap) {
    return function(state = initialState, action) {
        return produce(state, draft => {
            const handler = handlerMap[action.type];
            if (handler) {
                handler(draft, action);
            }
        });
    };
}
```

createReducer 함수는 리듀서 함수를 반환한다. 초기 상탯값인 initialState 변수를 state 매개변수의 기본값으로 사용했다. 리듀서 함수 전체를 이머의 produce 함수로 감쌌다. 등록된 액션 처리 함수가 있다면 실행한다.

#### 스토어

스토어(store)는 리덕스의 상탯값을 가지는 객체다. 액션의 발생은 스토어의 dispatch, 메서드로 시작된다. 스토어는 액션이 발생하면 미들웨어 함수를 실행하고, 리듀서를 실행해서 상탯값을 새로운 값으로 변경한다. 그리고 사전에 등록된 모든 이벤트 처리 함수에게 액션의 처리가 끝났음을 알린다.

리덕스의 첫 번째 원칙에서 애플리케이션의 전체 상탯값을 하나의 스토어에 저장하라고 했다. 기술적으로는 여러 개의 스토어를 만들어서 사용해도 문제가 되지 않는다. 하지만 단순히 데이터의 종류에 따라 구분하기 위한 용도라면 나중에 설명할 combineReducer 함수를 이용하면 된다. 그리고 특별한 이유가 없다면 스토어는 하나만 만드는 게 좋다.

외부에서 상탯값 변경 여부를 알기 위해서는 스토어에 이벤트 처리 함수를 등록하면 된다. 다음은 스토어의 subscribe 메서드를 사용해서 상탯값 변경 여부를 검사하는 코드다.

```jsx
const INITIAL_STATE = { value: 0 };
const reducer = createReducer(INITIAL_STATE, {
    INCREMENT: state => (state.value += 1),
});
const store = createStore(reducer);

let prevState;
store.subscribe(() => {
    const state = store.getState();
    if (state === prevState) {
        console.log('상탯값 같음');
    } else {
        console.log('상탯값 변경됨');
    }
    prevState = state;
});

store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'OTHER_ACTION' });
store.dispatch({ type: 'INCREMENT' });
```

subscribe 메서드를 이용해서 이벤트 처리 함수를 등록했다. 스토어에 등록된 함수는 액션이 처리될 때마다 호출된다. 상탯값이 변경됐는지 검사한다. 상탯값이 불변 객체이기 때문에 이렇게 단순한 비교로 상탯값 변경 여부를 확인할 수 있다. 'INCREMENT' 액션이 발생하면 **상탯값 변경됨** 로그가 출력된다. 등록되지 않은 액션이 발생하면 **상탯값 같음** 로그가 출력된다. 

### 데이터 종류별로 상탯값 나누기

프로그램 안에서 사용되는 데이터의 양이 많아지면, 데이터를 체계적으로 구조화하는 방법이 필요하다. 프로그램의 모든 액션을 하나의 파일에 작성하거나 모든 액션 처리 로직을 하나의 리듀서 함수로 작성할 수는 없다. 보통 프로그램의 큰 기능별로 폴더를 만들어서 코드를 관리한다. 리덕스 코드도 각 기능 폴더 하위에 작성해서 관리하는 게 좋다.

리덕스에서 제공하는 combineReducer 함수를 이용하면 리듀서 함수를 여러 개로 분리할 수 있다. 이렇게 리듀서 함수를 여러 개로 작성하다 보면 공통 로직이 생길 수 있는데, 공통 로직을 별도로 분리해서 재사용하는 방법을 알아보자. 

하나의 프로젝트 안에서 기능 추가와 리팩터링을 반복하며 진행되므로 직접 코드를 작성해보자. 

##### 코드를 작성하기 위한 사전 작업

create-react-app 기반으로 프로젝트를 생성해보자.

```bash
$ npx create-react-app redux-text
```

먼저 src 폴더 밑에서 index.js 파일을 제외한 모든 파일을 지운다. index.js 파일의 내용도 모두 지우고 빈 상태로 둔 다음 두 개의 패키지를 설치한다. 

```bash
$ npm install redux immer
```

#### 상탯값 나누기 예제를 위한 사전 작업

페이스북 웹사이트를 구현한다고 생각해 보자. 짧게 생각해 봐도 정말 많은 기능이 떠오른다. 그 중에서 타임라인과 친구 목록을 구현해 보자.

타임라인에서는 사용자에게 보여 줄 여러 개의 게시물을 관리해야 한다. 각 게시물 데이터를 배열로 관리하자. 게시물을 배열에 추가하거나 배열에서 삭제할 수 있어야 한다. 그리고 각 게시물의 좋아요 숫자는 변하는 값이므로 배열에 추가된 게시물 데이터를 수정할 수 있어야 한다. 타임라인은 무한 스크롤 기능이 필요하기 때문에 이미 로딩된 데이터의 끝에 도달한다면 자동으로 다음에 이어지는 게시물 데이터를 서버로 요청해야 한다. 이를 위해 다음에 요청할 페이지 번호를 관리할 수 있어야 한다. 

친구 목록 데이터도 배열로 관리하자. 타임라인과 마찬가지로 친구를 배열에 추가하거나 배열에서 삭제할 수 있어야 한다. 친구가 수정한 프로필 정보를 반영하기 위해 배열에 있는 친구 데이터를 수정할 수 있는 기능도 필요하다. 

리듀서 함수를 만들기 위해 이전에 작성했던 createReducer 함수를 이용하자. src 폴더 밑에 common 폴더를 만든다. 그 다음 common 폴더 밑에 createReducer.js 파일을 만들고 다음 내용을 입력한다. 

```jsx
import produce from "immer";

export default function createReducer(initialState, handlerMap) {
    return function(state = initialState, action) {
        return produce(state, draft => {
            const handler = handlerMap[action.type];
            if (handler) {
                handler(draft, action);
            }
        });
    };
}
```

##### 친구 목록을 위한 리덕스 코드 작성하기

이제 친구 목록을 위한 액션과 리듀서 코드를 작성해 보자. src 폴더 밑에 friend 폴더를 만들고 friend 폴더 밑에 state.js 파일을 만들어서 다음 코드를 입력한다. 

```jsx
import createReducer from "../common/createReducer";

const ADD = "freind/ADD";
const REMOVE = "friend/REMOVE";
const EDIT = "friend/EDIT";

export const addFriend = (friend) => ({ type: ADD, friend });
export const removeFriend = (friend) => ({ type: REMOVE, friend });
export const editFriend = (friend) => ({ type: EDIT, friend });

const INITIAL_STATE = { friends: [] };
const reducer = createReducer(INITIAL_STATE, {
  [ADD]: (state, action) => state.friends.push(action.friend),
  [REMOVE]: (state, action) =>
    (state.friends = state.friends.filter(
      (friend) => friend.id !== action.friend.id
    )),
  [EDIT]: (state, action) => {
    const index = state.friends.findIndex(
      (friend) => friend.id === action.friend.id
    );
    if (index >= 0) {
      state.friends[index] = action.friend;
    }
  },
});
export default reducer;
```

액션 타입을 상수 변수로 정의했다. 그리고 액션 생성자 함수를 정의했다. 이 함수는 외부에서 사용해야 하므로 export 키워드를 사용해 외부에 공개한다. 친구 데이터를 추가하는 리듀서 코드를 작성했다. 리듀서는 스토어를 생성할 때 필요하기 때문에 외부로 공개한다. createReducer 함수에서 immer 패키지를 사용했으므로 리듀서 함수에서 간편하게 상탯값을 수정할 수 있다.

> **덕스 패턴**
>
> 위의 코드에서는 친구 목록을 위한 리덕스 코드를 하나의 파일에서 작성했다. 리덕스 공식 문서에서는 액션 타입, 액션 생성자 함수, 리듀서 함수를 각각의 파일로 만들어서 설명한다. 리덕스 공식 문서의 방법으로 리덕스 코드를 작성해 본 사람은 알겠지만, 이게 여간 귀찮은 작업이 아니다. 간단한 액션을 하나만 추가하려고 해도 세 개 이상의 파일을 열어서 수정해야 한다.
>
> 이 문제를 해결하기 위해 제안된 방식이 덕스(ducks) 패턴이다. 이 패턴이 오리와 어떤 관계인지는 모르겠지만 발음이 비슷해서 지어진 이름으로 보인다. 덕스 패턴의 규칙은 다음과 같다.
>
> + 연관된 액션 타입, 액션 생성자 함수, 리듀서 함수를 하나의 파일로 작성한다. 
> + 리듀서 함수는 export default 키워드로 내보낸다.
> + 액션 생성자 함수는 export 키워드로 내보낸다.
> + 액션 타입은 접두사와 액션 이름을 조합해서 만든다. 
>
> 위의 코드는 덕스 패턴을 따르고 있다. 대부분의 경우 덕스 패턴으로 리덕스 코드를 작성하는 것이 효율적이다. 하지만 특정 파일의 코드가 많아지면 굳이 하나의 파일을 고집할 필요는 없다. 예를 들어, redux-thunk 패키지를 이용해서 비동기 코드를 작성하는 경우에는 액션 생성자 함수의 코드 양이 많아진다. 이럴 때는 리듀서 코드와 액션 코드를 별도의 파일로 분리하는 게 좋다. 

##### 타임라인을 위한 리덕스 코드 작성하기

이제 타임라인 코드를 작성해 보자. src 폴더 밑에 timeline 폴더를 만든 다음, timeline 폴더 밑에 state.js 파일을 만들어서 다음 코드를 입력한다. 

```jsx
import createReducer from "../common/createReducer";

const ADD = 'timeline/ADD';
const REMOVE = 'timeline/REMOVE';
const EDIT = 'timeline/EDIT';
const INCREASE_NEXT_PAGE = 'timeline/InCREASE_NEXT_PAGE';

export const addTimeLine = timeline => ({ type: ADD, timeline });
export const removeTimeLine = timeline => ({ type: REMOVE, timeline });
export const editTimeLine = timeline => ({ type: EDIT, timeline });
export const increaseNextPage = () => ({ type: INCREASE_NEXT_PAGE });

const INITIAL_STATE = { timelines: [], nextPage: 0 };
const reducer = createReducer(INITIAL_STATE, {
    [ADD]: (state, action) => state.timelines.push(action.timeline),
    [REMOVE]: (state, action) => (state.timelines = state.timelines.filter(
    	timeline => timeline.id !== action.timeline.id,
    )),
    [EDIT]: (state, action) => {
        const index = state.timelines.findIndex(
        	timeline => timeline.id === action.timeline.id,
        );
        if (index >= 0) {
            state.timelines[index] = action.timeline;
        }
    },
    [INCREASE_NEXT_PAGE]: (state, action) => (state.nextPage += 1),
});
export default reducer;
```

타임라인의 끝에 도달했을 때 서버에게 요청할 페이지 번호를 관리하는 액션 타입이다. 나머지 액션 타입은 친구 목록의 경우와 비슷하다. 페이지 번호를 증가시키는 액션 생성자 함수다. 나머지 액션 생성자 함수는 친구 목록의 경우와 비슷하다. 타임라인의 상탯값에는 다음 페이지 번호도 저장된다. 페이지 번호를 증가시키는 리듀서 코드다. 나머지 리듀서 코드는 친구 목록의 경우와 비슷하다. 타임라인 코드도 덕스 패턴을 따르고 있다. 

지금까지 잘 따라 했다면 프로젝트의 폴더 구조는 다음과 같이 나타난다.

```bash
redux-test
└── src 
	├── common ────── createReducer.js
	├── friend ────── state.js
	├── timeline ──── state.js
	└── index.js
```

friend, timeline 폴더 밑에는 각각의 기능 구현을 위한 파일을 추가할 수 있다. 각 기능에서 사용되는 리액트 컴포넌트 파일도 해당 폴더 밑에서 작성하면 된다. 물론 이는 하나의 방법일 뿐이므로 각자의 상황에 맞는 폴더 구조를 고민해서 구성하기 바란다.

##### 여러 리듀서를 하나로 합치기

우리는 두 개의 리듀서 함수를 만들었다. 리덕스에서 제공하는 combineReducers 함수를 이용하면 여러 개의 리듀서를 하나로 합칠 수 있다. src 폴더 밑에 있는 index.js 파일에 다음 코드를 입력하자. 

```jsx
import { createStore, combineReducers } from 'redux';
import timelineReducer, { addTimeline, removeTimeline, editTimeline, increaseNextPage, } from './timeline/state';
import friendReducder, { addFriend, removeFriend, editFriend, } from './friend/state';

const reducer = combineReducer({
    timeline: timelineReducer,
    friend: friendReducer,
});
const store = createStore(reducer);
store.subscribe(() => {
    const state = store.getState();
    console.log(state);
});

store.dispatch(addTimeLine({ id: 1, desc: '프론트엔드 개발 취업하기' }));
store.dispatch(addTimeLine({ id: 2, desc: '면접을 보자' }));
store.dispatch(increaseNextPage());
store.dispatch(addTimeLine({ id: 2, desc: '리액트 공부하기' }));
store.dispatch(addTimeLine({ id: 1, desc: '리덕스도 공부하자' }));

store.dispatch(addFriend({ id: 1, name: '아이유' }));
store.dispatch(addFriend({ id: 2, name: '손나은' }));
store.dispatch(addFriend({ id: 2, name: '수지' }));
store.dispatch(addFriend({ id: 1, name: '아이유' }));
```

친구 목록과 타임라인 모듈에서 액션 생성자 함수와 리듀서 함수를 가져온다. combineReducer 함수를 이용해 두 개의 리듀서를 하나로 합쳤다. 상탯값에는 각각 timeline, friend라는 이름으로 데이터가 저장된다. 스토어를 생성한다. 디버깅을 위해 액션 처리가 끝날 때마다 상탯값을 로그로 출력한다. 타임라인을 테스트하기 위해 다섯 개의 액션을 생성한다. 친구 목록을 테스트하기 위해 네 개의 액션을 생성한다. 

npm start 명령어를 입력해서 결과를 확인해 보자. 브라우저에서 개발자 모드를 켜서 로그를 확인해 본다. 마지막 상탯값은 다음과 같다.

```jsx
const state = {
    timeline: {
        timelines: [{ id: 2, desc: '리액트 공부하기' }],
        nextPage: 1,
    },
    friend: {
        friends: [{ id: 2, name: '수지' }],
    },
};
```

이처럼 combineReducers 함수를 이용하면 리듀서별로 상탯값을 관리할 수 있다.

#### 리듀서에서 공통 기능 분리하기

지금까지 작성한 타임라인 코드와 친구 목록 코드에는 서로 중복된 코드가 많다. 대략 다음과 같은 코드가 중복이다.

+ 배열과 관련된 액션 타입와 액션 생성자 함수
+ 초기 상탯값을 빈 배열로 정의
+ 배열의 데이터를 추가, 삭제, 수정하는 리듀서 코드

이 중복 코드를 별도의 파일로 분리해 보자. common 폴더 밑에 createItemsLogic.js 파일을 만들고 다음 코드를 입력한다.

```jsx
import createReducer from "./createReducer";

export default function createItemsLogic(name) {
    const ADD = `${name}/ADD`;
    const REMOVE = `${name}/REMOVE`;
    const EDIT = `${name}/EDIT`;
    
    const add = item => ({ type: ADD, item });
    const remove = item => ({ type: REMOVE, item });
    const edit = item => ({ type: EDIT, item });
    
    const reducer = createReducer(
    	{ [name]: [] },
        {
            [ADD]: (state, action) => state[name].push(action.item),
            [REMOVE]: (state, action) => {
                const index = state[name].findIndex(item => item.id === action.item.id);
                state[name].splice(index, 1);
            },
            [EDIT]: (state, action) => {
                const index = state[name].findIndex(item => item.id === action.item.id);
                if (index => 0) {
                    state[name][index] = action.item;
                }
            },
        },
    );
    
    return { add, remove, edit, reducer };
}
```

배열의 고유한 이름을 매개변수로 받는다. 입력받은 이름을 이용해서 액션 타입을 만든다. 액션 생성자 함수를 만든다. 초기 상탯값으로 빈 배열을 넣는다. 액션 생성자 함수와 리듀서 함수를 내보낸다. ADD와 EDIT를 처리하는 리듀서 코드의 로직은 이전에 작성했던 코드와 같다.

> **값에 의한 호출과 참조에 의한 호출**
>
> 위의 코드에서 REMOVE를 처리하는 코드는 filter 메서드를 이용하는 방법에서 splice 메서드를 이용하는 방법으로 변경됐다. 만약 다음과 같이 filter 메서드를 이용하면 원하는 대로 동작하지 않는다.
>
> ```jsx
> [REMOVE]: (state, action) => {
>     state = state.filter(item => item.id !== action.item.id);
> },
> ```
>
> 순간적으로 매개변수의 값만 변경될 뿐이다. 다음 코드는 이 상황을 구체적으로 설명해 준다. 
>
> ```jsx
> function myFunc(a) {
>     a = 20;
> }
> let v = 10;
> myFunc(v);
> console.log(v); // 10
> ```
>
> 매개변수의 값만 변경되고, 인수로 사용된 변수 v는 변하지 않는다. 이는 자바스크립트에서 함수의 호출은 값에 의한 호출(call by value)이기 때문이다. 

##### 기존 코드 리팩토링하기

friend/state.js 파일의 코드는 다음과 같이 간소화된다.

```jsx
import createItemsLogic from "../common/createItemsLogic";

const { add, remove, edit, reducer } = createItemLogic("friends");
export const addFriend = add;
export const removeFriend = remove;
export const editFriend = edit;
export default reducer;
```

위의 코드에서 작성한 공통 로직의 생성자 함수를 가져온다. friends라는 이름으로 공통 로직을 생성한다. 액션 생성자 함수를 원하는 이름으로 변경해서 내보낸다. 리듀서 함수를 그대로 내보낸다. 친구 목록의 모든  로직은 공통 로직으로 대체됐다.

이제 타임라인 코드도 공통 로직을 사용해서 리팩토링해보자. timeline/state.js 파일의 내용을 다음과 같이 수정한다.

```jsx
import createReducer from "../common/createReducer";
import createItemsLogic from '../common/createItemsLogic';
import mergeReducers from "../common/mergeReducers";

const { add, remove, edit, reducer: timelineReducer } = createItemsLogic("timelines");

const INCREASE_NEXT_PAGE = "timeline/INCREASE_NEXT_PAGE";

export const addTimeline = add;
export const removeTimeline = remove;
export const editTimeline = edit;
export const increaseNextPage = () => ({ type: INCREASE_NEXT_PAGE });

const INITIAL_STATE = { nextPage: 0 };
const reducer = createReducer(INITIAL_STATE, {
    [INCREASE_NEXT_PAGE]: (state, action) => (state.nextPage += 1)
});
const reducers = [reducer, timelineReducer];
export default mergeReducers(reducers);
```

공통 로직을 사용하기 위해 mergeReducers 함수를 사용했다. mergeReducers.js 파일의 내용은 잠시 후 살펴보자. timelines라는 이름으로 공통 로직을 생성한다. 공통 로직에 포함되지 않은 액션 타입, 액션 생성자 함수, 리듀서 코드를 정의한다. mergeReducers 함수를 사용해서 공통 로직의 리듀서 함수와 직접 작성한 리듀서 함수를 합친다. mergeReducers 함수는 리듀서 함수의 배열을 입력으로 받는다.

##### 여러 리듀서를 합치는 mergeReducders 함수

리덕스에서 제공하는 combineReducers 함수를 이용하면 상탯값의 깊이가 불필요하게 깊어진다. 다음은 리덕스에서 제공하는 combineReducers 함수를 사용해서 작성한 코드다.

```jsx
import { combineReducers } from 'redux';
// ...
export default combineReducers({
    common: reducer,
    timelines: timelinesReducer,
});
```

각 리듀서마다 새로운 이름을 부여하면서 객체의 깊이가 깊어진다. 다음은 위의 코드로 만들어진 초기 상탯값의 모습이다.

```jsx
const state = {
    timeline: {
        common: {
            nextPage: 0,
        },
        // ...
    }
}
```

불필요하게 common이라는 이름의 객체가 추가되었다.

이를 피하기 위해 mergeReducers 함수를 만들어 보자. common 폴더 밑에 mergeReducers.js 파일을 만들고 다음 코드를 입력하자.

```js
export default function mergeReducers(reducers) {
    return function(state, action) {
        if (!state) {
            return reducers.reduce((acc, r) => ({ ...acc, ...r(state, action) }), {});
        } else {
            let nextState = state;
            for (const r of reducers) {
                nextState = r(nextState, action);
            }
            return nextState;
        }
    };
}
```

mergeReducers 함수는 리듀서를 반환한다. 초기 상탯값을 계산할 때는 모든 리듀서 함수의 결괏값을 합친다. 초기화 단계가 아니라면 입력된 모든 리듀서를 호출해서 다음 상탯값을 반환한다. 

npm start 명령어를 실행해 보면 리팩토링하기 이전의 코드와 같은 결과가 출력되는 것을 확인할 수 있다. 하지만 공통 로직을 분리했기 때문에 코드는 더 간결해졌다. 



