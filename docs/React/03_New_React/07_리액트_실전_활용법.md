## 리액트 실전 활용법

useEffect 훅의 기능은 간단하지만 그것을 제대로 사용하려면 결코 쉽지 않다. 개발자들은 훅이 등장하기 전에 쓰이던 클래스형 컴포넌트에 익숙해져 있어 잘못된 방법으로 접근하는 경우가 많기 때문이다. useEffect 훅을 잘못 사용하면 오래된 데이터를 참조하거나 부수 효과가 자주 실행되는 문제가 발생할 수 있다.

이번에는 useEffect 훅을 제대로 사용하는 방법을 알아보자. 그리고 가독성과 생산성을 높이는 컴포넌트 작성 방법, 렌더링 속도를 올리기 위한 성능 최적화 방법도 알아보자. 

### 가독성과 생산성을 고려한 컴포넌트 코드 작성법

컴포넌트 코드를 작성할 때 가독성과 생산성을 높여 주는 방법을 알아보자. 같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있다. 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 사람 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드를 작성하는 게 좋다. 먼저 추천하는 컴포넌트 파일 작성법을 소개하고, 컴포넌트 속성값에 타입 정보를 추가하는 방법을 알아본다. 그리고 조건부 렌더링을 할 때 가독성이 높은 방식은 무엇인지 알아보고, 마지막으로 컨테이너 컴포넌트와 프레젠테이션 컴포넌트로 구분해서 폴더를 구성하는 방법도 알아보자. 

#### 추천하는 컴포넌트 파일 작성법

컴포넌트 파일에는 다양한 종류의 함수와 변수가 등장한다. 그로 인해 코드의 가독성이 떨어지고 관리가 힘들어질 수 있다. 가독성과 생산성을 높이기 위해 코드를 어떻게 배치하면 좋을지 살펴보자.

##### 컴포넌트 파일 작성 순서

다음은 추천하는 컴포넌트 파일 작성 예다.

```jsx
MyComponent.propTypes = {
    // ...
};

export default function MyComponent({prop1, prop2}) {
    // ...
}

const COLUMNES = [
    { id: 1, name: 'phoneNumber', width: 200, color: 'white' },
    { id: 1, name: 'city', width: 100, color: 'grey' },
    // ...
];

const URL_PRODUCT_LIST = '/api/products';
function getTotalPrice({ price, total }) {
    // ...
}
```

파일 최상단에는 속성값의 타입을 정의한다. 속성값 타입이 가장 먼저 오는 이유는 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해가 된다. 어떤 컴포넌트를 사용하기 위해서는 그 컴포넌트의 속성값 타입을 알아야 하므로 파일을 열었을 때 속성값 타입이 가장 먼저 보이는 게 좋다. 또한, 컴포넌트 작성자 입장에서도 속성값 타입은 다른 여느 코드 못지않게 중요하다. 따라서 속성값 타입 위쪽으로는 import 코드만 오도록 작성하자.

컴포넌트 파일의 매개변수는 명명된 매개변수로 정의하는 게 좋다. 속성값을 사용할 때마다 props.을 반복해서 입력하지 않아도 되므로 코드 작성이 편해진다. 그리고 컴포넌트 이름을 꼭 작성하자. function()처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 힘들다.

컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의한다. 특별한 이유가 없다면 변수는 상수 변수(const)로 정의하는 게 좋다. 그리고 상수 변수의 이름은 예제처럼 대문자로 작성하는 게 가독성에 좋다. 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하도록 하자. 그래야 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 있다. 

##### 서로 연관된 코드를 한 곳으로 모으기

이번에는 여러 가지 기능이 섞여 있는 코드를 어떻게 배치하면 좋을지 다음 코드를 통해 알아보자. 

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState(null);
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

모든 상탯값을 컴포넌트 함수 상단에서 정의하고 있다. 그리고 모든 useEffect 훅의 상탯값 코드 밑에 정의하고 있다.

앞의 코드에는 사용자 정보를 가져오는 기능과 창의 너비를 가져오는 기능이 섞여 있다. 다음은 각 기능별로 코드를 모아 놓은 코드다.

```jsx
function Profile({ userId }) { 
	const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
        const [width, setWidth] = useState(window.innerWidth);
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

사용자 정보를 가져오는 기능을 한 곳으로 모았다. 마찬가지로 창의 너비를 가져오는 기능을 한곳으로 모았다.

위에서 작성한 코드보다 현재의 코드가 가독성 면에서 낫다는 걸 알 수 있다. 이처럼 코드를 한곳에 모을 때는 훅의 종류별로 모으는 것보다는 연관된 코드끼리 모으는 게 좋다. 만약 컴포넌트 코드가 복잡하다고 느껴진다면 각 기능을 커스텀 훅으로 분리하는 것도 좋은 방법이다. 다음은 두 가지 기능을 각각 커스텀 훅으로 분리한 코드다.

```jsx
function Profile({ userId }) {
    const user = useUser(userId);
    const width = useWindowWidth();
    // ...
}

function useUser(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    return user;
}

function useWindowWidth() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    return width;
}
```

각 기능을 커스텀 훅으로 분리하면 Profile 컴포넌트 코드는 가독성이 좋아진다. 각 기능을 useUser, useWindowWidth 커스텀 훅으로 분리했다. 

기능을 커스텀 훅으로 분리하면 같은 기능을 다른 곳에서 사용하기 좋다. 기능을 재사용하는 곳이 없다고 하더라도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자. 다만 컴포넌트 코드가 복잡하지 않은 경우에는 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으니 필요하다고 판단되는 경우에만 분리하도록 하자.

#### 속성값 타입 정의하기: prop-types

prop-types는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지다. 속성값의 타입 정보는 컴포넌트 코드의 가독성을 위해서 필수로 작성하는 게 좋다. 코드에서 타입 정보가 필요한 이유를 간단하게 알아보자. 그리고 prop-types에서 기본적으로 제공하는 타입의 종류를 알아보고, 기본 타입 외에도 타입 정보의 함수를 이용해서 자신만의 타입을 만드는 방법도 알아보자. 

자바스크립트는 동적 타입 언어다. 타입이 없기 때문에 배우기 쉽고 간단한 프로그램을 작성할 때는 생산성이 좋다. 하지만 소스 파일이 50개가 넘어 가는 규모의 프로그램을 작성할 때는 오히려 생산성이 떨어진다. 그래서 가능하면 정적 타입 언어를 사용하는 게 좋다. 

하지만 상황이 여의치 않아서 동적 타입 언어를 사용해야만 할 때가 있다. 이를 위해 리액트에서는 속성값 타입을 정의할 수 있는 prop-types 패키지를 제공한다. prop-types를 사용할 경우 컴포넌트 사용 시 속성값에 잘못된 타입이 입력되면 콘솔에 에러 메시지가 출력된다. 이는 리액트가 렌더링하는 과정에서 잘못된 속성값 타입을 검사해 주기 때문에 가능하다. 물론 속성값 타입을 검사하기 위해 별도의 연산이 필요하므로 타입 검사는 개발 모드에서만 동작한다. 타입 에러를 사전에 검사할 수 있으므로 도움이 된다. 

prop-types를 사용했을 때 생기는 또 다른 장점은 타입 정의 자체가 훌륭한 문서가 된다는 점이다. 만약 속성값 타입 정보가 없다면 컴포넌트를 사용하는 사람 입장에서는 속성값의 정보를 파악하기 위해 코드를 일일이 들여다봐야 한다. 다음과 같이 속성값의 타입 정보를 입력하지 않은 컴포넌트를 사용해야 한다고 가정해 보자. 

```jsx
function User({ type, age, male, onChangeName, onChangeTitle }) {
    function onClick1() {
        const msg = `type: ${type}, age: ${age ? age : "알 수 없음"}`;
        log(msg, { color: type === "gold" ? "red" : "black" });
        // ...
    }
    function onClick2() {
        if (onChangeName) {
            onChangeName(name);
        }
        onChangeTitle(title);
        male ? goMalePage() : goFemalePage();
        // ...
    }
    // ...
}
```

각 속성의 타입이 무엇인지는 코드를 자세히 들여다보기 전까지 알기가 힘들다.

다음은 prop-types를 이용해서 위의 코드에 타입 정보를 추가한 코드다. 컴포넌트의 로직을 이해하지 않고도 속성값의 타입 정보를 한눈에 파악할 수 있다.

```jsx
User.propTypes = {
    male: PropTypes.bool.isRequired,
    age: PropTypes.number,
    type: PropTypes.oneOf(["gold", "silver", "bronze"]),
    onChangeName: PropTypes.func,
    onChangeTitle: PropTypes.func.isRequired
};
```

male 속성값은 필숫값이기 때문에 부모 컴포넌트에서 이 값을 주지 않으면 에러 메시지가 출력된다. 반대로 age 속성값은 필숫값이 아니기 때문에 이 값을 주지 않아도 에러는 발생하지 않는다. 만약 age 속성값으로 문자열을 줬다면 타입이 잘못됐다는 에러 메시지가 출력된다. type 속성값에는 gold, silver, bronze 중의 하나만 입력할 수 있다. 여기서 한 가지 부족한 타입 정보는 onChangeName과 같은 함수의 타입이다. prop-types에서 함수의 매개변수와 반환값에 대한 타입 정보는 정의할 수 없다. 이 경우에는 문서화를 위해 타입 정보를 주석으로 자세히 적기를 추천한다. 

##### prop-types로 정의할 수 있는 타입

다음 코드는 prop-types로 정의할 수 있는 여러 가지 타입을 보여 준다. 자세한 설명은 주석을 통해 확인할 수 있다. 

```jsx
MyComponent.propTypes = {
    // 리액트 요소
    // <div>hello</div> => 참
    // <SomeComponent /> => 참
    // 123 => 거짓
    menu: PropTypes.element,
    
    // 컴포넌트 함수가 반환할 수 있는 모든 것
    // number, string, array, element, ...
    // <SomeComponent /> => 참
    // 123 => 참
    description: PropTypes.node,
    
    // Message 클래스로 생성된 모든 객체
    // new Message() => 참
    // new Car() => 거짓
    message: PropTypes.instanceOf(Message),
    
    // 배열에 포함된 값 중에서 하나를 만족
    // 123 => 참
    // 'messy' => 참
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    
    // 특정 타입만 포함하는 배열
    // [1, 5, 7] => 참
    // ['a', 'b'] => 거짓
    ages: PropTypes.arrayOf(PropTypes.number),
    
    // 객체의 속성값 타입을 정의
    // {color: 'red', weight: 123} => 참
    // {color: 'red', weight: '123kg'} => 거짓
    info: PropTypes.shape({
        color: PropTypes.string,
        weight: PropTypes.number
    }),
    
    // 객체에서 모든 속성값의 타입이 같은 경우
    // {prop1: 123, prop2: 456} => 참
    // {prop1: 'red', prop2: 123} => 거짓
    infos: PropTypes.objectOf(PropTypes.number)
};
```

이처럼 prop-types가 제공하는 타입 정의 함수를 이용하면 웬만한 타입 정보는 표현할 수 있다. 그리고 다음과 같이 본인만의 타입 함수를 작성할 수도 있다. 

```jsx
MyComponent.propTypes = {
    age: function(props, propName, componentName) {
        const value = props[propName];
        if (value < 10 || value > 20) {
            return new Error(
            	`Invalid prop ${propName} supplied to ${componentName}.
                It must be 10 <= value <= 20.`
            );
        }
    }
};
```

age 속성값의 타입은 10 이상이고 20 이하인 숫자로 정의됐다. 조건에 맞지 않는 값이 들어오면 에러를 반환한다. 

