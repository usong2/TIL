## 리액트 실전 활용법

useEffect 훅의 기능은 간단하지만 그것을 제대로 사용하려면 결코 쉽지 않다. 개발자들은 훅이 등장하기 전에 쓰이던 클래스형 컴포넌트에 익숙해져 있어 잘못된 방법으로 접근하는 경우가 많기 때문이다. useEffect 훅을 잘못 사용하면 오래된 데이터를 참조하거나 부수 효과가 자주 실행되는 문제가 발생할 수 있다.

이번에는 useEffect 훅을 제대로 사용하는 방법을 알아보자. 그리고 가독성과 생산성을 높이는 컴포넌트 작성 방법, 렌더링 속도를 올리기 위한 성능 최적화 방법도 알아보자. 

### 가독성과 생산성을 고려한 컴포넌트 코드 작성법

컴포넌트 코드를 작성할 때 가독성과 생산성을 높여 주는 방법을 알아보자. 같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있다. 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 사람 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드를 작성하는 게 좋다. 먼저 추천하는 컴포넌트 파일 작성법을 소개하고, 컴포넌트 속성값에 타입 정보를 추가하는 방법을 알아본다. 그리고 조건부 렌더링을 할 때 가독성이 높은 방식은 무엇인지 알아보고, 마지막으로 컨테이너 컴포넌트와 프레젠테이션 컴포넌트로 구분해서 폴더를 구성하는 방법도 알아보자. 

#### 추천하는 컴포넌트 파일 작성법

컴포넌트 파일에는 다양한 종류의 함수와 변수가 등장한다. 그로 인해 코드의 가독성이 떨어지고 관리가 힘들어질 수 있다. 가독성과 생산성을 높이기 위해 코드를 어떻게 배치하면 좋을지 살펴보자.

##### 컴포넌트 파일 작성 순서

다음은 추천하는 컴포넌트 파일 작성 예다.

```jsx
MyComponent.propTypes = {
    // ...
};

export default function MyComponent({prop1, prop2}) {
    // ...
}

const COLUMNES = [
    { id: 1, name: 'phoneNumber', width: 200, color: 'white' },
    { id: 1, name: 'city', width: 100, color: 'grey' },
    // ...
];

const URL_PRODUCT_LIST = '/api/products';
function getTotalPrice({ price, total }) {
    // ...
}
```

파일 최상단에는 속성값의 타입을 정의한다. 속성값 타입이 가장 먼저 오는 이유는 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해가 된다. 어떤 컴포넌트를 사용하기 위해서는 그 컴포넌트의 속성값 타입을 알아야 하므로 파일을 열었을 때 속성값 타입이 가장 먼저 보이는 게 좋다. 또한, 컴포넌트 작성자 입장에서도 속성값 타입은 다른 여느 코드 못지않게 중요하다. 따라서 속성값 타입 위쪽으로는 import 코드만 오도록 작성하자.

컴포넌트 파일의 매개변수는 명명된 매개변수로 정의하는 게 좋다. 속성값을 사용할 때마다 props.을 반복해서 입력하지 않아도 되므로 코드 작성이 편해진다. 그리고 컴포넌트 이름을 꼭 작성하자. function()처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 힘들다.

컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의한다. 특별한 이유가 없다면 변수는 상수 변수(const)로 정의하는 게 좋다. 그리고 상수 변수의 이름은 예제처럼 대문자로 작성하는 게 가독성에 좋다. 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하도록 하자. 그래야 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 있다. 

##### 서로 연관된 코드를 한 곳으로 모으기

이번에는 여러 가지 기능이 섞여 있는 코드를 어떻게 배치하면 좋을지 다음 코드를 통해 알아보자. 

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState(null);
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

모든 상탯값을 컴포넌트 함수 상단에서 정의하고 있다. 그리고 모든 useEffect 훅의 상탯값 코드 밑에 정의하고 있다.

앞의 코드에는 사용자 정보를 가져오는 기능과 창의 너비를 가져오는 기능이 섞여 있다. 다음은 각 기능별로 코드를 모아 놓은 코드다.

```jsx
function Profile({ userId }) { 
	const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
        const [width, setWidth] = useState(window.innerWidth);
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

사용자 정보를 가져오는 기능을 한 곳으로 모았다. 마찬가지로 창의 너비를 가져오는 기능을 한곳으로 모았다.

위에서 작성한 코드보다 현재의 코드가 가독성 면에서 낫다는 걸 알 수 있다. 이처럼 코드를 한곳에 모을 때는 훅의 종류별로 모으는 것보다는 연관된 코드끼리 모으는 게 좋다. 만약 컴포넌트 코드가 복잡하다고 느껴진다면 각 기능을 커스텀 훅으로 분리하는 것도 좋은 방법이다. 다음은 두 가지 기능을 각각 커스텀 훅으로 분리한 코드다.

```jsx
function Profile({ userId }) {
    const user = useUser(userId);
    const width = useWindowWidth();
    // ...
}

function useUser(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    return user;
}

function useWindowWidth() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    return width;
}
```

각 기능을 커스텀 훅으로 분리하면 Profile 컴포넌트 코드는 가독성이 좋아진다. 각 기능을 useUser, useWindowWidth 커스텀 훅으로 분리했다. 

기능을 커스텀 훅으로 분리하면 같은 기능을 다른 곳에서 사용하기 좋다. 기능을 재사용하는 곳이 없다고 하더라도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자. 다만 컴포넌트 코드가 복잡하지 않은 경우에는 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으니 필요하다고 판단되는 경우에만 분리하도록 하자.

#### 속성값 타입 정의하기: prop-types

prop-types는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지다. 속성값의 타입 정보는 컴포넌트 코드의 가독성을 위해서 필수로 작성하는 게 좋다. 코드에서 타입 정보가 필요한 이유를 간단하게 알아보자. 그리고 prop-types에서 기본적으로 제공하는 타입의 종류를 알아보고, 기본 타입 외에도 타입 정보의 함수를 이용해서 자신만의 타입을 만드는 방법도 알아보자. 

자바스크립트는 동적 타입 언어다. 타입이 없기 때문에 배우기 쉽고 간단한 프로그램을 작성할 때는 생산성이 좋다. 하지만 소스 파일이 50개가 넘어 가는 규모의 프로그램을 작성할 때는 오히려 생산성이 떨어진다. 그래서 가능하면 정적 타입 언어를 사용하는 게 좋다. 

하지만 상황이 여의치 않아서 동적 타입 언어를 사용해야만 할 때가 있다. 이를 위해 리액트에서는 속성값 타입을 정의할 수 있는 prop-types 패키지를 제공한다. prop-types를 사용할 경우 컴포넌트 사용 시 속성값에 잘못된 타입이 입력되면 콘솔에 에러 메시지가 출력된다. 이는 리액트가 렌더링하는 과정에서 잘못된 속성값 타입을 검사해 주기 때문에 가능하다. 물론 속성값 타입을 검사하기 위해 별도의 연산이 필요하므로 타입 검사는 개발 모드에서만 동작한다. 타입 에러를 사전에 검사할 수 있으므로 도움이 된다. 

prop-types를 사용했을 때 생기는 또 다른 장점은 타입 정의 자체가 훌륭한 문서가 된다는 점이다. 만약 속성값 타입 정보가 없다면 컴포넌트를 사용하는 사람 입장에서는 속성값의 정보를 파악하기 위해 코드를 일일이 들여다봐야 한다. 다음과 같이 속성값의 타입 정보를 입력하지 않은 컴포넌트를 사용해야 한다고 가정해 보자. 

```jsx
function User({ type, age, male, onChangeName, onChangeTitle }) {
    function onClick1() {
        const msg = `type: ${type}, age: ${age ? age : "알 수 없음"}`;
        log(msg, { color: type === "gold" ? "red" : "black" });
        // ...
    }
    function onClick2() {
        if (onChangeName) {
            onChangeName(name);
        }
        onChangeTitle(title);
        male ? goMalePage() : goFemalePage();
        // ...
    }
    // ...
}
```

각 속성의 타입이 무엇인지는 코드를 자세히 들여다보기 전까지 알기가 힘들다.

다음은 prop-types를 이용해서 위의 코드에 타입 정보를 추가한 코드다. 컴포넌트의 로직을 이해하지 않고도 속성값의 타입 정보를 한눈에 파악할 수 있다.

```jsx
User.propTypes = {
    male: PropTypes.bool.isRequired,
    age: PropTypes.number,
    type: PropTypes.oneOf(["gold", "silver", "bronze"]),
    onChangeName: PropTypes.func,
    onChangeTitle: PropTypes.func.isRequired
};
```

male 속성값은 필숫값이기 때문에 부모 컴포넌트에서 이 값을 주지 않으면 에러 메시지가 출력된다. 반대로 age 속성값은 필숫값이 아니기 때문에 이 값을 주지 않아도 에러는 발생하지 않는다. 만약 age 속성값으로 문자열을 줬다면 타입이 잘못됐다는 에러 메시지가 출력된다. type 속성값에는 gold, silver, bronze 중의 하나만 입력할 수 있다. 여기서 한 가지 부족한 타입 정보는 onChangeName과 같은 함수의 타입이다. prop-types에서 함수의 매개변수와 반환값에 대한 타입 정보는 정의할 수 없다. 이 경우에는 문서화를 위해 타입 정보를 주석으로 자세히 적기를 추천한다. 

##### prop-types로 정의할 수 있는 타입

다음 코드는 prop-types로 정의할 수 있는 여러 가지 타입을 보여 준다. 자세한 설명은 주석을 통해 확인할 수 있다. 

```jsx
MyComponent.propTypes = {
    // 리액트 요소
    // <div>hello</div> => 참
    // <SomeComponent /> => 참
    // 123 => 거짓
    menu: PropTypes.element,
    
    // 컴포넌트 함수가 반환할 수 있는 모든 것
    // number, string, array, element, ...
    // <SomeComponent /> => 참
    // 123 => 참
    description: PropTypes.node,
    
    // Message 클래스로 생성된 모든 객체
    // new Message() => 참
    // new Car() => 거짓
    message: PropTypes.instanceOf(Message),
    
    // 배열에 포함된 값 중에서 하나를 만족
    // 123 => 참
    // 'messy' => 참
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    
    // 특정 타입만 포함하는 배열
    // [1, 5, 7] => 참
    // ['a', 'b'] => 거짓
    ages: PropTypes.arrayOf(PropTypes.number),
    
    // 객체의 속성값 타입을 정의
    // {color: 'red', weight: 123} => 참
    // {color: 'red', weight: '123kg'} => 거짓
    info: PropTypes.shape({
        color: PropTypes.string,
        weight: PropTypes.number
    }),
    
    // 객체에서 모든 속성값의 타입이 같은 경우
    // {prop1: 123, prop2: 456} => 참
    // {prop1: 'red', prop2: 123} => 거짓
    infos: PropTypes.objectOf(PropTypes.number)
};
```

이처럼 prop-types가 제공하는 타입 정의 함수를 이용하면 웬만한 타입 정보는 표현할 수 있다. 그리고 다음과 같이 본인만의 타입 함수를 작성할 수도 있다. 

```jsx
MyComponent.propTypes = {
    age: function(props, propName, componentName) {
        const value = props[propName];
        if (value < 10 || value > 20) {
            return new Error(
            	`Invalid prop ${propName} supplied to ${componentName}.
                It must be 10 <= value <= 20.`
            );
        }
    }
};
```

age 속성값의 타입은 10 이상이고 20 이하인 숫자로 정의됐다. 조건에 맞지 않는 값이 들어오면 에러를 반환한다. 

#### 가독성을 높이는 조건부 렌더링 방법

컴포넌트 함수 내부에서 특정 값에 따라 선택적으로 렌더링하는 것을 조건부 렌더링(conditional rendering)이라 한다. 조건부 렌더링을 구현할 때는 삼항 연산자가 유용한 경우도 있지만 대부분 && 연산자가 가독성이 더 좋다. 예제를 통해 몇 가지 조건부 렌더링 방법을 알아보고, && 연산자를 이용한 방법과 비교해 보자. 

개발하다 보면 다음과 같은 조건부 렌더링을 자주 사용하게 된다. 

```jsx
function GreetingA({ isLogin, name }) { 
	if (isLogin) {
        return <p>{`${name}님 안녕하세요.`}</p>;
    } else {
        return <p>권한이 없습니다.</p>;
    }
}

function GreetingB({ isLogin, name }) {
    return <p>{isLogin ? `${name}님 안녕하세요.` : '권한이 없습니다.'}</p>;
}
```

GreetingB 컴포넌트가 좀 더 짧기도 하고 p 태그가 한 번만 등장해서 GreetingA보다 좋은 선택인 것 같다. 하지만 매번 그런 것은 아니다. 다음 코드처럼 좀 더 복잡한 조건부 렌더링의 경우를 보자. 

```jsx
function GreetingA({ isLogin, name }) {
    if (isLogin) {
        return (
        	<p className="greeting" onClick={showMenu}>
            	{`${name}님 안녕하세요.`}
            </p>
        );
    } else {
        return (
        	<p className="noAuth" onClick={goToLoginPage}>
            	권한이 없습니다.
            </p>
        );
    }
}

function GreetingB({ isLogin, name }) {
    return (
    	<p className={isLogin ? 'greeting' : 'noAuth'} 
            onClick={isLogin ? showMenu : goToLoginPage}>
            {isLogin ? `${name}님 안녕하세요.` : '권한이 없습니다.'}
        </p>
    );
}
```

위의 코드에서 어느 방법이 더 좋을지 토론을 하면 갑론을박이 벌어져 쉽게 결론이 나지 않는다. 확실한 답이 없기 때문이다. 그렇다고 어느 쪽을 쓰든 상관없다고 결론지으려는 건 아니다. 때에 따라 상대적으로 더 좋은 코드가 있다. 

조건부 렌더링을 무분별하게 사용하면 JSX 코드는 금방 스파게티가 되므로, 더 좋은 코드에 대한 고민을 끊임없이 해야 한다. 특히 JSX 코드에서는 삼항 연산자보다 && 연산자를 사용한 조건부 렌더링 코드가 가독성이 더 높다. 

다음은 로그인했을 때만 개인 정보를 보여주는 코드를 삼항 연산자를 사용해서 구현한 것이다.

```jsx
function Greeting({ isLogin, name, cash }) {
    return (
    	<div>
        	저희 사이트에 방문해 주셔서 감사합니다.
            {isLogin ? (
            	<div>
                	<p>{name}님 안녕하세요.</p>
                    <p>현재 보유하신 금액은 {cash}원입니다.</p>
                </div>
            ) : null}
        </div>
    );
}
```

##### && 연산자를 이용한 조건부 렌더링

특정 조건에서만 렌더링할 때는 위의 코드처럼 삼항 연산자를 사용하는 것보다는 && 연산자를 사용하는 게 낫다.

> **&&, || 연산자 이해하기**
>
> &&와 || 연산이 헷갈리다면 이 시점에서 확실히 이해해 보자.
>
> ```jsx
> const v1 = 'ab' && 0 && 2; // v1 === 0
> const v2 = 'ab' && 2 && 3; // v2 === 3
> const v3 = 'ab' || 0; // v3 === 'ab'
> const v4 = '' || 0 || 3; // v4 === 3
> ```
>
> &&, || 연산자 모두 마지막으로 검사한 값을 반환한다. 따라서 && 연산자는 첫 거짓(false)값 또는 마지막 값을 반환하고, || 연산자는 첫 참(true)값 또는 마지막 값을 반환한다. 따라서 렌더링할 리액트 요소를 && 연산자의 끝에 작성하고, 앞쪽에는 해당 조건을 작성하는 방식으로 조건부 렌더링을 구현할 수 있다. 

다음은 && 연산자를 사용해서 조건부 렌더링을 구현한 코드다. 

```jsx
function Greeting({ isLogin, name, cash }) {
    return (
    	<div>
      		저희 사이트에 방문해 주셔서 감사합니다.
            {isLogin && (
            	<div>
                	<p>{name}님 안녕하세요.</p>
                    <p>현재 보유하신 금액은 {cash}원입니다.</p>
                </div>
            )}
        </div>
    );
}
```

코드의 끝에 null을 생략해도 되기 때문에 가독성이 좋아진다. 아직까지는 코드가 간단해서 크게 와닿지 않을 수도 있다. 예를 들어 기획서가 업데이트됐는데, 이벤트 기간에는 개인 정보를 생략한 채 이벤트 문구를 보여 줘야 하고, 로그인을 했더라도 캐시가 십만 원을 넘으면 해킹한 사람이므로 개인 정보를 보여 주면 안 된다는 전제가 있다고 하자. 이에 삼항 연산자를 좋아하는 개발자는 다음과 같이 작성했다.

```jsx
function Greeting({ isEvent, isLogin, name, cash }) {
    return (
    	<div>
        	저희 사이트에 방문해 주셔서 감사합니다.
            {isEvent ? (
            	<div>
                	<p>오늘의 이벤트를 놓치지 마세요.</p>
                    <button onClick={onClickEvent}>이벤트 참여하기</button>
                </div>
            ) : isLogin ? (
            	cash <= 100000 ? (
                	<div>
                    	<p>{name}님 안녕하세요.</p>
                        <p>현재 보유하신 금액은 {cash}원입니다.</p>
                    </div>
                ) : null
            ) : null}
        </div>
    );
}
```

삼항 연산자를 중첩해서 사용했다. 첫 번째 삼항 연산자는 어디에서 끝나는지 파악하기도 힘들다. 이 코드를 && 연산자를 사용한 버전으로 변경하면 다음과 같다.

```jsx
function Greeting({ isEvent, isLogin, name, cash }) {
    return (
    	<div>
        	저희 사이트에 방문해 주셔서 감사합니다.
            {isEvent && (
            	<div>
                	<p>오늘의 이벤트를 놓치지 마세요.</p>
                    <button onClick={onClickEvent}>이벤트 참여하기</button>
                </div>
            )}
            {!isEvent && 
            	isLogin &&
                cash <= 100000 && (
            	<div>
                	<p>{name}님 안녕하세요.</p>
                    <p>현재 보유하신 금액은 {cash}원입니다.</p>
                </div>	
            )}
        </div>
    );
}
```

코드가 두 그룹이라는 게 금방 드러난다. 각 그룹의 조건도 한눈에 들어온다. 

> **&& 연산자 사용 시 주의할 점**
>
> && 연산자를 사용할 때 주의해야 할 점이 몇 가지 있다. 변수가 숫자 타입인 경우 0은 거짓이고, 문자열 타입인 경우 빈 문자열도 거짓이다. 당연하게 보이지만 && 연산자를 사용할 때 자주 실수하는 내용이다.
>
> 다음 코드는 && 연산자를 잘못 사용한 예를 보여 준다.
>
> ```jsx
> <div>
> 	{cash && <p>{cash}원 보유 중</p>}
>     {memo && <p>{200 - memo.length}자 입력 가능</p>}
> </div>
> ```
>
> 캐시가 0원일 때도 **0원 보유 중**을 출력해야 하는데 출력되지 않는다. 사실 더 큰 문제는 의도치 않게 숫자 0이 덩그러니 출력된다는 점이다. 만약 의도적으로 0도 거짓으로 처리하고 싶다면 !!cash &&를 입력하는 게 좋다. 마찬가지로 빈 문자열일 때는 **200자 입력 가능**이 출력되어야 하는데 출력되지 않는다. 이 경우에는 명확하게 undefined, null이 아닌 경우라고 표현해야 한다. 
>
> 위의 코드를 다음과 같이 수정하면 의도한 대로 동작한다.
>
> ```jsx
> <div>
> 	{cash != null && <p>{cash}원 보유 중</p>}
>     {memo != null && <p>{200 - memo.length}자 입력 가능</p>}
> </div>
> ```
>
> cash != null은 cash가 undefined가 아니고 null도 아니면 참이 된다.

변수가 배열인 경우에는 기본값으로 빈 배열을 넣어 주는 게 좋다. 다음 코드에서 students 배열의 기본값이 빈 배열이었다면 조건부 렌더링을 할 때마다 student &&를 입력하지 않아도 되기 때문에 편하게 map 함수를 사용할 수 있다.

```jsx
<div>{students && students.map(/* */)}</div>
<div>{products.map(/* */)}</div>
```

변수가 undefined 또는 null을 가질 수 있다면, 컴포넌트 함수에서 변수를 사용할 때마다 students && 코드를 작성해야 한다. 배열의 기본값을 빈 배열로 설정하면 코드가 간결해진다. 

조건에 따라 아무것도 렌더링하지 않은 경우에는 null을 반환하기도 한다. 또는 해당 컴포넌트를 사용하는 부모 컴포넌트에서 조건에 따라 자식 컴포넌트를 보이거나 가릴 수도 있다. 후자의 경우는 해당 컴포넌트가 마운트와 언마운트를 반복할 수 있다는 점을 인지해야 한다. 마운트와 언마운트를 반복하면 컴포넌트의 상탯값도 사라지고 렌더링 성능에도 안 좋은 영향을 끼칠 수 있다. 하지만 필요한 조건을 부모 컴포넌트에서 작성하기 때문에 자식 컴포넌트 입장에서는 로직이 더 간단해지는 장점도 있다.

조건부 렌더링의 방법은 다양하기 때문에 각자의 취향과 프로젝트의 성격에 따라 코딩 컨벤션을 정하는 게 좋다. 특히 코드 리뷰를 할 때 조건부 렌더링 쪽 코드가 복잡해서 힘들어지는 경우가 많다. 조건부 렌더링 코드를 수정할 때는 리뷰어(reviewer)를 배려하는 마음으로 코드를 작성하자. 

#### 관심사 분리를 위한 프레젠테이션, 컨테이너 컴포넌트 구분하기

댄 아브라모프(Dan Abramov)의 블로그 포스트로 잘 알려진 컴포넌트 구분법이 있다. 블로그 포스트에서 설명하는 구분법은 너무 복잡하고 헷갈리므로 보다 더 간단한 규칙을 제안한다. 비즈니스 로직과 상탯값의 유무에 따라 프레젠테이션(presentation)과 컨테이너(container)로 불리는 두 가지 컴포넌트로 구분하는 방법을 알아보자.

프로그래밍 세계에서 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 말한다. UI 처리, API 호출, DB 관리 등의 코드가 같은 곳에 있으면 복잡하기 때문에 이들은 서로 관심사가 다르다고 보고 분리해서 관리하는 게 좋다. 코드를 작성하다가 어느 순간 코드가 복잡해진다고 느껴진다면 관심사의 분리가 필요한 순간인지 생각해 보는 게 좋다. 

하나의 컴포넌트 안에서 모든 기능을 구현할 수는 없기 때문에 우리는 여러 개의 컴포넌트를 만들어서 조립한다. 하나의 폴더 안에 모든 컴포넌트를 모아 놓고 작업한다고 가정해 보자. 시간이 흐를수록 컴포넌트가 많아지고, 사용하려는 컴포넌트를 찾기가 어려워진다. 이때 기능별로 폴더를 만들어 관리하면 컴포넌트를 찾기가 쉬워지고 간단한 프로그램은 이 정도로도 충분해 보인다.

그러나 프로젝트의 규모가 커지면 문제가 생긴다. 비즈니스 로직과 상탯값이 컴포넌트의 여기저기에 흩어져 있다. 상탯값의 중복도 발생한다. 다음과 같이 부모 컴포넌트가 넘겨준 속성값으로부터 새로운 상탯값을 만드는 경우가 빈번해진다. 

```jsx
function MyComponent({ todos }) {
    const [doneList, setDoneList] = useState(todos.filter(item => item.done));
    function onChangeName(key, name) {
        setDoneList(
        	doneList.map(item => (item.key === key ? { ...item, name } : item))
        );
    }
    // ...
}
```

부모로부터 받은 todo로부터 완료 목록 doList를 만들었다. 그러고는 이벤트 처리 함수에서 특정 목록의 이름을 수정하고 있다. 

여기서 주목할 부분은 특정 목록의 이름을 수정하는 순간, 부모가 가진 데이터와 정합(sync)이 안 맞다는 것이다. 대개 이런 상황은 버그로 이어진다. 이렇게 자식 컴포넌트에서 부모의 데이터를 별도의 상탯값으로 관리하는 것은 나쁜 습관(anti-pattern)이라고 할 수 있다. 비즈니스 로직과 상탯값은 일부 컴포넌트로 한정해서 관리하는 게 좋다.

컴포넌트가 비즈니스 로직이나 상탯값을 가지고 있으면 재사용하기 힘들다. 컴포넌트를 재사용하면 할수록 이득인데 말이다. 컴포넌트에 비즈니스 로직이나 상탯값이 있어서 재사용을 못 하고 새로운 컴포넌트를 만들면 코드 중복이 발생할 수 있다. 개발자에게 있어서 코드 중복은 게으름이며 기술 부채다. 

그렇다면 비즈니스 로직과 상탯값의 유무로 컴포넌트를 분리하면 어떨까? 앞에서 언급한 댄 아브라모프의 블로그 글에서는 재사용성이 좋은 프레젠테이션 컴포넌트와 그렇지 않은 컨테이너 컴포넌트로 구분하는 방법을 설명한다. 하지만 글을 읽어 보면 머리가 더 복잡해질 수 있다. 그 글에서 설명하는 프레젠테이션 컴포넌트의 조건이 다소 복잡하기 때문이다. 추천하는 프레젠테이션 컴포넌트의 정의는 다음과 같다. 

+ 비즈니스 로직이 없다.
+ 상탯값이 없다. 단, 마우스 오버(mouse over)와 같은 UI 효과를 위한 상탯값은 제외한다. 

이처럼 컴포넌트를 프레젠테이션과 컨테이너로 구분하고 폴더도 이에 따라 별도로 관리하는 게 좋다. 일반적으로 프레젠테이션 컴포넌트 코드가 가독성이 더 좋고 재사용성도 높다. 

### useEffect 훅 실전 활용법

useEffect 훅 사용 시 의존성 배열을 관리하는 방법을 알아본다. 의존성 배열을 잘 관리하지 못해서 발생한 버그는 디버깅이 쉽지 않으므로 제대로 이해하고 사용해야 한다. 

#### 의존성 배열을 관리하는 방법

의존성 배열은 useEffect 훅에 입력하는 두 번째 매개변수다. 의존성 배열의 내용이 변경됐을 때 부수 효과 함수가 실행된다.

의존성 배열은 잘못 관리하면 쉽게 버그로 이어지므로 가능하면 입력하지 않는 게 좋다. 다행히 의존성 배열은 대부분의 경우에 입력하지 않아도 되는데, 꼭 필요한 경우가 생기기도 한다. 몇 가지 예제를 통해 의존성 배열을 관리하는 방법을 알아보자.

##### 부수 효과 함수에서 API를 호출하는 경우

부수 효과 함수에서 API를 호출한다면 불필요한 API 호출이 발생하지 않도록 주의해야 한다. 다음은 사용자 정보를 가져오기 위해 useEffect 훅을 이용하는 코드다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    useEffect(() => {
    	fetchUser(userId).then(data => setUser(data));   
    });
    // ...
}
```

fetchUser 함수는 렌더링을 할 때마다 호출되므로 비효율적이다.

이 문제를 해결하기 위해 의존성 배열에 빈 배열을 넣을 수 있도록 한다. 하지만 이는 userId가 변경돼도 새로운 사용자 정보를 가져오지 못하기 때문에 올바른 해결책이 아니다. 지금 이 순간에는 userId가 변경되지 않는다는 것을 확신한다고 하더라도 언제 기획서가 변경될지 모르는 일이다.

다음은 이 문제를 의존성 배열을 이용해서 해결하는 코드다.

```jsx
useEffect(() => {
	fetchUser(userId).then(data => setUser(data));    
}, [userId]);
```

userId가 변경될 때만 fetchUser 함수를 호출한다.

나중에 부수 효과 함수를 수정할 때는 새로 추가된 변수를 빠짐없이 의존성 배열에 추가해야 한다. 다음과 같이 fetchUser 함수에 매개변수를 추가한다고 생각해 보자.

```jsx
const [needDetail, setNeedDetail] = useState(false);
useEffect(() => {
    fetchUser(userId, needDetail).then(data => setUser(data));
}, [userId]);
```

상탯값 neddDetail을 부수 효과 함수에서 사용했다. 부수 효과 함수를 수정할 때 새로운 상탯값을 사용했다면 의존성 배열에 추가해야 한다. 하지만 사람이 하는 일이다 보니 이렇게 깜빡하고 needDetail을 의존성 배열에 추가하지 않는 일이 종종 생긴다. 

리액트 팀에서는 이러한 문제를 해결하기 위해 eslint에서 사용할 수 있는 exhaustive-deps 규칙을 만들어서 제공한다. exhaustive-deps는 잘못 사용된 의존성 배열을 찾아서 알려 준다. 의존성 배열에서 실수를 하는 경우가 많고, 의존성 배열 때문에 발생한 버그는 원인 파악도 힘들기 때문에 exhaustive-deps를 꼭 사용할 것을 추천한다.

> **의존성 배열을 잘못 관리하면 생기는 일**
>
> 의존성 배열에서 입력해야 할 값을 입력하지 않으면 오래된 값을 참조하는 문제가 발생한다. 다음 코드에서 **value1 증가** 버튼을 누르면 증가된 valu1 값이 콘솔에 출력된다. 하지만 **value2 증가*** 버튼을 누르면 오래된 value2 값이 콘솔에 출력된다. 
>
> ```jsx
> function MyComponent() {
>     const [value1, setValue1] = useState(0);
>     const [value2, setValue2] = useState(0);
>     useEffect(() => {
>         const id = setInterval(() => console.log(value1, value2), 1000);
>         return () => clearInterval(id);
>     }, [value1]);
>     return (
>     	<div>
>         	<button onClick={() => setValue(value1 + 1)}>value1 증가</button>
>         	<button onClick={() => setValue(value2 + 1)}>value2 증가</button>
>         </div>
>     );
> }
> ```
>
> value2를 의존성 배열에 넣지 않았다. 따라서 value2가 변경돼도 부수 효과 함수는 갱신되지 않으며 value2가 변경되기 전에 등록된 부수 효과 함수가 계속 사용된다. 
>
> 컴포넌트 함수가 실행될 때마다 부수 효과 함수가 생성되고, 함수는 생성될 당시의 변수를 참조한다. 같은 value2 변수라고 하더라도 컴포넌트 함수가 생성될 때마다 새로운 메모리 공간을 가진다. 즉, 부수 효과 함수는 함수가 생성된 시점의 value2를 참조하므로 예전에 생성된 부수 효과 함수는 예전 value2를 참조하는 것이다.

##### useEffect 훅에서 async await 함수 사용하기

useEffect 훅에서 async await 함수를 사용하기 위해 부수 효과 함수를 async await 함수로 만들면 에러가 난다. 부수 효과 함수의 반환값은 항상 함수 타입이어야 하기 때문이다.

다음은 부수 효과 함수를 async await 함수로 만든 것이다.

```jsx
useEffect(async () => {
    const data = await fetchUser(userId);
    setUser(data);
}, [userId]);
```

async await 함수는 프로미스 객체를 반환하므로 부수 효과 함수가 될 수 없다. 부수 효과 함수는 함수만 반환할 수 있으며, 반환된 함수는 부수 효과 함수가 호출되기 직전과 컴포넌트가 사라지기 직전에 호출된다.

useEffect 훅에서 async await 함수를 사용하는 한 가지 방법은 부수 효과 함수 내에서 async await 함수를 만들어서 호출하는 것이다.

```jsx
useEffect(() => {
    async function fetchAndSetUser() {
        const data = await fetchUser(userId);
        setUser(data);
    }
    fetchAndSetUser();
}, [userId]);
```

부수 효과 함수 내에서 async await 함수를 만들고, 그 함수를 바로 호출한다.

##### fetchAndSetUSer 함수 재사용하기

다음과 같이 fetchAndSetUser 함수를 다른 곳에서도 사용해야 한다면 코드를 어떻게 변경해야 할지 고민해 보자.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    useEffect(() => {
        async function fetchAndSetUser(needDetail) {
            const data = await fetchUser(userId, needDetail);
            setUser(data);
        }
        fetchAndSetUser(false);
    }, [userId]);
    if (!user) {
    return <h1>로딩...</h1>;
    }
    return (
        <div>
            <h1>{user.name}</h1>
            <p>{`캐시: ${user.cash}`}</p>
            <p>{`계정 생성일: ${user.createdAt}`}</p>
            <button onClick={() => fetchAndSetUser(true)}>더보기</button>
            <UserDetail user={user} />
        </div>
    );
}
```

더보기 버튼을 누르면 사용자 상세 정보를 보여 주는 기능을 추가하려고 한다. fetchUser 함수에서 상세 정보가 필요한지 여부를 알려 주는 needDetail 매개변수를 추가한다. 

useEffect 훅 안에 있는 fetchAndSetUser 함수를 훅 밖으로 빼야 하는 상황이다. 간단하게는 다음과 같이 해 볼 수 있다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    async function fetchAndSetUser(needDetail) {
        const data = await fetchUser(userId, needDetail);
        setUser(data);
    }
    useEffect(() => {
        fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    // ...
}
```

훅 내부에서 fetchAndSetUser 함수를 사용하므로 해당 함수를 의존성 배열에 넣는다. fetchAndSetUser 함수는 렌더링을 할 때마다 갱신되므로 결과적으로 fetchAndSetUser 함수는 렌더링을 할 때마다 호출된다.

이 문제를 해결하려면 fetchAndSetUser 함수가 필요할 때만 갱신되도록 만들어야 한다. 다음 코드는 useCallback 훅을 이용해서 userId가 변경될 때만 fetchAndSetUser 함수가 갱신된다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    const fetchAndSetUser = useCallback(
    	async needDetail => {
          const data = await fetchUser(userId, needDetail);
          setUser(data);
        },
        [userId];
    );
    useEffect(() => {
        fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    // ...
}
```

useCallback 훅을 이용해서 fetchAndSetUSer 함수가 필요할 때만 갱신되도록 개선했다. 이제 fetchAndSetUser 함수는 userId가 변경될 때만 호출된다.

#### 의존성 배열을 없애는 방법

앞에서도 언급했지만 가능하다면 의존성 배열을 사용하지 않는 게 좋다. 의존성 배열을 관리하는데 생각보다 많은 시간과 노력이 들어가기 때문이다. 특히 속성값으로 전달되는 함수를 의존성 배열에 넣는 순간, 그 함수는 useCallback 등을 사용해서 자주 변경되지 않도록 신경 써서 관리해야 한다. 

##### 부수 효과 함수 내에서 분기 처리하기

의존성 배열을 입력하지 않는 대신 부수 효과 함수 내에서 실행 시점을 조절할 수 있다. 다음은 의존성 배열을 사용하지 않고 if 문으로 fetchUser 호출 시점을 관리하는 코드다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    async function fetchAndSetUser(needDetail) {
        const data = await fetchUser(userId, needDetail);
     	setUser(data);   
    }
    useEffect(() => {
       if (!user || user.id !== userId) {
           fetchAndSetUser(false);
       } 
    });
    // ...
}
```

if 문으로 fetchAndSetUser 호출 시점을 관리한다. 이렇게 의존성 배열을 입력하지 않으면 부수 효과 함수에서 사용된 모든 변수는 가장 최신화된 값을 참조하므로 안심할 수 있다. 이제 fetchAndSetUser 함수는 useCallback 훅을 사용하지 않아도 된다. 

##### useState의 상탯값 변경 함수에 함수 입력하기

이전 상탯값을 기반으로 다음 상탯값을 계산하기 위해 상탯값을 의존성 배열에 추가하는 경우가 있다. 이런 경우 상탯값 변경 함수에 함수를 입력하면 상탯값을 의존성 배열에서 제거할 수 있다. 다음은 화면을 클릭할 때마다 상탯값 count를 1씩 증가시키는 코드다. 

```jsx
function MyComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
        function onClick() {
            setCount(count + 1);
        }
        window.addEventListner("click", onClick);
        return () => window.removeEventListner("click", onClick);
    }, [count]);
    // ...
}
```

이전 상탯값을 기반으로 다음 상탯값을 계산한다. 이전 상탯값을 사용하기 위해 상탯값을 의존성 배열에 추가한다.

상탯값 변경 함수에 함수를 입력하면 이전 상탯값을 매개변수로 받을 수 있다. 다음은 상탯값 변경 함수에 함수를 입력해서 의존성 배열을 제거하는 코드다.

```jsx
function MyComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
       	function onClick() {
       	    setCount(prev => prev + 1);
       	} 
       	window.addEventListner("click", onClick);
        return () => window.removeEventListner("click", onClick);
    });
    // ...
}
```

이전 상탯값을 매개변수로 받는다. 이제 상탯값을 의존성 배열에서 제거할 수 있다. 

##### useReducer 활용하기

여러 상탯값을 참조하면서 값을 변경할 때는 useReducer 훅을 사용하는 게 좋다. 예를 들어 타이머에서는 시간이 흐를 때 시, 분, 초라는 세 가지 상탯값을 참조하면서 값을 변경한다. 이렇게 여러 상탯값을 참조해야 하는 경우에 useReducer 훅을 사용하면 의존성 배열을 쉽게 제거할 수 있다. 

다음은 타이머 컴포넌트에서 여러 상탯값을 참조하면서 값을 변경하는 코드다.

```jsx
function Timer({ initialTotalSeconds }) {
    const [hour, setHour] = useState(Math.floor(initialTotalSeconds / 3600));
    const [minute, setMinute] = useState(Math.floor((initialTotalSeconds % 3600) / 60));
    const [second, setSecond] = useState(initialTotalSeconds % 60);
    useEffect(() => {
        const id = setInterval(() => {
            if (second) {
                setSecond(second - 1);
            } else if (minute) {
                setMinute(minute - 1);
                setSecond(59);
            } else if (hour) {
                setHour(hour - 1);
                setMinute(59);
                setSecond(59);
            }
        }, 1000);
        return () => clearInterval(id);
    }, [hour, minute, second]);
    // ...
}
```

세 가지 상탯값을 사용한다. 1초마다 타이머의 시간을 차감한다. 세 가지 상탯값 모두 의존성 배열에 추가한다. setInterval을 사용한 것이 무색하게도 1초마다 clearInterval, setInterval을 반복해서 호출한다.

다음과 같이 useReducer 훅을 사용하면 setIntervla을 한 번만 호출하도록 개선할 수 있다. 

```jsx
function Timer({ initialTotalSeconds }) { 
	const [state, dispatch] = useReducer(reducer, {
        hour: Math.floor(initialTotalSeconds / 3600),
        minute: Math.floor((initialTotalSeconds % 3600) / 60),
        second: initialTotalSeconds % 60
    });
    const { hour, minute, second } = state;
    useEffect(() => {
        const id = setInterval(dispatch, 1000);
        return () => clearInterval(id);
    });
    // ...
}

function reducer(state) {
    const { hour, minute, second } = state;
    if (second) {
        return { ...state, second: second - 1 };
    } else if (minute) {
        return { ...state, minute: minute - 1, second: 59 }; 
    } else if (hour) {
        return { hour: hour - 1, minute: 59, second: 59 };
    } else {
        return state;
    }
}
```

세 가지 상탯값을 모두 useReducer 훅으로 관리한다. useReducer 훅의 두 번째 매개변수는 초기 상탯값이다. dispatch는 변하지 않는 값이므로 의존성 배열을 제거할 수 있다. 상탯값을 변경하는 로직은 reducer 함수에서 구현한다. 

물론 시, 분, 초를 하나의 객체에 담아서 useState 훅으로 관리할 수도 있다. 이렇게 useState 훅을 사용해도 의존성 배열을 제거할 수 있다. 다만 useReducer를 사용하면 다양한 액션과 상탯값을 관리하기 용이하고, 상탯값 변경 로직을 여러 곳에서 재사용하기에도 좋다. 

##### useRef 활용하기

의존성 배열이 자주 변경되는 문제를 해결하는 방법은 여러 가지가 있지만, 상황에 따라 마땅한 방법이 보이지 않을 수 있다. 특히 속성값으로 전달되는 함수는 자주 변경되는 경우가 많다. 해당 속성값이 렌더링 결과에 영향을 주는 값이 아니라면 useRef 훅을 이용해서 의존성 배열을 제거할 수 있다. 

다음은 속성값으로 받은 함수를 useEffect 훅 안에서 사용하는 코드다.

```jsx
function MyComponent({ onClick }) {
    useEffect(() => {
        window.addEventListner("click", () => {
            onClick();
            // ...
        });
        // 연산량이 많은 코드
    }, [onClick]);
    // ...
}
```

속성값으로 전달된 함수는 함수 내용은 그대로인데 렌더링할 때마다 변경되는 경우가 많다. 이로 인해 부수 효과 함수가 불필요하게 자주 호출된다.

이를 해결하는 마땅한 방법이 떠오르지 않는다면 useRef 훅이 손쉬운 해결책이 될 수 있다. 다음은 useRef 훅을 사용해서 부수 효과 함수가 자주 호출되지 않도록 개선한 코드다.

```jsx
function MyComponent({ onClick }) {
    const onClickRef = useRef();
    useEffect(() => {
       onClickRef.current = onClick; 
    });
    useEffect(() => {
        window.addEventListner("click", () => {
            onClickRef.current();
            // ...
        });
        // ...
    });
    // ...
}
```

onClick을 useRef에 저장한다. useRef에는 렌더링 결과와 무관한 값만 저장하자. 이는 useRef에 저장된 값이 변경돼도 컴포넌트가 다시 렌더링되지 않기 때문이다. 부수 효과 함수에서 사용된 useRef 값은 의존성 배열에 추가할 필요가 없다.

> **useRef 값을 부수 효과 함수에서 변경하는 이유**
>
> 다음과 같이 useRef 값은 컴포넌트 함수에서 직접 변경해도 된다고 생각할 수 있지만 한 가지 문제가 있다.
>
> ```jsx
> function MyComponent({ onClick }) {
>     const onClickRef = useRef();
>     onClickRef.current = onClick;
>     // ...
> }
> ```
>
> 부수 효과 함수에서 값을 수정하는 것보다 빠른 시점에 수정한다. useEffect 코드를 작성하는 것보다 간편하다.
>
> 부수 효과 함수에서 useRef 값을 수정하는 이유는 나중에 도입될 리액트의 concurrent 모드 때문이다. concurrent 모드로 동작할 때는 컴포넌트 함수가 실행됐다고 하더라도 중간에 렌더링이 취소될 수 있다. 렌더링은 취소됐는데 useRef에는 잘못된 값이 저장될 수 있으므로 useRef 값은 컴포넌트 함수에서 직접 수정하면 안 된다. 단, concurrent 모드로 동작하지 않는 리액트 버전에서는 문제가 되지 않는다. 

### 렌더링 속도를 올리기 위한 성능 최적화 방법

리액트가 실행될 때 가장 많은 CPU 리소스를 사용하는 것은 렌더링이다. 리액트는 UI 라이브러리이기 때문에 프로그램이 실행되는 동안에 화면을 그리고 또 그린다. 리액트는 데이터와 컴포넌트 함수로 화면을 그린다. 그 과정에서 대부분의 연산은 컴포넌트 함수의 실행과 가상 돔에서 발생한다. 여기서 데이터는 컴포넌트의 속성값과 상탯값을 말한다. 속성값이나 상탯값이 변경되면 리액트가 자동으로 컴포넌트 함수를 이용해서 화면을 다시 그린다. 정말 단순하지만 중요한 리액트의 역할이다.

리액트에서 최초 렌더링 이후에는 데이터 변경 시 렌더링을 하는데, 이때 다음과 같은 단계를 거친다.

1. 이전 렌더링 결과를 재사용할지 판단한다.
2. 컴포넌트 함수를 호출한다.
3. 가상 돔끼리 비교해서 변경된 부분마 실제 돔에 반영한다.

첫 번째 단계에서는 속성값이나 상탯값의 이전 이후 값을 비교하고, 이후 단계를 생략할 수 있다. 클래스형 컴포넌트에서는 shouldComponentUpdate 메서드가 그런 역할을 하고, 함수형 컴포넌트에서는 React.memo를 이용해서 구현할 수 있다.

첫 번째 단계에서 렌더링이 필요하다고 판단하면 컴포넌트 함수를 호출한다. 컴포넌트 함수를 호출해서 새로운 가상 돔을 만들고 이전에 만들었던 가상 돔과 비교해서 변경점을 찾는다. 그리고 변경된 부분을 실제 돔에 반영한다. 

렌더링 속도를 개선하기 위해 각 단계에서 우리가 할 수 있는 일은 무엇인지 하나씩 알아보자. 

성능 최적화 방법을 설명하기 전에 당부하고 싶은 말이 있다. 평상시에는 성능 최적화를 고민하지 말고 편하게 코딩하기를 바란다. 대부분의 웹 페이지는 성능을 고민하지 않아도 문제없이 잘 돌아간다. 성능 이슈가 생기면 그때 고민해도 늦지 않다.

#### React.memo로 렌더링 결과 재사용하기

컴포넌트의 속성갑싱나 상탯값이 변경되면 리액트는 그 컴포넌트를 다시 그릴 준비를 한다. 만약 React.memo 함수로 감싼 컴포넌트라면 속성값 비교 함수가 호출된다. 이 함수는 이전 이후 속성값을 매개변수로 받아서 참 또는 거짓을 반환한다. 참을 반환하면 렌더링을 멈추고, 거짓을 반환하면 컴포넌트 함수를 실행해서 가상 돔을 업데이트한 후 변경된 부분만 실제 돔에 반영한다. 

컴포넌트를 React.memo 함수로 감싸지 않았다면 항상 거짓을 반환하는 속성값 비교 함수가 사용된다고 생각할 수 있다. 이때는 속성값이 변경되지 않아도 부모 컴포넌트가 렌더링될 때마다 자식 컴포넌트도 렌더링된다.

속성값 비교 함수가 항상 거짓을 반환해도 속성값이 변경되지 않으면 실제 돔도 변경되지 않기 때문에 대부분 문제가 되지 않는다. 하지만 렌더링 성능이 중요한 상황에서는 컴포넌트를 React.memo 함수로 감싸서 컴포넌트 함수의 실행과 가상 돔의 계산을 생략할 수 있다. 다음은 React.memo 함수의 간단한 사용 예다.

```jsx
function MyComponent(props) {
    // ...
}
function isEqual(prevProps, nextProps) {
    // true 또는 false를 반환
}
React.memo(MyComponent, isEqual);
```

React.memo의 두 번째 매개변수로 속성값 비교 함수를 입력한다. 속성값 비교 함수에서 참을 반환하면 이후 단계를 생략하고 이전 렌더링 결과를 재사용한다. 만약 속성값 비교 함수를 입력하지 않으면 얕은(shallow) 비교를 수행하는 기본 함수가 된다. 

속성값 비교 함수에서 속성값의 변경 여부를 어떻게 알 수 있을지 알아보자. 다음은 특정 속성값의 변경 전과 변경 후의 데이터를 보여 준다.

```jsx
const prevProps = {
    todos: [
        { title: 'fix bug', priority: 'high' },
        { title: 'meeting with jone', priority: 'low'},
        // ...
    ],
    // ...
};
const nextProps = {
	todos: [
        { title: 'fix bug', priority: 'high' },
        { title: 'meeting with jone', priority: 'high' },
        // ...
    ],
    // ...
};
```

todo 배열에서 두 번째 객체의 priority 속성값이 변경됐다. 만약 todos를 수정 가능한 객체로 관리했다면 속성값이 변경됐는지 알 수 있는 방법은 단순 무식(brute force)하게 모두 비교하는 수밖에 없다. 반대로 불변 객체로 관리했다면 다음과 같이 한 번만 비교해도 충분하다.

```jsx
prevProps.todos !== nextProps.todos
```

속성값을 불변 객체로 관리했다면 이전 이후 값의 단순 비교만으로 컴포넌트의 속성값이 변경되었는지 알 수 있다. 따라서 속성값을 불변 객체로 관리하면 렌더링 선응에 큰 도움이 된다.

> **리액트에서 속성값의 변경 여부를 계산하는 알고리즘**
>
> React.memo 함수로 컴포넌트를 만들면 속성값이 변경된 경우에만 렌더링된다. React.memo 함수의 두 번째 매개변수인 속성값 비교 함수를 입력하지 않으면 리액트에서 기본으로 제공하는 함수가 사용된다. 이 함수가 어떻게 동작하는지 알아보자.
>
> 객체를 수정 불가능하게 관리하면 다음과 같이 최상위 객체의 참조값만 비교하면 값의 변경 유무를 알 수 있다. 
>
> + prevObj === nextObj
>
> 리액트는 속성값의 변경 여부를 판단하기 위해 속성값에 직접 연결된 모든 속성을 비교한다.
>
> + prevProps.prop1 === nextProps.prop1 &&
>
>   ​        prevProps.prop2 === nextProps.prop2 && ...
>
> 최상위 객체의 참조값만 비교하지 않고 이렇게 하는 이유는 JSX 문법이 createElement로 변환된 코드를 보면 이해할 수 있다.
>
> ```jsx
> function Parent() {
>     return <Child name="mike" age={23} />;
> }
> function Parent() {
>     return React.createElement(Child, { name: 'mike', age: 23 });
> }
> ```
>
> createElement로 변환된 코드를 보면 렌더링할 때마다 새로운 속성값 객체가 생성된다. 객체의 내부 속성값이 변경되지 않아도 최상위 객체의 참조값은 항상 변경된다. 따라서 리액트는 속성값이 최상위 객체에 직접 연결(1-depth)된 모든 값을 단순 비교한다. 이를 얕은 비교(shallow compare)라 부른다. 

#### 속성값과 상탯값을 불변 변수로 관리하는 방법

##### 함수의 값이 변하지 않도록 관리하기

컴포넌트 함수 내부에서 함수를 정의해서 자식 컴포넌트의 속성값으로 입력하면, 함수의 내용이 변경되지 않아도 자식 컴포넌트의 입장에서는 속성값이 변경됐다고 인식한다. 

다음은 컴포넌트 함수에서 렌더링을 할 때마다 새로운 함수를 만들어서 자식 컴포넌트의 속성값으로 전달하는 코드다.

```jsx
function Parent() {
    const [selectFruit, setSelectedFruit] = useState("apple");
    const [count, setCount] = useState(0);
    return (
    	<div>
        	<p>{`count: ${count}`}</p>
            <button onClick={() => setCount(count + 1)}>increase count</button>
            <SelectFruit selected={selectedFruit} onChange={fruit => setSelectedFruit(fruit)} />
        </div>
    );
}
```

버튼을 눌러서 count 상탯값을 변경하면 Parent 컴포넌트의 렌더링이 시작된다. 이때 SelectFruit 컴포넌트로 전달되는 속성값은 변경되지 않으므로 SelectFruit 컴포넌트에서 React.memo를 사용했다면 SelectFruit 컴포넌트 함수는 호출되지 않는다고 생각하기 쉽다. 하지만 count 변수가 변경될 때마다 SelectFruit 컴포넌트 함수도 호출된다. React.memo를 사용했고, SelectFruit 컴포넌트로 전달되는 SelectFruit 값도 변하지 않았는데 왜 컴포넌트 함수가 호출되는 걸까? 그건 바로 SelectFruit 컴포넌트로 전달되는 onChange 속성값이 변하기 때문이다. onChange 속성값은 부모 컴포넌트가 렌더링될 때마다 새로운 함수로 만들어지고 있다. 

useState, useReducer의 상탯값 변경 함수는 변하지 않는다는 점을 이용하면 이 문제를 쉽게 해결할 수 있다. 코드를 다음과 같이 변경하면 onChange 속성값에는 항상 같은 값이 입력된다.

```jsx
function Parent() {
    const [selectedFruit, setSelectedFruit] = useState("apple");
    // ...
    	<SelectFruit selected={selectedFruit} onChange={setSelectedFruit} />
    // ...
}
```

useState의 상탯값 변경 함수는 변하지 않으므로 onChange 속성값에는 항상 같은 값이 입력된다. 

이벤트 처리 함수에서 상탯값 변경 외에 다른 처리도 필요하다면 useCallback을 사용할 수 있다. 다음은 useCallback 훅을 이용해서 이벤트 처리 함수가 변하지 않도록 처리한 코드다.

```jsx
function Parent() {
    // ...
    const onChangeFruit = useCallback(fruit => {
        setSelectedFruit(fruit);
        sendLog({ type: "fruit change", value: fruit });
    }, []);
    // ...
    	<SelectFruit selected={selectedFruit} onChange={onChangeFruit} />
    // ...
}
```

useCallback 훅을 이용해서 이벤트 처리 함수를 구현한다. 의존성 배열로 빈 배열을 입력했으므로 이 함수는 항상 고정된 값을 가진다. onChange 이벤트에는 useCallback 훅이 반환한 함수를 속성값으로 입력한다. 

##### 객체의 값이 변하지 않도록 관리하기

함수와 마찬가지로 컴포넌트 내부에서 객체를 정의해서 자식 컴포넌트의 속성값으로 입력하면, 자식 컴포넌트는 객체의 내용이 변경되지 않았는데도 속성값이 변경됐다고 인식한다. 

다음은 컴포넌트 함수에서 렌더링을 할 때마다 새로운 객체를 만들어서 자식 컴포넌트의 속성값으로 전달하는 코드다.

```jsx
function SelectFruit({ selectedFruit, onChange }) {
    // ...
    return (
    	<div>
        	<Select options={[
                    { name: "apple", price: 500 },
                    { name: "banana", price: 1000 },
                    { name: "orange", price: 1500 },
                ]}
                selected={selectedFruit}
                onChange={onChange}
            />
            {/* ... */}
        </div>
    );
}
```

SelectFruit 컴포넌트가 렌더링될 때마다 options 속성값으로 새로운 객체가 입력된다. 

과일 목록은 렌더링과 무관하게 항상 같은 값을 가지므로 다음과 같이 컴포넌트 밖에서 상수 변수로 관리할 수 있다.

```jsx
function SelectFruit({ selectedFruit, onChange }) {
    // ...
    return (
    	<div>
        	<Select options={FRUIT} selected={selectedFruit} onChange={onChnage} />
            {/* ... */}
        </div>
    );
}

const FRUITS = [
  { name: "apple", price: 500 },  
  { name: "banana", price: 1000 },  
  { name: "orange", price: 1500 },  
];
```

과일 목록을 컴포넌트 밖에서 상수 변수로 관리한다. 이제 options 속성값은 컴포넌트 렌더링과 무관하게 항상 같은 값을 가진다. 

하지만 다른 상탯값이나 속성값을 이용해서 계산되는 값은 상수 변수로 관리할 수 없다. 다음은 과일의 가격 조건에 따라 과일 목록을 계산하는 코드다. 

```jsx
function SelectFruit({ selectedFruit, onChange }) {
    const [maxPrice, setMaxPrice] = useState(1000);
    // ...
    return (
    	<div>
        	<Select options={FRUIT.filter(item => item.price <= maxPRice)}
                selected={selectedFruit}
                onChange={onChange}
            />
            {/* ... */}
        </div>
    );
}
```

maxPrice 상탯값은 화면에 보여 줄 과일의 최대 가격을 의미한다. 상탯값 maxPrice를 이용해서 속성값 options를 계산한다.

useMemo 훅을 이용하면 필요한 경우에만 속성값 options의 값이 변하도록 만들 수 있다. 다음은 useMemo 훅을 이용한 코드다.

```jsx
function SelectFruit({ selectedFruit, onChange }) {
    // ...
    const fruits = useMemo(() => FRUITS.filter(item => item.price <= maxPrice)m [
    	maxPrice                       
    ]);
    return (
    	<div>
        	<Select options={fruits} selected={selectedFruit} onChange={onChange} />
            {/* ... */}
        </div>
    );
}
```

maxPrice 값이 같으면 fruits 값은 변하지 않는다. 이처럼 useMemo 훅은 꼭 필요할 때만 반환되는 값이 변경되도록 한다.

useMemo 훅의 또 다른 중요한 역할은 입력된 함수를 최소한으로 실행한다는 것이다. 만약 FRUITS 배열이 상당히 크다면 렌더링할 때마다 filter 연산을 수행하는 것은 부담스러울 수 있다. useMemo 훅은 maxPrice 값이 변하지 않으면 불필요한 filter 연산을 막아준다. 

그렇다고 무조건 useMemo, useCallback, React.memo 등을 사용하는 것은 좋지 않다. 성능을 최적화하는 코드는 가독성이 안 좋고 유지보수 비용을 증가시킨다. 성능 이슈가 발생했을 때 해당하는 부분의 코드만 최적화 하도록 하자.

> **상탯값을 불변 객체로 관리하기**
>
> 속성값이나 상탯값이 변경되면 반드시 객체도 새로 생성해야 한다. 다음은 상탯값을 변경하면서 객체를 새로 생성하지 않는 코드다. 
>
> ```jsx
> function SelectFruit({ selectedFruit, onChange }) {
>     const [fruits, setFruits] = useState(["apple", "banana", "orange"]);
>     const [newFruit, setNewFruit] = useState("");
>     function addNewFruit() {
>         fruits.push(newFruit);
>         setNewFruit("");
>     }
>     // ...
>     return (
>     	<div>
>         	<Select options={fruits} selected={selectedFruit} onChange={onChange} />
>             <input type="text" value={newFruit} onChange={e => setNewFruit(e.target.value)} />
>             <button onClick={addNewFruit}>추가하기</button>
>             {/* ... */}
>         </div>
>     );
> }
> ```
>
> 과일 목록을 상탯값을 관리한다. 사용자는 키보드를 입력해서 새로운 과일 이름을 setFruit에 저장한다. 새로운 과일을 과일 목록에 추가한다. fruit 상탯값의 내용은 변경되지만 fruits 변수가 가리키는 배열의 참조값은 변하지 않는다. newFruit 상탯값을 초기화하면서 SelectFruit 컴포넌트는 다시 렌더링된다. Select 컴포넌트 입장에서는 속성값이 변하지 않았다. 만약 Select 컴포넌트가 React.memo를 이용했다면 새로 추가된 과일은 반영되지 않는다. 
>
> 과일 목록에 새로운 과일을 추가할 때는 코드를 다음과 같이 작성해야 한다.
>
> ```jsx
> function addNewFruit() {
>     setFruits([...fruits, newFruit]);
>     setNewFruit("");
> }
> ```
>
> 