## 리액트 실전 활용법

useEffect 훅의 기능은 간단하지만 그것을 제대로 사용하려면 결코 쉽지 않다. 개발자들은 훅이 등장하기 전에 쓰이던 클래스형 컴포넌트에 익숙해져 있어 잘못된 방법으로 접근하는 경우가 많기 때문이다. useEffect 훅을 잘못 사용하면 오래된 데이터를 참조하거나 부수 효과가 자주 실행되는 문제가 발생할 수 있다.

이번에는 useEffect 훅을 제대로 사용하는 방법을 알아보자. 그리고 가독성과 생산성을 높이는 컴포넌트 작성 방법, 렌더링 속도를 올리기 위한 성능 최적화 방법도 알아보자. 

### 가독성과 생산성을 고려한 컴포넌트 코드 작성법

컴포넌트 코드를 작성할 때 가독성과 생산성을 높여 주는 방법을 알아보자. 같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있다. 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 사람 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드를 작성하는 게 좋다. 먼저 추천하는 컴포넌트 파일 작성법을 소개하고, 컴포넌트 속성값에 타입 정보를 추가하는 방법을 알아본다. 그리고 조건부 렌더링을 할 때 가독성이 높은 방식은 무엇인지 알아보고, 마지막으로 컨테이너 컴포넌트와 프레젠테이션 컴포넌트로 구분해서 폴더를 구성하는 방법도 알아보자. 

#### 추천하는 컴포넌트 파일 작성법

컴포넌트 파일에는 다양한 종류의 함수와 변수가 등장한다. 그로 인해 코드의 가독성이 떨어지고 관리가 힘들어질 수 있다. 가독성과 생산성을 높이기 위해 코드를 어떻게 배치하면 좋을지 살펴보자.

##### 컴포넌트 파일 작성 순서

다음은 추천하는 컴포넌트 파일 작성 예다.

```jsx
MyComponent.propTypes = {
    // ...
};

export default function MyComponent({prop1, prop2}) {
    // ...
}

const COLUMNES = [
    { id: 1, name: 'phoneNumber', width: 200, color: 'white' },
    { id: 1, name: 'city', width: 100, color: 'grey' },
    // ...
];

const URL_PRODUCT_LIST = '/api/products';
function getTotalPrice({ price, total }) {
    // ...
}
```

파일 최상단에는 속성값의 타입을 정의한다. 속성값 타입이 가장 먼저 오는 이유는 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해가 된다. 어떤 컴포넌트를 사용하기 위해서는 그 컴포넌트의 속성값 타입을 알아야 하므로 파일을 열었을 때 속성값 타입이 가장 먼저 보이는 게 좋다. 또한, 컴포넌트 작성자 입장에서도 속성값 타입은 다른 여느 코드 못지않게 중요하다. 따라서 속성값 타입 위쪽으로는 import 코드만 오도록 작성하자.

컴포넌트 파일의 매개변수는 명명된 매개변수로 정의하는 게 좋다. 속성값을 사용할 때마다 props.을 반복해서 입력하지 않아도 되므로 코드 작성이 편해진다. 그리고 컴포넌트 이름을 꼭 작성하자. function()처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 힘들다.

컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의한다. 특별한 이유가 없다면 변수는 상수 변수(const)로 정의하는 게 좋다. 그리고 상수 변수의 이름은 예제처럼 대문자로 작성하는 게 가독성에 좋다. 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하도록 하자. 그래야 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 있다. 

##### 서로 연관된 코드를 한 곳으로 모으기

이번에는 여러 가지 기능이 섞여 있는 코드를 어떻게 배치하면 좋을지 다음 코드를 통해 알아보자. 

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState(null);
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

모든 상탯값을 컴포넌트 함수 상단에서 정의하고 있다. 그리고 모든 useEffect 훅의 상탯값 코드 밑에 정의하고 있다.

앞의 코드에는 사용자 정보를 가져오는 기능과 창의 너비를 가져오는 기능이 섞여 있다. 다음은 각 기능별로 코드를 모아 놓은 코드다.

```jsx
function Profile({ userId }) { 
	const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
        const [width, setWidth] = useState(window.innerWidth);
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

사용자 정보를 가져오는 기능을 한 곳으로 모았다. 마찬가지로 창의 너비를 가져오는 기능을 한곳으로 모았다.

위에서 작성한 코드보다 현재의 코드가 가독성 면에서 낫다는 걸 알 수 있다. 이처럼 코드를 한곳에 모을 때는 훅의 종류별로 모으는 것보다는 연관된 코드끼리 모으는 게 좋다. 만약 컴포넌트 코드가 복잡하다고 느껴진다면 각 기능을 커스텀 훅으로 분리하는 것도 좋은 방법이다. 다음은 두 가지 기능을 각각 커스텀 훅으로 분리한 코드다.

```jsx
function Profile({ userId }) {
    const user = useUser(userId);
    const width = useWindowWidth();
    // ...
}

function useUser(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    return user;
}

function useWindowWidth() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    return width;
}
```

각 기능을 커스텀 훅으로 분리하면 Profile 컴포넌트 코드는 가독성이 좋아진다. 각 기능을 useUser, useWindowWidth 커스텀 훅으로 분리했다. 

기능을 커스텀 훅으로 분리하면 같은 기능을 다른 곳에서 사용하기 좋다. 기능을 재사용하는 곳이 없다고 하더라도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자. 다만 컴포넌트 코드가 복잡하지 않은 경우에는 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으니 필요하다고 판단되는 경우에만 분리하도록 하자.

#### 속성값 타입 정의하기: prop-types

prop-types는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지다. 속성값의 타입 정보는 컴포넌트 코드의 가독성을 위해서 필수로 작성하는 게 좋다. 코드에서 타입 정보가 필요한 이유를 간단하게 알아보자. 그리고 prop-types에서 기본적으로 제공하는 타입의 종류를 알아보고, 기본 타입 외에도 타입 정보의 함수를 이용해서 자신만의 타입을 만드는 방법도 알아보자. 

자바스크립트는 동적 타입 언어다. 타입이 없기 때문에 배우기 쉽고 간단한 프로그램을 작성할 때는 생산성이 좋다. 하지만 소스 파일이 50개가 넘어 가는 규모의 프로그램을 작성할 때는 오히려 생산성이 떨어진다. 그래서 가능하면 정적 타입 언어를 사용하는 게 좋다. 

하지만 상황이 여의치 않아서 동적 타입 언어를 사용해야만 할 때가 있다. 이를 위해 리액트에서는 속성값 타입을 정의할 수 있는 prop-types 패키지를 제공한다. prop-types를 사용할 경우 컴포넌트 사용 시 속성값에 잘못된 타입이 입력되면 콘솔에 에러 메시지가 출력된다. 이는 리액트가 렌더링하는 과정에서 잘못된 속성값 타입을 검사해 주기 때문에 가능하다. 물론 속성값 타입을 검사하기 위해 별도의 연산이 필요하므로 타입 검사는 개발 모드에서만 동작한다. 타입 에러를 사전에 검사할 수 있으므로 도움이 된다. 

prop-types를 사용했을 때 생기는 또 다른 장점은 타입 정의 자체가 훌륭한 문서가 된다는 점이다. 만약 속성값 타입 정보가 없다면 컴포넌트를 사용하는 사람 입장에서는 속성값의 정보를 파악하기 위해 코드를 일일이 들여다봐야 한다. 다음과 같이 속성값의 타입 정보를 입력하지 않은 컴포넌트를 사용해야 한다고 가정해 보자. 

```jsx
function User({ type, age, male, onChangeName, onChangeTitle }) {
    function onClick1() {
        const msg = `type: ${type}, age: ${age ? age : "알 수 없음"}`;
        log(msg, { color: type === "gold" ? "red" : "black" });
        // ...
    }
    function onClick2() {
        if (onChangeName) {
            onChangeName(name);
        }
        onChangeTitle(title);
        male ? goMalePage() : goFemalePage();
        // ...
    }
    // ...
}
```

각 속성의 타입이 무엇인지는 코드를 자세히 들여다보기 전까지 알기가 힘들다.

다음은 prop-types를 이용해서 위의 코드에 타입 정보를 추가한 코드다. 컴포넌트의 로직을 이해하지 않고도 속성값의 타입 정보를 한눈에 파악할 수 있다.

```jsx
User.propTypes = {
    male: PropTypes.bool.isRequired,
    age: PropTypes.number,
    type: PropTypes.oneOf(["gold", "silver", "bronze"]),
    onChangeName: PropTypes.func,
    onChangeTitle: PropTypes.func.isRequired
};
```

male 속성값은 필숫값이기 때문에 부모 컴포넌트에서 이 값을 주지 않으면 에러 메시지가 출력된다. 반대로 age 속성값은 필숫값이 아니기 때문에 이 값을 주지 않아도 에러는 발생하지 않는다. 만약 age 속성값으로 문자열을 줬다면 타입이 잘못됐다는 에러 메시지가 출력된다. type 속성값에는 gold, silver, bronze 중의 하나만 입력할 수 있다. 여기서 한 가지 부족한 타입 정보는 onChangeName과 같은 함수의 타입이다. prop-types에서 함수의 매개변수와 반환값에 대한 타입 정보는 정의할 수 없다. 이 경우에는 문서화를 위해 타입 정보를 주석으로 자세히 적기를 추천한다. 

##### prop-types로 정의할 수 있는 타입

다음 코드는 prop-types로 정의할 수 있는 여러 가지 타입을 보여 준다. 자세한 설명은 주석을 통해 확인할 수 있다. 

```jsx
MyComponent.propTypes = {
    // 리액트 요소
    // <div>hello</div> => 참
    // <SomeComponent /> => 참
    // 123 => 거짓
    menu: PropTypes.element,
    
    // 컴포넌트 함수가 반환할 수 있는 모든 것
    // number, string, array, element, ...
    // <SomeComponent /> => 참
    // 123 => 참
    description: PropTypes.node,
    
    // Message 클래스로 생성된 모든 객체
    // new Message() => 참
    // new Car() => 거짓
    message: PropTypes.instanceOf(Message),
    
    // 배열에 포함된 값 중에서 하나를 만족
    // 123 => 참
    // 'messy' => 참
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    
    // 특정 타입만 포함하는 배열
    // [1, 5, 7] => 참
    // ['a', 'b'] => 거짓
    ages: PropTypes.arrayOf(PropTypes.number),
    
    // 객체의 속성값 타입을 정의
    // {color: 'red', weight: 123} => 참
    // {color: 'red', weight: '123kg'} => 거짓
    info: PropTypes.shape({
        color: PropTypes.string,
        weight: PropTypes.number
    }),
    
    // 객체에서 모든 속성값의 타입이 같은 경우
    // {prop1: 123, prop2: 456} => 참
    // {prop1: 'red', prop2: 123} => 거짓
    infos: PropTypes.objectOf(PropTypes.number)
};
```

이처럼 prop-types가 제공하는 타입 정의 함수를 이용하면 웬만한 타입 정보는 표현할 수 있다. 그리고 다음과 같이 본인만의 타입 함수를 작성할 수도 있다. 

```jsx
MyComponent.propTypes = {
    age: function(props, propName, componentName) {
        const value = props[propName];
        if (value < 10 || value > 20) {
            return new Error(
            	`Invalid prop ${propName} supplied to ${componentName}.
                It must be 10 <= value <= 20.`
            );
        }
    }
};
```

age 속성값의 타입은 10 이상이고 20 이하인 숫자로 정의됐다. 조건에 맞지 않는 값이 들어오면 에러를 반환한다. 

#### 가독성을 높이는 조건부 렌더링 방법

컴포넌트 함수 내부에서 특정 값에 따라 선택적으로 렌더링하는 것을 조건부 렌더링(conditional rendering)이라 한다. 조건부 렌더링을 구현할 때는 삼항 연산자가 유용한 경우도 있지만 대부분 && 연산자가 가독성이 더 좋다. 예제를 통해 몇 가지 조건부 렌더링 방법을 알아보고, && 연산자를 이용한 방법과 비교해 보자. 

개발하다 보면 다음과 같은 조건부 렌더링을 자주 사용하게 된다. 

```jsx
function GreetingA({ isLogin, name }) { 
	if (isLogin) {
        return <p>{`${name}님 안녕하세요.`}</p>;
    } else {
        return <p>권한이 없습니다.</p>;
    }
}

function GreetingB({ isLogin, name }) {
    return <p>{isLogin ? `${name}님 안녕하세요.` : '권한이 없습니다.'}</p>;
}
```

GreetingB 컴포넌트가 좀 더 짧기도 하고 p 태그가 한 번만 등장해서 GreetingA보다 좋은 선택인 것 같다. 하지만 매번 그런 것은 아니다. 다음 코드처럼 좀 더 복잡한 조건부 렌더링의 경우를 보자. 

```jsx
function GreetingA({ isLogin, name }) {
    if (isLogin) {
        return (
        	<p className="greeting" onClick={showMenu}>
            	{`${name}님 안녕하세요.`}
            </p>
        );
    } else {
        return (
        	<p className="noAuth" onClick={goToLoginPage}>
            	권한이 없습니다.
            </p>
        );
    }
}

function GreetingB({ isLogin, name }) {
    return (
    	<p className={isLogin ? 'greeting' : 'noAuth'} 
            onClick={isLogin ? showMenu : goToLoginPage}>
            {isLogin ? `${name}님 안녕하세요.` : '권한이 없습니다.'}
        </p>
    );
}
```

위의 코드에서 어느 방법이 더 좋을지 토론을 하면 갑론을박이 벌어져 쉽게 결론이 나지 않는다. 확실한 답이 없기 때문이다. 그렇다고 어느 쪽을 쓰든 상관없다고 결론지으려는 건 아니다. 때에 따라 상대적으로 더 좋은 코드가 있다. 

조건부 렌더링을 무분별하게 사용하면 JSX 코드는 금방 스파게티가 되므로, 더 좋은 코드에 대한 고민을 끊임없이 해야 한다. 특히 JSX 코드에서는 삼항 연산자보다 && 연산자를 사용한 조건부 렌더링 코드가 가독성이 더 높다. 

다음은 로그인했을 때만 개인 정보를 보여주는 코드를 삼항 연산자를 사용해서 구현한 것이다.

```jsx
function Greeting({ isLogin, name, cash }) {
    return (
    	<div>
        	저희 사이트에 방문해 주셔서 감사합니다.
            {isLogin ? (
            	<div>
                	<p>{name}님 안녕하세요.</p>
                    <p>현재 보유하신 금액은 {cash}원입니다.</p>
                </div>
            ) : null}
        </div>
    );
}
```

##### && 연산자를 이용한 조건부 렌더링

특정 조건에서만 렌더링할 때는 위의 코드처럼 삼항 연산자를 사용하는 것보다는 && 연산자를 사용하는 게 낫다.

> **&&, || 연산자 이해하기**
>
> &&와 || 연산이 헷갈리다면 이 시점에서 확실히 이해해 보자.
>
> ```jsx
> const v1 = 'ab' && 0 && 2; // v1 === 0
> const v2 = 'ab' && 2 && 3; // v2 === 3
> const v3 = 'ab' || 0; // v3 === 'ab'
> const v4 = '' || 0 || 3; // v4 === 3
> ```
>
> &&, || 연산자 모두 마지막으로 검사한 값을 반환한다. 따라서 && 연산자는 첫 거짓(false)값 또는 마지막 값을 반환하고, || 연산자는 첫 참(true)값 또는 마지막 값을 반환한다. 따라서 렌더링할 리액트 요소를 && 연산자의 끝에 작성하고, 앞쪽에는 해당 조건을 작성하는 방식으로 조건부 렌더링을 구현할 수 있다. 

다음은 && 연산자를 사용해서 조건부 렌더링을 구현한 코드다. 

```jsx
function Greeting({ isLogin, name, cash }) {
    return (
    	<div>
      		저희 사이트에 방문해 주셔서 감사합니다.
            {isLogin && (
            	<div>
                	<p>{name}님 안녕하세요.</p>
                    <p>현재 보유하신 금액은 {cash}원입니다.</p>
                </div>
            )}
        </div>
    );
}
```

코드의 끝에 null을 생략해도 되기 때문에 가독성이 좋아진다. 아직까지는 코드가 간단해서 크게 와닿지 않을 수도 있다. 예를 들어 기획서가 업데이트됐는데, 이벤트 기간에는 개인 정보를 생략한 채 이벤트 문구를 보여 줘야 하고, 로그인을 했더라도 캐시가 십만 원을 넘으면 해킹한 사람이므로 개인 정보를 보여 주면 안 된다는 전제가 있다고 하자. 이에 삼항 연산자를 좋아하는 개발자는 다음과 같이 작성했다.

```jsx
function Greeting({ isEvent, isLogin, name, cash }) {
    return (
    	<div>
        	저희 사이트에 방문해 주셔서 감사합니다.
            {isEvent ? (
            	<div>
                	<p>오늘의 이벤트를 놓치지 마세요.</p>
                    <button onClick={onClickEvent}>이벤트 참여하기</button>
                </div>
            ) : isLogin ? (
            	cash <= 100000 ? (
                	<div>
                    	<p>{name}님 안녕하세요.</p>
                        <p>현재 보유하신 금액은 {cash}원입니다.</p>
                    </div>
                ) : null
            ) : null}
        </div>
    );
}
```

삼항 연산자를 중첩해서 사용했다. 첫 번째 삼항 연산자는 어디에서 끝나는지 파악하기도 힘들다. 이 코드를 && 연산자를 사용한 버전으로 변경하면 다음과 같다.

```jsx
function Greeting({ isEvent, isLogin, name, cash }) {
    return (
    	<div>
        	저희 사이트에 방문해 주셔서 감사합니다.
            {isEvent && (
            	<div>
                	<p>오늘의 이벤트를 놓치지 마세요.</p>
                    <button onClick={onClickEvent}>이벤트 참여하기</button>
                </div>
            )}
            {!isEvent && 
            	isLogin &&
                cash <= 100000 && (
            	<div>
                	<p>{name}님 안녕하세요.</p>
                    <p>현재 보유하신 금액은 {cash}원입니다.</p>
                </div>	
            )}
        </div>
    );
}
```

코드가 두 그룹이라는 게 금방 드러난다. 각 그룹의 조건도 한눈에 들어온다. 

> **&& 연산자 사용 시 주의할 점**
>
> && 연산자를 사용할 때 주의해야 할 점이 몇 가지 있다. 변수가 숫자 타입인 경우 0은 거짓이고, 문자열 타입인 경우 빈 문자열도 거짓이다. 당연하게 보이지만 && 연산자를 사용할 때 자주 실수하는 내용이다.
>
> 다음 코드는 && 연산자를 잘못 사용한 예를 보여 준다.
>
> ```jsx
> <div>
> 	{cash && <p>{cash}원 보유 중</p>}
>     {memo && <p>{200 - memo.length}자 입력 가능</p>}
> </div>
> ```
>
> 캐시가 0원일 때도 **0원 보유 중**을 출력해야 하는데 출력되지 않는다. 사실 더 큰 문제는 의도치 않게 숫자 0이 덩그러니 출력된다는 점이다. 만약 의도적으로 0도 거짓으로 처리하고 싶다면 !!cash &&를 입력하는 게 좋다. 마찬가지로 빈 문자열일 때는 **200자 입력 가능**이 출력되어야 하는데 출력되지 않는다. 이 경우에는 명확하게 undefined, null이 아닌 경우라고 표현해야 한다. 
>
> 위의 코드를 다음과 같이 수정하면 의도한 대로 동작한다.
>
> ```jsx
> <div>
> 	{cash != null && <p>{cash}원 보유 중</p>}
>     {memo != null && <p>{200 - memo.length}자 입력 가능</p>}
> </div>
> ```
>
> cash != null은 cash가 undefined가 아니고 null도 아니면 참이 된다.

변수가 배열인 경우에는 기본값으로 빈 배열을 넣어 주는 게 좋다. 다음 코드에서 students 배열의 기본값이 빈 배열이었다면 조건부 렌더링을 할 때마다 student &&를 입력하지 않아도 되기 때문에 편하게 map 함수를 사용할 수 있다.

```jsx
<div>{students && students.map(/* */)}</div>
<div>{products.map(/* */)}</div>
```

변수가 undefined 또는 null을 가질 수 있다면, 컴포넌트 함수에서 변수를 사용할 때마다 students && 코드를 작성해야 한다. 배열의 기본값을 빈 배열로 설정하면 코드가 간결해진다. 

조건에 따라 아무것도 렌더링하지 않은 경우에는 null을 반환하기도 한다. 또는 해당 컴포넌트를 사용하는 부모 컴포넌트에서 조건에 따라 자식 컴포넌트를 보이거나 가릴 수도 있다. 후자의 경우는 해당 컴포넌트가 마운트와 언마운트를 반복할 수 있다는 점을 인지해야 한다. 마운트와 언마운트를 반복하면 컴포넌트의 상탯값도 사라지고 렌더링 성능에도 안 좋은 영향을 끼칠 수 있다. 하지만 필요한 조건을 부모 컴포넌트에서 작성하기 때문에 자식 컴포넌트 입장에서는 로직이 더 간단해지는 장점도 있다.

조건부 렌더링의 방법은 다양하기 때문에 각자의 취향과 프로젝트의 성격에 따라 코딩 컨벤션을 정하는 게 좋다. 특히 코드 리뷰를 할 때 조건부 렌더링 쪽 코드가 복잡해서 힘들어지는 경우가 많다. 조건부 렌더링 코드를 수정할 때는 리뷰어(reviewer)를 배려하는 마음으로 코드를 작성하자. 

#### 관심사 분리를 위한 프레젠테이션, 컨테이너 컴포넌트 구분하기

댄 아브라모프(Dan Abramov)의 블로그 포스트로 잘 알려진 컴포넌트 구분법이 있다. 블로그 포스트에서 설명하는 구분법은 너무 복잡하고 헷갈리므로 보다 더 간단한 규칙을 제안한다. 비즈니스 로직과 상탯값의 유무에 따라 프레젠테이션(presentation)과 컨테이너(container)로 불리는 두 가지 컴포넌트로 구분하는 방법을 알아보자.

프로그래밍 세계에서 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 말한다. UI 처리, API 호출, DB 관리 등의 코드가 같은 곳에 있으면 복잡하기 때문에 이들은 서로 관심사가 다르다고 보고 분리해서 관리하는 게 좋다. 코드를 작성하다가 어느 순간 코드가 복잡해진다고 느껴진다면 관심사의 분리가 필요한 순간인지 생각해 보는 게 좋다. 

하나의 컴포넌트 안에서 모든 기능을 구현할 수는 없기 때문에 우리는 여러 개의 컴포넌트를 만들어서 조립한다. 하나의 폴더 안에 모든 컴포넌트를 모아 놓고 작업한다고 가정해 보자. 시간이 흐를수록 컴포넌트가 많아지고, 사용하려는 컴포넌트를 찾기가 어려워진다. 이때 기능별로 폴더를 만들어 관리하면 컴포넌트를 찾기가 쉬워지고 간단한 프로그램은 이 정도로도 충분해 보인다.

그러나 프로젝트의 규모가 커지면 문제가 생긴다. 비즈니스 로직과 상탯값이 컴포넌트의 여기저기에 흩어져 있다. 상탯값의 중복도 발생한다. 다음과 같이 부모 컴포넌트가 넘겨준 속성값으로부터 새로운 상탯값을 만드는 경우가 빈번해진다. 

```jsx
function MyComponent({ todos }) {
    const [doneList, setDoneList] = useState(todos.filter(item => item.done));
    function onChangeName(key, name) {
        setDoneList(
        	doneList.map(item => (item.key === key ? { ...item, name } : item))
        );
    }
    // ...
}
```

부모로부터 받은 todo로부터 완료 목록 doList를 만들었다. 그러고는 이벤트 처리 함수에서 특정 목록의 이름을 수정하고 있다. 

여기서 주목할 부분은 특정 목록의 이름을 수정하는 순간, 부모가 가진 데이터와 정합(sync)이 안 맞다는 것이다. 대개 이런 상황은 버그로 이어진다. 이렇게 자식 컴포넌트에서 부모의 데이터를 별도의 상탯값으로 관리하는 것은 나쁜 습관(anti-pattern)이라고 할 수 있다. 비즈니스 로직과 상탯값은 일부 컴포넌트로 한정해서 관리하는 게 좋다.

컴포넌트가 비즈니스 로직이나 상탯값을 가지고 있으면 재사용하기 힘들다. 컴포넌트를 재사용하면 할수록 이득인데 말이다. 컴포넌트에 비즈니스 로직이나 상탯값이 있어서 재사용을 못 하고 새로운 컴포넌트를 만들면 코드 중복이 발생할 수 있다. 개발자에게 있어서 코드 중복은 게으름이며 기술 부채다. 

그렇다면 비즈니스 로직과 상탯값의 유무로 컴포넌트를 분리하면 어떨까? 앞에서 언급한 댄 아브라모프의 블로그 글에서는 재사용성이 좋은 프레젠테이션 컴포넌트와 그렇지 않은 컨테이너 컴포넌트로 구분하는 방법을 설명한다. 하지만 글을 읽어 보면 머리가 더 복잡해질 수 있다. 그 글에서 설명하는 프레젠테이션 컴포넌트의 조건이 다소 복잡하기 때문이다. 추천하는 프레젠테이션 컴포넌트의 정의는 다음과 같다. 

+ 비즈니스 로직이 없다.
+ 상탯값이 없다. 단, 마우스 오버(mouse over)와 같은 UI 효과를 위한 상탯값은 제외한다. 

이처럼 컴포넌트를 프레젠테이션과 컨테이너로 구분하고 폴더도 이에 따라 별도로 관리하는 게 좋다. 일반적으로 프레젠테이션 컴포넌트 코드가 가독성이 더 좋고 재사용성도 높다. 

### useEffect 훅 실전 활용법

useEffect 훅 사용 시 의존성 배열을 관리하는 방법을 알아본다. 의존성 배열을 잘 관리하지 못해서 발생한 버그는 디버깅이 쉽지 않으므로 제대로 이해하고 사용해야 한다. 

#### 의존성 배열을 관리하는 방법

의존성 배열은 useEffect 훅에 입력하는 두 번째 매개변수다. 의존성 배열의 내용이 변경됐을 때 부수 효과 함수가 실행된다.

의존성 배열은 잘못 관리하면 쉽게 버그로 이어지므로 가능하면 입력하지 않는 게 좋다. 다행히 의존성 배열은 대부분의 경우에 입력하지 않아도 되는데, 꼭 필요한 경우가 생기기도 한다. 몇 가지 예제를 통해 의존성 배열을 관리하는 방법을 알아보자.

##### 부수 효과 함수에서 API를 호출하는 경우

부수 효과 함수에서 API를 호출한다면 불필요한 API 호출이 발생하지 않도록 주의해야 한다. 다음은 사용자 정보를 가져오기 위해 useEffect 훅을 이용하는 코드다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    useEffect(() => {
    	fetchUser(userId).then(data => setUser(data));   
    });
    // ...
}
```

fetchUser 함수는 렌더링을 할 때마다 호출되므로 비효율적이다.

이 문제를 해결하기 위해 의존성 배열에 빈 배열을 넣을 수 있도록 한다. 하지만 이는 userId가 변경돼도 새로운 사용자 정보를 가져오지 못하기 때문에 올바른 해결책이 아니다. 지금 이 순간에는 userId가 변경되지 않는다는 것을 확신한다고 하더라도 언제 기획서가 변경될지 모르는 일이다.

다음은 이 문제를 의존성 배열을 이용해서 해결하는 코드다.

```jsx
useEffect(() => {
	fetchUser(userId).then(data => setUser(data));    
}, [userId]);
```

userId가 변경될 때만 fetchUser 함수를 호출한다.

나중에 부수 효과 함수를 수정할 때는 새로 추가된 변수를 빠짐없이 의존성 배열에 추가해야 한다. 다음과 같이 fetchUser 함수에 매개변수를 추가한다고 생각해 보자.

```jsx
const [needDetail, setNeedDetail] = useState(false);
useEffect(() => {
    fetchUser(userId, needDetail).then(data => setUser(data));
}, [userId]);
```

상탯값 neddDetail을 부수 효과 함수에서 사용했다. 부수 효과 함수를 수정할 때 새로운 상탯값을 사용했다면 의존성 배열에 추가해야 한다. 하지만 사람이 하는 일이다 보니 이렇게 깜빡하고 needDetail을 의존성 배열에 추가하지 않는 일이 종종 생긴다. 

리액트 팀에서는 이러한 문제를 해결하기 위해 eslint에서 사용할 수 있는 exhaustive-deps 규칙을 만들어서 제공한다. exhaustive-deps는 잘못 사용된 의존성 배열을 찾아서 알려 준다. 의존성 배열에서 실수를 하는 경우가 많고, 의존성 배열 때문에 발생한 버그는 원인 파악도 힘들기 때문에 exhaustive-deps를 꼭 사용할 것을 추천한다.

> **의존성 배열을 잘못 관리하면 생기는 일**
>
> 의존성 배열에서 입력해야 할 값을 입력하지 않으면 오래된 값을 참조하는 문제가 발생한다. 다음 코드에서 **value1 증가** 버튼을 누르면 증가된 valu1 값이 콘솔에 출력된다. 하지만 **value2 증가*** 버튼을 누르면 오래된 value2 값이 콘솔에 출력된다. 
>
> ```jsx
> function MyComponent() {
>     const [value1, setValue1] = useState(0);
>     const [value2, setValue2] = useState(0);
>     useEffect(() => {
>         const id = setInterval(() => console.log(value1, value2), 1000);
>         return () => clearInterval(id);
>     }, [value1]);
>     return (
>     	<div>
>         	<button onClick={() => setValue(value1 + 1)}>value1 증가</button>
>         	<button onClick={() => setValue(value2 + 1)}>value2 증가</button>
>         </div>
>     );
> }
> ```
>
> value2를 의존성 배열에 넣지 않았다. 따라서 value2가 변경돼도 부수 효과 함수는 갱신되지 않으며 value2가 변경되기 전에 등록된 부수 효과 함수가 계속 사용된다. 
>
> 컴포넌트 함수가 실행될 때마다 부수 효과 함수가 생성되고, 함수는 생성될 당시의 변수를 참조한다. 같은 value2 변수라고 하더라도 컴포넌트 함수가 생성될 때마다 새로운 메모리 공간을 가진다. 즉, 부수 효과 함수는 함수가 생성된 시점의 value2를 참조하므로 예전에 생성된 부수 효과 함수는 예전 value2를 참조하는 것이다.

##### useEffect 훅에서 async await 함수 사용하기

useEffect 훅에서 async await 함수를 사용하기 위해 부수 효과 함수를 async await 함수로 만들면 에러가 난다. 부수 효과 함수의 반환값은 항상 함수 타입이어야 하기 때문이다.

다음은 부수 효과 함수를 async await 함수로 만든 것이다.

```jsx
useEffect(async () => {
    const data = await fetchUser(userId);
    setUser(data);
}, [userId]);
```

async await 함수는 프로미스 객체를 반환하므로 부수 효과 함수가 될 수 없다. 부수 효과 함수는 함수만 반환할 수 있으며, 반환된 함수는 부수 효과 함수가 호출되기 직전과 컴포넌트가 사라지기 직전에 호출된다.

useEffect 훅에서 async await 함수를 사용하는 한 가지 방법은 부수 효과 함수 내에서 async await 함수를 만들어서 호출하는 것이다.

```jsx
useEffect(() => {
    async function fetchAndSetUser() {
        const data = await fetchUser(userId);
        setUser(data);
    }
    fetchAndSetUser();
}, [userId]);
```

부수 효과 함수 내에서 async await 함수를 만들고, 그 함수를 바로 호출한다.

##### fetchAndSetUSer 함수 재사용하기

다음과 같이 fetchAndSetUser 함수를 다른 곳에서도 사용해야 한다면 코드를 어떻게 변경해야 할지 고민해 보자.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    useEffect(() => {
        async function fetchAndSetUser(needDetail) {
            const data = await fetchUser(userId, needDetail);
            setUser(data);
        }
        fetchAndSetUser(false);
    }, [userId]);
    if (!user) {
    return <h1>로딩...</h1>;
    }
    return (
        <div>
            <h1>{user.name}</h1>
            <p>{`캐시: ${user.cash}`}</p>
            <p>{`계정 생성일: ${user.createdAt}`}</p>
            <button onClick={() => fetchAndSetUser(true)}>더보기</button>
            <UserDetail user={user} />
        </div>
    );
}
```

더보기 버튼을 누르면 사용자 상세 정보를 보여 주는 기능을 추가하려고 한다. fetchUser 함수에서 상세 정보가 필요한지 여부를 알려 주는 needDetail 매개변수를 추가한다. 

useEffect 훅 안에 있는 fetchAndSetUser 함수를 훅 밖으로 빼야 하는 상황이다. 간단하게는 다음과 같이 해 볼 수 있다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    async function fetchAndSetUser(needDetail) {
        const data = await fetchUser(userId, needDetail);
        setUser(data);
    }
    useEffect(() => {
        fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    // ...
}
```

훅 내부에서 fetchAndSetUser 함수를 사용하므로 해당 함수를 의존성 배열에 넣는다. fetchAndSetUser 함수는 렌더링을 할 때마다 갱신되므로 결과적으로 fetchAndSetUser 함수는 렌더링을 할 때마다 호출된다.

이 문제를 해결하려면 fetchAndSetUser 함수가 필요할 때만 갱신되도록 만들어야 한다. 다음 코드는 useCallback 훅을 이용해서 userId가 변경될 때만 fetchAndSetUser 함수가 갱신된다.

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState();
    const fetchAndSetUser = useCallback(
    	async needDetail => {
          const data = await fetchUser(userId, needDetail);
          setUser(data);
        },
        [userId];
    );
    useEffect(() => {
        fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    // ...
}
```

useCallback 훅을 이용해서 fetchAndSetUSer 함수가 필요할 때만 갱신되도록 개선했다. 이제 fetchAndSetUser 함수는 userId가 변경될 때만 호출된다.

