## 리액트 실전 활용법

useEffect 훅의 기능은 간단하지만 그것을 제대로 사용하려면 결코 쉽지 않다. 개발자들은 훅이 등장하기 전에 쓰이던 클래스형 컴포넌트에 익숙해져 있어 잘못된 방법으로 접근하는 경우가 많기 때문이다. useEffect 훅을 잘못 사용하면 오래된 데이터를 참조하거나 부수 효과가 자주 실행되는 문제가 발생할 수 있다.

이번에는 useEffect 훅을 제대로 사용하는 방법을 알아보자. 그리고 가독성과 생산성을 높이는 컴포넌트 작성 방법, 렌더링 속도를 올리기 위한 성능 최적화 방법도 알아보자. 

### 가독성과 생산성을 고려한 컴포넌트 코드 작성법

컴포넌트 코드를 작성할 때 가독성과 생산성을 높여 주는 방법을 알아보자. 같은 기능을 하는 컴포넌트라도 다양한 방식으로 작성될 수 있다. 되도록 컴포넌트를 작성하는 사람 입장에서는 유지 보수하기 쉬운 코드를, 컴포넌트를 사용하는 사람 입장에서는 컴포넌트의 인터페이스를 쉽게 파악할 수 있는 코드를 작성하는 게 좋다. 먼저 추천하는 컴포넌트 파일 작성법을 소개하고, 컴포넌트 속성값에 타입 정보를 추가하는 방법을 알아본다. 그리고 조건부 렌더링을 할 때 가독성이 높은 방식은 무엇인지 알아보고, 마지막으로 컨테이너 컴포넌트와 프레젠테이션 컴포넌트로 구분해서 폴더를 구성하는 방법도 알아보자. 

#### 추천하는 컴포넌트 파일 작성법

컴포넌트 파일에는 다양한 종류의 함수와 변수가 등장한다. 그로 인해 코드의 가독성이 떨어지고 관리가 힘들어질 수 있다. 가독성과 생산성을 높이기 위해 코드를 어떻게 배치하면 좋을지 살펴보자.

##### 컴포넌트 파일 작성 순서

다음은 추천하는 컴포넌트 파일 작성 예다.

```jsx
MyComponent.propTypes = {
    // ...
};

export default function MyComponent({prop1, prop2}) {
    // ...
}

const COLUMNES = [
    { id: 1, name: 'phoneNumber', width: 200, color: 'white' },
    { id: 1, name: 'city', width: 100, color: 'grey' },
    // ...
];

const URL_PRODUCT_LIST = '/api/products';
function getTotalPrice({ price, total }) {
    // ...
}
```

파일 최상단에는 속성값의 타입을 정의한다. 속성값 타입이 가장 먼저 오는 이유는 컴포넌트를 사용하는 입장에서 생각하면 쉽게 이해가 된다. 어떤 컴포넌트를 사용하기 위해서는 그 컴포넌트의 속성값 타입을 알아야 하므로 파일을 열었을 때 속성값 타입이 가장 먼저 보이는 게 좋다. 또한, 컴포넌트 작성자 입장에서도 속성값 타입은 다른 여느 코드 못지않게 중요하다. 따라서 속성값 타입 위쪽으로는 import 코드만 오도록 작성하자.

컴포넌트 파일의 매개변수는 명명된 매개변수로 정의하는 게 좋다. 속성값을 사용할 때마다 props.을 반복해서 입력하지 않아도 되므로 코드 작성이 편해진다. 그리고 컴포넌트 이름을 꼭 작성하자. function()처럼 이름 없는 컴포넌트로 만들면 리액트 개발자 도구에서 디버깅이 힘들다.

컴포넌트 바깥의 변수와 함수는 파일의 가장 밑에 정의한다. 특별한 이유가 없다면 변수는 상수 변수(const)로 정의하는 게 좋다. 그리고 상수 변수의 이름은 예제처럼 대문자로 작성하는 게 가독성에 좋다. 컴포넌트 내부에서 커다란 객체를 생성하는 코드가 있을 때, 가능하다면 컴포넌트 외부에서 상수 변수로 정의해서 사용하도록 하자. 그래야 렌더링 시 불필요한 객체 생성을 피할 수 있어서 성능상 이점이 있다. 

##### 서로 연관된 코드를 한 곳으로 모으기

이번에는 여러 가지 기능이 섞여 있는 코드를 어떻게 배치하면 좋을지 다음 코드를 통해 알아보자. 

```jsx
function Profile({ userId }) {
    const [user, setUser] = useState(null);
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

모든 상탯값을 컴포넌트 함수 상단에서 정의하고 있다. 그리고 모든 useEffect 훅의 상탯값 코드 밑에 정의하고 있다.

앞의 코드에는 사용자 정보를 가져오는 기능과 창의 너비를 가져오는 기능이 섞여 있다. 다음은 각 기능별로 코드를 모아 놓은 코드다.

```jsx
function Profile({ userId }) { 
	const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
        const [width, setWidth] = useState(window.innerWidth);
    }, [userId]);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    // ...
}
```

사용자 정보를 가져오는 기능을 한 곳으로 모았다. 마찬가지로 창의 너비를 가져오는 기능을 한곳으로 모았다.

위에서 작성한 코드보다 현재의 코드가 가독성 면에서 낫다는 걸 알 수 있다. 이처럼 코드를 한곳에 모을 때는 훅의 종류별로 모으는 것보다는 연관된 코드끼리 모으는 게 좋다. 만약 컴포넌트 코드가 복잡하다고 느껴진다면 각 기능을 커스텀 훅으로 분리하는 것도 좋은 방법이다. 다음은 두 가지 기능을 각각 커스텀 훅으로 분리한 코드다.

```jsx
function Profile({ userId }) {
    const user = useUser(userId);
    const width = useWindowWidth();
    // ...
}

function useUser(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
        getUserApi(userId).then(data => setUser(data));
    }, [userId]);
    return user;
}

function useWindowWidth() {
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
        const onResize = () => setWidth(window.innerWidth);
        window.addEventListner("resize", onResize);
        return () => {
            window.removeEventListner("resize", onResize);
        };
    }, []);
    return width;
}
```

각 기능을 커스텀 훅으로 분리하면 Profile 컴포넌트 코드는 가독성이 좋아진다. 각 기능을 useUser, useWindowWidth 커스텀 훅으로 분리했다. 

기능을 커스텀 훅으로 분리하면 같은 기능을 다른 곳에서 사용하기 좋다. 기능을 재사용하는 곳이 없다고 하더라도 컴포넌트 코드가 복잡해지면 커스텀 훅으로 분리하자. 다만 컴포넌트 코드가 복잡하지 않은 경우에는 커스텀 훅이 오히려 가독성을 떨어뜨릴 수 있으니 필요하다고 판단되는 경우에만 분리하도록 하자.

