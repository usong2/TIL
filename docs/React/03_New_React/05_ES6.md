## ES6+ 자바스크립트

ES6은 ECMA에서 2015년에 채택한 자바스크립트 표준이다. ES6 이후로 자바스크립트에는 많은 변화가 있었다. 사실 프로그래밍 언어라면 당연히 있을 것으로 생각했던 많은 기능이 ES6에는 없었다. ES6에 새로 추가된 기능이 많은데, 그중 핵심적인 기능을 살펴본다. 

### 변수를 정의하는 새로운 방법: const, let

ES5까지의 자바스크립트에서는 var를 이용해서 변수를 정의했고 그게 유일한 방법이었다. ES6에서는 const와 let을 이용하는 새로운 변수 정의 방법이 생겼다. 새로운 방법이 나온 이유는 기존 방식으로는 해결되지 않는 문제가 있었기 때문이다. 자바스크립트가 저급한 언어라고 무시당하던 ES6 이전 시절, var가 그 비난에 한몫하지 않았을까 싶다. var가 안고 있는 문제들을 살펴보고, const와 let이 그 문제들을 어떻게 해결하는지 살펴본다. 

#### var가 가진 문제

##### var의 첫 번째 문제: 함수 스코프

var의 첫 번째 문제는 정의된 변수가 함수 스코프를 가진다는 것이다. 스코프(scope)란 변수가 사용될 수 있는 영역을 말한다. 스코프는 변수가 정의된 위치에 의해 결정된다. var로 정의된 변수는 함수 스코프이기 때문에 함수를 벗어난 영역에서 사용하면 에러가 발생한다. 

```jsx
function example() {
    var i = 1;
}

console.log(i); // 참조 에러
```

var 변수를 함수가 아닌 프로그램의 가장 바깥에 정의하면 전역 변수가 되는데, 이는 프로그램 전체를 감싸는 하나의 함수가 있다고 생각하면 이해가 쉽다. 특이한 점은 함수 안에서 var 키워드를 사용하지 않고 변수에 값을 할당하면 그 변수는 전역 변수가 된다는 점이다. 

```jsx
function example1() {
    i = 1;
}

function example2() {
    console.log(i);
}

example1();
example2(); // 1이 출력됨
```

이런 상황에서 명시적 에러가 발생하도록 하려면 파일 상단에 use strict를 선언하면 된다. 
var는 함수 스코프이기 때문에 for 반복문에서 정의된 변수가 반복문이 끝난 이후에도 계속 남는 문제점이 있다. 

```jsx
for (var i = 0; i < 10; i++) {
    console.log(i);
}

console.log(i); // 10
```

for 문 뿐만 아니라 while 문, switch 문, if 문 등 함수 내부에서 작성되는 모든 코드는 같은 문제를 안고 있다. 

var 변수의 스코프를 제한하기 위해 즉시 실행 함수를 사용하기도 한다. 즉시 실행 함수는 함수를 정의하는 시점에 바로 실행되고 사라진다. var 변수는 함수 스코프이므로 즉시 실행 함수로 묶으면 변수의 스코프를 제한할 수 있다. 그러나 즉시 실행 함수는 작성하기 번거롭고 가독성도 떨어진다. var 변수의 스코프 문제를 해결하려면 이렇게 상당한 노력이 필요하다. 

##### **var의 두 번째 문제: 호이스팅**

var로 정의된 변수는 그 변수가 속한 스코프의 최상단으로 끌어올려진다. 이를 호이스팅(hoisting)이라고 부른다. 끌어올려진다는 말의 의미가 무엇인지 지금부터 살펴보자. 

다음 코드에서는 정의되지 않은 변수를 사용해서 에러가 발생한다. 

```jsx
console.log(myVar); // 참조 에러
```

이제 console.log 밑에 변수를 정의해 보자.

```jsx
console.log(myVar); // undefined
var myVar = 1;
```

변수를 정의하기 전에 사용했음에도 이 코드를 실행하면 에러가 발생하지 않는다. 특이한 점은 1이 아니라 undefined가 출력된다는 점이다. 이것은 해당 변수의 정의가 위쪽으로 끌어올려졌기 때문인데, 코드가 다음처럼 변경됐다고 생각하면 이해하기 쉽다. 

```jsx
var myVar = undefined;
console.log(myVar); // undefined
myVar = 1;
```

변수의 정의만 끌어올려지고 값은 원래 정의했던 위치에서 할당된다. 특이하게도 다음처럼 변수가 정의된 곳에서 값을 할당할 수도 있다. 

```jsx
console.log(myVar); // undefined
myVar = 2;
console.log(myVar); // 2
var myVar = 1;
```

버그처럼 보이는 위와 같은 코드가 에러 없이 사용될 수 있는 것은 단점이라고 할 수 있다. 호이스팅은 직관적이지 않으며, 보통의 프로그래밍 언어에서는 찾아보기 힘든 성질이다. 

##### var의 기타 문제들

var의 또 다른 문제를 살펴보자. var를 이용하면 한 번 정의된 변수를 재정의할 수 있다. 

```jsx
var myVar = 1;
var myVar = 2;
```

변수를 정의한다는 것은 이전에 없던 변수를 생성한다는 의미로 통용된다. 따라서 앞의 코드가 에러 없이 사용될 수 있다는 것은 직관적이지 않으며 버그로 이어질 수 있다. 

또 다른 문제는 var가 재할당 가능한 변수로밖에 만들 수 없다는 점이다. 상수처럼 쓸 값도 무조건 재할당 가능한 변수로 만들어야 한다. 이런 상황에서 재할당 불가능한 변수를 사용한다면 코드의 복잡도가 낮아지고 가독성은 높아진다. 

#### var의 문제를 해결하는 const, let

##### const, let은 블록 스코프다

var는 함수 스코프였지만 const, let은 블록(block) 스코프다. 함수 스코프의 단점 대부분이 블록 스코프에는 없다. 블록 스코프는 대부분의 언어에서 사용하므로 개발자에게 익숙한 개념이다. 

```jsx
if (true) {
    const i = 0;
}
console.log(i); // 참조 에러
```

블록 스코프에서 if 문의 블록 안에서 정의된 변수는 if 문을 벗어나면 참조할 수 없다. 따라서 if 문에서 생성된 변수를 블록 바깥에서 사용하려고 하면 에러가 발생한다. 이러한 상황에서 에러가 발생하는 것이 직관적이며 이해하기도 쉽다. var를 사용하는 경우에는 if 문 안에서 생성된 변수가 if 문을 벗어나고 계속 살아 있기 때문에, 함수 스코프를 벗어나기 전까지 계속해서 신경 써서 관리해야 했다. 

이번에는 블록 스코프에서 같은 이름의 변수를 정의하는 경우를 살펴보자.

```jsx
let foo = 'bar1';
console.log(foo); // bar1
if (true) {
    let foo = 'bar2';
    console.log(foo); // bar2
}
console.log(foo);
```

마지막 줄의 foo 변수는 같은 블록에서 정의된 변수를 참조하므로 bar1를 출력한다. 

##### const, let에서의 호이스팅

const 도는 let으로 정의된 변수도 호이스팅된다. 하지만 const 또는 let으로 변수를 정의하기 전에 그 변수를 사용하려고 하면 참조 에러가 발생한다. 

```jsx
console.log(foo); // 참조 에러
const foo = 1;
```

똑같은 경우에 var는 에러가 발생하지 않았다. 따라서 const 또는 let으로 정의된 변수는 호이스팅이 되지 않는다고 생각하기 쉽다. 하지만 const 또는 let으로 정의된 변수도 호이스팅된다. 다만 변수가 정의된 위치와 호이스팅된 위치 사이에서 변수를 사용하려고 하면 에러가 발생한다. 이 구간을 임시적 사각지대(temporal dead zone)라고 한다.

임시적 사각지대에서 변수를 사용하지 못한다면 호이스팅의 역할은 무엇인지 생각해 보자. 다음 코드에서는 같은 변수가 서로 다른 스코프에 정의되어 있다. 

```jsx
const foo = 1;
{
    console.log(foo); // 참조 에러
    const foo = 2;
}
```

만약 첫번째 선언한 변수가 호이스팅되지 않았다면 참조 에러는 발생하지 않고 아래의 변수 값이 출력될 것이다. 이 예제를 통해 호이스팅의 역할을 짐작할 수 있다. 첫 번째 변수의 호이스팅 때문에 console 창에서는 첫 번째 변수를 참조하게 된다. 그리고 첫 번째 변수를 참조했지만 임시적 사각지대여서 에러가 발생한다. 이를 제대로 이해하기 위해서는 브라우저가 자바스크립트의 실행 환경을 어떻게 구축하는지 알아야 한다. 

var로 정의된 변수에는 임시적 사각지대가 없기 때문에 다음 코드에서는 참조 에러가 발생하지 않는다. 

```jsx
var foo = 1;
(function () {
    console.log(foo); // undefined
    var foo = 2;
})();
```

##### const는 변수를 재할당 불가능하게 만든다

const로 정의된 변수는 재할당이 불가능하다. 반대로 let, var로 정의된 변수는 재할당할 수 있다. 재할당 불가능한 변수는 프로그램으 복잡도를 상당히 낮춰주기 때문에 되도록이면 재할당 불가능한 변수를 사용하는게 좋다. 

```jsx
const bar = 'a';
bar = 'b'; // 에러 발생
var foo = 'a';
foo = 'b'; // 에러 없음
let value = 'a';
value = 'b'; // 에러 없음
```

이처럼 const로 정의된 변수에 값을 재할당하면 에러가 발생한다. 다만 const로 정의된 객체의 내부 속성값은 수정 가능하다는 점을 주의해야 한다. 

```jsx
const bar = { prop1: 'a' };
bar.prop1 = 'b';
bar.prop2 = 123;
console.log(bar); // { prop1: 'b', prop2: 123 }
const arr = [10, 20];
arr[0] = 100;
arr.push(300);
console.log(arr); // [ 100, 20, 300 ]
```

이미 존재하는 속성값을 수정하거나 새로운 속성값을 추가하는 것 모두 가능하다. 객체의 내부 속성값도 수정 불가능하게 만들고 싶다면 immer, immutable.js 등의 외부 패키지를 활용하는 게 좋다. 이러한 외부 패키지는 객체를 수정하려고 할 때 기존 객체는 변경하지 않고 새로운 객체를 생성한다. 새로운 객체를 생성하는 편의 기능은 필요 없고 단지 수정만 할 수 없도록 차단하고 싶다면, 다음과 같은 자바스크립트 내장 함수를 이용하면 된다. 

+ Object.preventExtensions
+ Object.seal
+ Object.freeze

당연한 이야기지만 const로 정의했던 객체를 참조하는 변수 자체를 변경하는 것은 불가능하다. 

```jsx
const bar = { prop1: 'a' };
bar = { prop2: 123 }; // 에러 발생
```

### 객체와 배열의 사용성 개선

ES6+에서 객체와 배열에 추가된 문법을 알아보자. 단축 속성명과 계산된 속성명을 이용하면 객체와 배열을 생성하고 수정하는 코드를 쉽게 작성할 수 있다. 또한, 전개 연산자와 비구조화 할당(destructuring assignment) 덕분에 객체와 배열의 속성값을 밖으로 꺼내는 방법이 한결 쉬워졌다. 

#### 객체와 배열을 간편하게 생성하고 수정하기 

##### 단축 속성명

단축 속성명(shorthand property names)은 객체 리터럴 코드를 간편하게 작성할 목적으로 만들어진 문법이다. 단축 속성명을 사용하면 간편하게 새로운 객체를 만들 수 있다. 

```jsx
const name = 'mike';
const obj = {
    age: 21,
    name,
    getname() { return this.name; }, 
};
```

새로 만들려면 객체의 속성값 일부가 이미 변수로 존재하면 간단하게 변수 이름만 적어 주면 된다. 이때 속성명은 변수 이름과 같아진다. 속성값이 함수이면 function 키워드 없이 함수명만 적어도 된다. 이때 속성명은 함수명과 같아진다. 

이번에는 단축 속성명을 사용한 경우와 사용하지 않은 경우를 비교해 보자. 

```jsx
function makePerson1(age, name) { 
	return { age: age, name: name };
}

function makePerson2(age, name) {
    return { age, name };
}
```

첫 번째 makePerson1은 속성명을 사용하지 않은 경우이고,  makePerson2가 사용한 경우다. 보다시피 단축 속성명을 사용한 경우가 코드를 작성하기도 편하고 가독성도 좋다. 

또한, 단축 속성명은 디버깅을 위해 콘솔 로그를 출력할 때 유용하다. 

```jsx
const name = 'mike';
const age = 21;
console.log('name = ', name, ', age = ', age); // name = mike, age = 21
console.log({ name, age }); // { name: 'mike', age: 21 }
```

단축 속성명이 없었다면 위의 콘솔과 같이 출력했겠지만 아래의 코드가 훨씬 간결해진 것을 확인할 수 있다. 

##### 계산된 속성명

계산된 속성명(computed property names)은 객체의 속성명을 동적으로 결정하기 위해 나온 문법이다. 

```jsx
function makeObject1(key, value) {
    const obj = {};
    obj[key] = value;
    return obj;
}

function makeObject2(key, value) {
    return { [key]: value };
}
```

계산된 속성명을 사용하면 같은 함수를 makeObject2처럼 간결하게 작성할 수 있다. 

계산된 속성명은 다음과 같이 컴포넌트의 상탯값을 변경할 때 유용하게 쓸 수 있다. 

```jsx
class MyComponent extends React.Component {
    state = {
        count1: 0,
        count2: 0,
        count3: 0,
    };
	// ...
	onClick = index => {
        const key = `count${index}`;
        const value = this.state[key];
        this.setState({ [key]: value + 1 });
    }
}
```

setState 호출 시 계산된 속성명을 사용할 수 있다. 만약 계산된 속성명을 사용하지 않았다면 앞의 코드는 좀더 복잡했을 것이다. 

#### 객체와 배열의 속성값을 간편하게 가져오기

##### 전개 연산자

전개 연산자(spread operator)는 배열이나 객체의 모든 속성을 풀어놓을 때 사용하는 문법이다. 다음과 같이 매개변수가 많은 함수를 호출할 때 유용하다. 

```jsx
Math.math(1, 3, 7, 9);
const numbers = [1, 3, 7, 9];
Math.max(...numbers);
```

첫번째 행과 같은 방식으로 동적으로 매개변수를 전달할 수 없다.  만약 네 개의 변수를 사용하면 값은 동적으로 전달할 수 있지만 매개변수 개수는 항상 네 개로 고정이다. 아래와 같은 전개 연산자를 사용하면 동적으로 함수의 매개변수를 전달할 수 있다. 

> **동적으로 함수의 매개변수를 전달하는 다른 방법**
>
> 전개 연산자를 사용하지 않고도 다음과 같이 동적으로 함수의 매개변수를 전달할 수 있다. 
>
> + apply 함수를 이용해서 동적으로 함수의 매개변수 입력하기
>
>   ```jsx
>   const numbers = [-1, 5, 11, 3];
>   Math.math.apply(null, numbers);
>   ```
>
>   이 코드는 this 바인딩이 필요하지 않기 때문에 첫 번째 매개변수로 null을 입력하고 있다. 전개 연산자 방식보다 작성하기 번거롭고 가독성도 떨어진다.

전개 연산자는 배열이나 객체를 복사할 때도 유용하다. 

```jsx
const arr1 = [1, 2, 3];
const obj1 = { age: 23, name: 'mike' };
const arr2 = [...arr1];
const obj2 = { ...obj1 };
arr2.push(4);
obj2.age = 80;
```

전개 연산자를 사용해서 새로운 객체와 배열을 생성했다. 전개 연산자를 사용해서 새로운 객체가 생성되었기 때문에 속성을 추가하거나 변경해도 원래의 객체에 영향을 주지 않는다. 

배열의 경우 전개 연산자를 사용하면 그 순서가 유지된다.

```jsx
[1, ...[2, 3], 4]; // [1, 2, 3, 4]
new Date(...[2020, 6, 24]); // 2020년 6월 24일
```

배열 리터럴에서 중간에 전개 연산자를 사용하면 전개 연산자 전후의 순서가 유지된다. 함수의 인수는 정의된 매개변수의 순서대로 입력해야 하므로, 순서가 유지되는 전개 연산자의 성질을 이용하기 좋다. 예를 들어, Date 생성자의 매개변수 순서대로 날짜 데이터를 관리하면 Date 객체를 쉽게 생성할 수 있다. 

전개 연산자를 사용하면 서로 다른 두 배열이나 객체를 쉽게 합칠 수 있다. 

```jsx
const obj1 = { age: 21, name: 'mike' };
const obj2 = { hobby: 'soccer' };
const obj3 = { ...obj1, ...obj2 };
console.log(obj3); // { age: 21, name: 'mike', hobby: 'soccer' }
```

그런데 이 코드에서 obj1과 obj2가 같은 이름의 속성을 가지고 있었다면 어떻게 될까? ES5까지는 중복된 속성명을 사용하면 에러가 발생했지만, ES6부터는 중복된 속성명이 허용된다. 

```jsx
const obj1 = { x: 1, x: 2, y: 'a' }; // { x: 2, y: 'a' }
const obj2 = { ...obj1, y: 'b' }; // { x: 2, y: 'b' }
```

중복된 속성명 사용 시 최종 결과는 마지막 속성명의 값이 된다. 중복된 속성명과 전개 연산자를 이용하면 객체의 특정 속성값을 변경할 때 이전 객체에 영향을 주지 않고 새로운 객체를 만들어 낼 수 있다. 이는 변수를 수정 불가능하도록 관리할 때 유용하게 사용될 수 있다. 

##### 배열 비구조화

배열 비구조화(array destructuring)는 배열의 여러 속성값을 변수로 쉽게 할당할 수 있는 문법이다. 다음은 배열 비구조화를 사용한 코드다. 

```jsx
const arr = [1, 2];
const [a, b] = arr;
console.log(a); // 1
console.log(b); // 2
```

배열의 속성값이 왼쪽의 변수에 순서대로 들어간다. 

이렇게 새로운 변수로 할당할 수도 있고 다음 코드처럼 이미 존재하는 변수에 할당할 수도 있다. 

```jsx
let a, b;
[a, b] = [1, 2];
```

배열 비구조화 시 기본값을 정의할 수 있다. 아래의 코드에서 배열의 속성값이 undefined라면 정의된 기본값이 할당되고, 그렇지 않다면 원래의 속성값이 할당된다. 

```jsx
const arr = [1];
const [a = 10, b = 20] = arr;
console.log(a); // 1 
console.log(b); // 20
```

첫 번째 변수의 속성값은 존재하기 때문에 기본값 10은 사용되지 않고 속성값이 그대로 할당된다. 두 번째 변수의 속성값은 undefined이므로 기본값 20이 할당된다. 

배열 비구조화를 사용하면 두 변수의 값을 쉽게 교환할 수 있다. 

```jsx
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a); // 2
console.log(b); // 1
```

두 변수가 값을 교환하기 위해서는 제 3의 변수를 이용하는 게 일반적이다. 하지만 배열 비구조화를 사용하면 제3의 변수가 필요하지 않을 뿐만 아니라 단 한줄의 짧은 코드로 구현할 수 있다.

배열에서 일부 속성값을 무시하고 진행하고 싶다면 건너뛰는 개수만큼 쉼표를 입력하면 된다. 

```jsx
const arr = [1, 2, 3];
const [a, , c] = arr;
console.log(a); // 1
console.log(c); // 3
```

첫 번째 속성값은 변수 a에 할당된다. 두 번째 속성값은 건너뛰고 세 번째 속성값이 변수 c에 할당된다.

쉼표 개수만큼을 제외한 나머지를 새로운 배열로 만들 수도 있다. 

```jsx
const arr = [1, 2, 3];
const [first, ...rest1] = arr;
console.log(rest1); // [2, 3]
const [a, b, c, ...rest2] = arr;
console.log(rest2); // []
```

배열 비구조화 시에 마지막에 ...와 함께 변수명을 입력하면 나머지 모든 속성 값이 새로운 배열로 만들어진다. 나머지 속성값이 존재하지 않으면 빈 배열이 만들어진다. 

##### 객체 비구조화

객체 비구조화(object destructing)은 객체의 여러 속성값을 변수로 쉽게 할당할 수 있는 문법이다. 다음은 객체 비구조화를 사용한 코드다.

```jsx
const obj = { age: 21, name: 'mike' };
const { age, name } = obj;
console.log(age); // 21
console.log(name); // mike
```

객체 비구조화에서는 중괄호를 사용한다. 배열 비구조화에서는 배열으 순서가 중요했지만 객체 비구조화에서 순서는 무의미하다. 따라서 name과 age의 순서를 바꿔도 결과는 같다. 단, 배열 비구조화에서 왼쪽 변수의 이름은 임의로 결정할 수 있지만, 객체 비구조화에서는 기존 속성명을 그대로 사용해야 한다. 

```jsx
const obj = { age: 21, name: 'mike' };
const { age, name } = obj;
const { name, age } = obj;
const { a, b } = obj;
```

객체 비구조화에서 순서는 무의미하므로 2행과 3행의 결과는 같다. 4행은 존재하지 않는 속성명을 사용하면 undefined가 할당된다. 

객체 비구조화에서는 속성명과 다른 이름으로 변수를 생성할 수 있다. 이는 중복된 변수명을 피하거나 좀 더 구체적인 변수명을 만들 때 좋다. 

```jsx
const obj = { age: 21, name: 'mike' };
const { age: theAge, name } = obj;
console.log(theAge); // 21
console.log(age); // 참조 에러
```

속성명의 age의 값을 theAge 변수에 할당한다. theAge라는 이름의 변수만 할당되고 age 변수는 할당되지 않는다. 

객체 비구조화에서도 기본값을 정의할 수 있다. 배열 비구조화처럼 속성값이 undefined인 경우에는 기본값이 들어간다. 

```jsx
const obj = { age: undefined, name: null, grade: 'A' };
const { age = 0, name = 'noName', grade = 'F' } = obj;
console.log(age); // 0
console.log(name); // null
console.log(grade); // A
```

age는 undefined이므로 기본값이 들어간다. 따라서 age는 0이 된다. 속성값이 null이면 기본값은 들어가지 않는다. 따라서 name은 null이 된다. 

기본값을 정의하면서 별칭을 함께 사용할 수 있다. 

```jsx
const obj = { age: undefined, name: 'mike' };
const { age: theAge = 0, name } = obj;
console.log(theAge); // 0
```

기본값으로 함수의 반환값을 넣을 수 있다.

```jsx
function getDefaultAge() {
    console.log('hello');
    return 0;
}
const obj = { age: 21, grade: 'A' };
const { age = getDefaultAge(), grade } = obj; // hello 출력되지 않음
console.log(age); // 21
```

한 가지 재미있는 건 기본값이 사용될 때만 함수가 호출된다는 점이다. age의 속성값은 undefined가 아니므로 기본값이 사용되지 않고, getDefaultAge 함수도 호출되지 않는다. 

객체 비구조화에서도 사용되지 않은 나머지 속성들을 별도의 객체로 생성할 수 있다. 

```jsx
const obj = { age: 21, name: 'mike', grade: 'A' };
const { age, ...rest } = obj;
console.log(rest); // { name: 'mike', grade: 'A' }
```

배열 비구조화와 비슷한 방식으로 나머지 속성들을 별도의 객체로 분리하고 있다. 

for 문에서 객체를 원소로 갖는 배열을 순회할 때 객체 비구조화를 사용하면 편리하다. 

```jsx
const people = [{ age: 21, name: 'mike' }, { age: 51, name: 'sara' }];
for (const { age, name } of people) {
    // ...
}
```

##### 비구조화 심화 학습

비구조화는 객체와 배열이 중첩되어 있을 때도 사용할 수 있다. 

```jsx
const obj = { name: 'mike', mother: { name: 'sara' } };
const { 
	name,
    mother: { name: motherName },
} = obj;
console.log(name);			// mike
console.log(motherName); 	// sara
console.log(mother);		// 참조 에러
```

세 개의 단어가 등장하지만, 비구조화의 결과로 motherName이라는 이름의 변수만 생성된다. 

비구조화에서 기본값의 정의는 변수로 한정되지 않는다. 

```jsx
const [{ prop: x } = { prop: 123 }] = [];
console.log(x); // 123
const [{ prop: x } = { prop: 123 }] = [{}];
console.log(x); // undefined
```

1행 코드에서 { prop:  }는 배열의 첫 번째 원소를 가리키고, { prop: 123 }은 그 기본값을 정의한다. 첫 번째 원소가 존재하지 않아서 기본값이 할당된다. 결과적으로 변수 x에는 기본값이 정의된 123이 들어간다. 3행 코드에서 배열의 첫 번째 원소가 존재하므로 기본값이 할당되지 않는다. 그리고 첫 번째 원소에는 prop이라는 이름의 속성명이 존재하지 않으므로 x에는 undefined가 할당된다. 

객체 비구조화에서도 계산된 속성명을 활용할 수 있다. 

```jsx
const index = 1;
const { ['key${index}']: valueOfTheIndex } = { key1: 123 };
console.log(valueOfTheIndex); // 123
```

객체 비구조화에서 계산된 속성명을 사용할 때에는 반드시 별칭을 입력해야 한다. 

별칭에 단순히 변수명만 입력할 수 있는 것은 아니다. 

```jsx
const obj = {};
const arr = [];
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });
console.log(obj); // {prop:123}
console.log(arr); // [true]
```

### 강화된 함수의 기능

ES6에서는 함수의 기능이 많이 보강되었다. 사실 이전의 함수가 뼈대만 구성해 놓은 상태였다면, ES6에서는 살을 붙여서 함수의 기능을 온전하게 완성했다고 볼 수 있다. 매개변수에 기본값을 줄 수 있게 되었고, 나머지 매개변수를 통해 가변 길이 매개변수를 좀 더 명시적으로 표현할 수 있게 되었다. 명명된 매개변수(named parameter)를 통해서 함수를 호출하는 코드의 가독성이 월등히 좋아졌다. 그리고 화살표 함수(arrow function)가 추가되면서 함수 코드가 간결해졌고, this 바인딩에 대한 고민을 덜 수 있게 되었다. 

#### 매개변수에 추가된 기능

##### 매개변수 기본값

ES6부터 함수 매개변수에 기본값을 줄 수 있다. 

```jsx
function printLog(a = 1) {
    console.log({ a });
}
printLog(); // { a: 1 }
```

인수 없이 함수를 호출하므로 a에는 undefined가 입력된다. 기본값이 정의된 매개변수에 undefined를 입력하면 정의된 기본값 1이 사용된다. 

객체 비구조화처럼 기본값으로 함수 호출을 넣을 수 있고, 기본값이 필요한 경우에만 함수가 호출된다. 

```jsx
function getDefault() {
    return 1;
}
function printLog(a = getDefault()) {
    console.log({ a });
}
printLog(); // { a: 1 }
```

입력값이 undefined인 경우에만 호출된다는 특징을 이용하면 매개변수에서 필숫값을 표현할 수 있다. 

```jsx
fucntion required() {
    throw new Error('no parameter');
}
function printLog(a = required()) {
    console.log({ a });
}
printLog(10); // { a: 10 }
printLog(); // 에러 발생: no parameter
```

매개변수의 값이 존재하면 required 함수는 호출되지 않는다. 매개변수의 값이 없으면 required 함수에서 예외(exception)가 발생하기 때문에 매개변수 a는 필숫값이 된다. 

##### 나머지 매개변수

나머지 매개변수(rest parameter)는 입력된 인수 중에서 정의된 매개변수 개수만큼을 제외한 나머지를 배열로 만들어 준다. 나머지 매개변수는 매개변수 개수가 가변적일 때 유용하다. 

```jsx
function printLog(a, ...rest) {
    console.log({ a, rest });
}
printLog(1, 2, 3); // { a: 1, rest: [2, 3]}
```

하나의 인자를 제외한 나머지를 rest 매개변수에 할당한다.

ES5에서는 arguments 키워드가 비슷한 역할을 한다. 위의 코드를 arguments 키워드로 작성하면 다음과 같다. 

```jsx
function printLog(a) {
    const rest = Array.from(arguments).splice(1);
    console.log({ a, rest });
}
printLog(1, 2, 3); // { a: 1, rest: [2, 3] }
```

매개변수 정의에서 arguments의 존재가 명시적으로 드러나지 않기 때문에 가독성이 좋지 않다. arguments는 배열이 아니기 때문에 배열처럼 사용하기 위해서는 배열로 변환하는 과정이 필요하다는 단점이 있다. 따라서 나머지 매개변수를 사용한 방식이 더 낫다. 

##### 명명된 매개변수

자바스크립트에서 명명된 매개변수(named parameter)는 객체 비구조화를 이용해서 구현할 수 있다. 명명된 매개변수를 사용하면 함수 호출 시 매개변수의 이름과 값을 동시에 적을 수 있으므로 가독성이 높다.

```jsx
const numbers = [10, 20, 30, 40];
const result1 = getValue(numbers, 5, 25);
const result2 = getValues({ numbers, greaterThan: 5, lessThan: 25 });
```

두 번째 행은 함수 호출 시 매개변수의 이름이 보이지 않아 인수가 의미하는 바를 알기 어렵다. 반대로 세 번째 행과 같이 명명된 매개변수를 이용하면 매개변수의 이름이 노출된다. 명명된 매개변수를 이용하면 선택적 매개변수(optional parameter)의 활용도가 올라간다. 필숫값과 반대되는 의미로, 있어도 되고 없어도 되는 매개변수를 선택적 매개변수라고 부른다. 

```jsx
const result1 = getValue(numbers, undefined, 25);
const result2 = getValues({ numbers, greaterThan: 5 });
const result3 = getValues({ numbers, lessThan: 25 });
```

첫 번째 행은 명명된 매개변수 없이 선택적 매개변수를 사용한 예로, 필요 없는 매개변수 자리에 undefined를 넣으면 된다. 그러나 이 방식은 매개 변수 개수가 많아지면 관리하기 힘들어진다. 2, 3행은 명명된 매개변수를 사용했다. 필요한 인수만 넣어 주면 되기 때문에 선택적 매개변수가 늘어나도 별 문제 없이 사용할 수 있다. 

명명된 매개변수를 사용하면 함수를 호출할 때마다 객체가 생성되기 때문에 비효율적일 것이라고 생각할 수 있다. 하지만 자바스크립트 엔진이 최적화를 통해 새로운 객체를 생성하지 않으므로 안심하고 사용해도 된다. 

#### 함수를 정의하는 새로운 방법: 화살표 함수

ES6에서는 화살표 함수(arrow function)을 이용해 함수를 정의하는 방법이 추가되었다. 화살표 함수를 이용하면 함수를 간결하게 작성할 수 있다. 

```jsx
const add = (a, b) => a + b;
console.log(add(1, 2)); // 3
const add5 = a => a + 5;
console.log(add5(1)); // 6
const addAndReturnObject = (a, b) => ({ result: a + b });
console.log(addAndReturnObject(1, 2).result); // 3
```

1행의 코드는 화살표 함수를 중괄호로 감싸지 않으면 오른쪽의 계산 결과가 반환된다. 명시적으로 return 키워드를 작성하지 않아도 되기 때문에 코드가 간결해진다. 3행의 코드는 매개변수가 하나라면 매개변수를 감싸는 소괄호도 생략할 수 있다. 5행은 객체를 반환해야 한다면 소괄호로 감싸야 한다. 

##### 화살표 함수의 코드가 여러 줄인 경우

화살표 함수에 여러 줄의 코드가 필요하다면 다음과 같이 전체를 중골호로 묶고, 반환값에는 return 키워드를 사용한다.

```jsx
const add = (a, b) => {
    if (a <= 0 || b <= 0) {
        throw new Error('must be positive number');
    }
    return a + b;
};
```

##### this와 arguments가 바인딩되지 않는 화살표 함수

화살표 함수가 일반 함수와 다른 점은 this와 arguments가 바인딩되지 않는다는 점이다. 따라서 화살표 함수에서 arguments가 필요하다면 나머지 매개변수를 이용한다. 

```jsx
const printLog = (...rest) => console.log(rest);
printLog(1, 2); // [1, 2]
```

##### 일반 함수에서 this 바인딩 때문에 버그가 발생하는 경우

이번에는 일반 함수의 this 바인딩을 알아보자. 일반 함수에서 this는 호출 시점에 사용된 객체로 바인딩된다. 따라서 객체에 정의된 일반 함수를 다른 변수에 할당해서 호출하면 버그가 발생할 수 있다. 

```jsx
const obj = {
    value: 1,
    increase: function() {
        this.value++;
    },
};
obj.increase();
console.log(obj.value); // 2
const increase = obj.increase;
increase();
console.log(obj.value); // 2
```

3행의 increase 함수는 일반 함수이므로 호출 시 사용된 객체가 this로 바인딩된다. 6행의 obj 객체가 this에 바인딩되므로 obj.value가 증가한다. 객체 없이 호출되는 경우에는 전역 객체가 바인딩되는데, 브라우저 환경에서는 window 객체가 바인딩된다. 따라서 obj.value는 증가하지 않는다. 화살표 함수 안에서 사용된 this와 arguments는 자신을 감싸고 있는 가장 가까운 일반 함수의 것을 참조한다. 따라서 increase 함수를 화살표 함수로 작성했다면 this는 window 객체를 가리키기 때문에 함수를 호출해도 obj.value는 항상 변하지 않는다. 

##### 생성자 함수 내부에서 정의된 화살표 함수의 this

이번에는 생성자 함수 내부에서 정의된 화살표 함수를 살펴보자. 생성자 함수 내부에서 정의된 화살표 함수의 this는 생성된 객체를 참조한다. 

```jsx
function Something() {
    this.value = 1;
    this.increase = () => this.value++;
}
const obj = new Something();
obj.increase();
console.log(obj.value); // 2
const increase = obj.increase;
increase();
console.log(obj.value); // 3
```

3행에서 화살표 함수 increase의 this는 가장 가까운 일반 함수인 Something의 this를 참조한다. Something 함수는 생성자이고 5행에서 obj 객체가 생성될 때 호출된다. new 키워드를 이용해서 생성자 함수를 호출하면 this는 생성되는 객체를 참조한다는 점에 유의하자. increase 함수의 this는 생성된 객체를 가리킨다. 그러므로 6행과 9행에서 호출 시점의 객체와는 무관하게 increase 함수의 this는 항상 생성된 객체를 참조하고 obj.value는 계속 증가한다. 

##### setInterval 함수 사용 시 this 바인딩 문제

```jsx
function Something() {
    this.value = 1;
    setInterval(function increase() {
        this.value++;
    }, 1000);
}
const obj = new Something();
```

실행해 보면 알겠지만 의도와 달리 obj.value는 증가하지 않는다. setInterval 함수의 인수로 들어간 increase 함수는 전역 환경(global context)에서 실행되기 때문에 this는 window 객체를 참조한다. 

ES5에서는 앞에서의 문제를 해결하기 위해 다음과 같은 편법을 사용했다.

```jsx
function Something() {
    this.value = 1;
    var that = this;
    setInterval(function increase() {
        that.value++;
    }, 1000);
}
const obj = new Something();
```

increase 함수에서는 클로저(closure)를 이용해서 미리 저장해둔 that 변수를 통해 this 객체에 접근한다. 

> **클로저 개념 이해하기**
>
> 클로저는 함수가 생성되는 시점에 접근 가능했던 변수들을 생성 이후에도 계속해서 접근할 수 있게 해주는 기능이다. 접근할 수 있는 변수는 그 함수를 감싸고 있는 상위 함수들의 매개변수와 내부 변수들이다. 
>
> ```jsx
> function makeAddFunc(x) {
>     return function add(y) {
>         return x + y;
>     };
> }
> 
> const add5 = makeAddFunc(5);
> console.log(add5(1)); // 6
> const add7 = makeAddFunc(7);
> console.log(add7(1)); // 8
> console.log(add5(1)); // 6
> ```
>
> 2행에서 add 함수는 상위 함수인 makeAddFunc의 매개변수 x에 접근할 수 있다. 7행에서 add5 함수가 생성된 이후에도 상위 함수를 호출할 때 사용했던 인수에 접근할 수 있다. 8~10행에서 중간에 makeAddFunc(7)이 호출되지만 add5에 영향을 주지는 않는다. 즉, 생성된 add 함수별로 클로저 환경이 생성된다. 

화살표 함수를 사용하면 위의 코드 같은 ES5 편법을 사용하지 않고도 원하는 기능을 구현할 수 있다. 

```jsx
function Something() {
    this.value = 1;
    setInterval(() => {
        this.value++;
    }, 1000);
}
const obj = new Something();
```

화살표 함수를 사용했기 때문에 this는 setInterval의 동작과는 상관없이 obj를 참조한다. 

### 향상된 비동기 프로그래밍 1: 프로미스

프로미스(promise)는 비동기 상태를 값으로 다룰 수 있는 객체다. 프로미스를 사용하면 비동기 프로그래밍을 할 때 동기 프로그래밍 방식으로 코드를 작성할 수 있다. 프로미스가 널리 보급되기 전에는 비동기 프로그래밍 코드인 콜백 패턴이 많이 쓰였다. 그러다가 몇 가지 프로미스 라이브러리가 등장하면서 프로미스를 사용하는 개발자가 많아졌고, 이제는 여러 라이브러리의 비동기 함수가 프로미스를 반환할 만큼 널리 사용되고 있다. 

그리고 마침내 ES6에서는 프로미스가 자바스크립트 언어에 포함됐다. 자바스크립트 언어에서 지원하는 프로미스의 기능을 알아보자. 

#### 프로미스 이해하기

##### 콜백 패턴의 문제

자바스크립트에서는 비동기 프로그래밍의 한 가지 방식으로 콜백(callback) 패턴을 많이 사용했었다. 하지만 콜백 패턴은 콜백이 조금만 중첩돼도 코드가 상당히 복잡해지는 단점이 있다.

```jsx
function requestData1(callback) {
    // ...
    callback(data);
}
function requestData2(callback) {
    // ...
    callback(data);
}
function onSuccess1(data) {
    console.log(data);
    requestData2(onSuccess2);
}
function onSuccess2(data) {
    console.log(data);
    // ...
}
requestData1(onSuccess1);
```

콜백 패턴은 코드의 흐름이 순차적이지 않기 때문에 코드를 읽기가 상당히 힘들다. 코드의 흐름을 따라 가려면 가장 아래 행부터 시작해야 한다. 이 코드는 마지막 행 -> 3행 -> 11행 -> 7행 -> 13행 순서로 실행되기 때문에, 짧은 코드임에도 쉽게 읽히지 않는다. 

하지만 프로미스를 사용하면 코드가 순차적으로 실행되게 작성할 수 있다. 아래는 위의 코드를 프로미스로 작성한 예다. 

```jsx
requestData1()
	.then(data => {
    	console.log(data);
    	return requestData2();
	})
	.then(data => {
    	console.log(data);
    	// ...
	});
```

프로미스를 사용하면 비동기 프로그래밍을 할 때 코드를 순차적으로 작성할 수 있다. 

##### 프로미스의 세 가지 상태

프로미스는 다음 세 가지 상태 중 하나의 상태로 존재한다. 

+ 대기 중(pending): 결과를 기다리는 중
+ 이행됨(fulfilled): 수행이 정상적으로 끝났고 결괏값을 가지고 있음
+ 거부됨(rejected): 수행이 비정상적으로 끝났음

이행됨, 거부됨 상태를 처리됨(settled) 상태라고 부른다. 프로미스는 처리됨 상태가 되면 더 이상 다른 상태로 변겨되지 않는다. 대기 중 상태일 때만 이행됨 또는 거부됨 상태로 변할 수 있다. 

##### 프로미스를 생성하는 방법

프로미스는 다음 세 가지 방식으로 생성할 수 있다. 

```jsx
const p1 = new Promise((resolve, reject) => {
    // ...
    // resolve(data)
    // or reject('error message')
});
const p2 = Promise.reject('error message');
const p3 = Promise.resolve(param);
```

1행은 일반적으로 new 키워드를 사용해서 프로미스를 생성한다. 이 방법으로 생성된 프로미스는 대기 중 상태가 된다. 생성자에 입력되는 함수는 resolve와 reject라는 콜백 함수를 매개변수로 갖는다. 비동기로 어떤 작업을 수행 후 성공했을 때 resolve를 호출하고, 실패했을 때 reject를 호출하면 된다. resolve를 호출하면 p1 객체는 이행됨 상태가 된다. 반대로 reject를 호출하면 거부됨 상태가 된다. 만약 생성자에 입력된 함수 안에서 예외(exception)가 발생하면 거부됨 상태가 된다. new 키워드를 사용해서 프로미스를 생성하는 순간 생성자의 입력 함수가 실행된다. 만약 API 요청을 보내는 비동기 코드가 있다면 프로미스가 생성되는 순간에 요청을 보낸다. 

6행은 키워드를 사용하지 않고 Promise.reject를 호출하면 거부됨 상태인 프로미스가 생성된다. 

7행은 Promise.resolve를 호출해도 프로미스가 생성된다. 만약 입력값이 프로미스였다면 그 객체가 그대로 반환되고, 프로미스가 아니라면 이행됨 상태인 프로미스가 반환된다. 

다음은 Promise.resolve의 인수가 프로미스인 경우와 아닌 경우의 반환값을 보여준다. 

```jsx
const p2 = new Proise(resolve => setTimeout(() => resolve(10), 1));
console.log(Promise.resolve(p2) === p2); // true
```

2행에서는 프로미스가 아닌 인수와 함께 Promise.resolve 함수를 호출하면 그 값 그대로 이행됨 상태인 프로미스가 반혼된다. p1은 123을 데이터로 가진 프로미스다. Promise.resolve 함수에 프로미스가 입력되면 그 자신이 반환된다. 

##### 프로미스 이용하기 1: then

then은 처리됨 상태가 된 프로미스를 처리할 때 사용하는 메서드다. 프로미스가 처리됨 상태가 되면 then 메서드의 인수로 전달된 함수가 호출된다. 다음은 then 메서드의 사용법을 보여 주는 코드다.

```jsx
requestData().then(onResolvem onReject);
Promise.resolve(123).then(data => console.log(data)); // 123
Promise.reject('err').then(null, error => console.log(error)); // 에러 발생
```

1행은 프로미스가 처리됨 상태가 되면 onResolve 함수가 호출되고, 거부됨 상태가 되면 onReject 함수가 호출된다. 

then 메서드는 항상 프로미스를 반환한다. 따라서 하나의 프로미스로부터 연속적으로 then 메서드를 호출할 수 있다. 

```jsx
requestData1()
	.then(data => {
    	console.log(data);
    	return requestData2();
	})
	.then(data => {
    	return data + 1;
	})
	.then(data => {
    	throw new Error('some error');
	})
	.then(null, error => {
    	console.log(error);
	});
```

4행의 onResolve 또는 onReject 함수에서 프로미스를 반환하면 then 메서드는 그 값을 그대로 반환한다. 만약 프로미스가 아닌 값을 반환하면 then 메서드는 이행됨 상태인 프로미스를 반환한다. onResolve 또는 onReject 함수 내부에서 예외가 발생하면 then 메서드는 거부됨 상태인 프로미스를 반환한다. 결과적으로 then 메서드는 항상 프로미스를 반환한다. 

프로미스가 거부됨 상태인 경우에는 onReject 함수가 존재하는 then을 만날 때까지 이동한다. 

```jsx
Promise.reject('err')
	.then(() => console.log('then 1'))
	.then(() => console.log('then 2'))
	.then(() => console.log('then 3'), () => console.log('then 4'))
	.then(() => console.log('then 5'), () => console.log('then 6'));
```

거부됨 상태인 프로미스는 처음으로 만나는 onReject 함수를 호출하므로 2~3행 코드 블록은 생략되고 4행의 then 4가 출력된다. then 4를 출력하는 onReject 함수는 undefined를 결과로 가지면서 이행됨 상태인 프로미스를 생성한다. 따라서 이어지는 then 메서드에는 then 5가 출력된다. then 메서드의 가장 중요한 특징은 항상 연결된 순서대로 호출된다는 점이다. 이 특징 덕에 프로미스로 비동기 프로그래밍을 할 때 동기 프로그래밍 방식으로 코드를 작성할 수 있다. 

##### 프로미스 이용하기 2: catch

catch는 프로미스 수행 중 발생한 예외를 처리하는 메서드다. catch 메서드는 then 메서드의 onReject 함수와 같은 역할을 한다. 

다음은 동일한 기능을 then 메서드와 catch 메서드로 각각 구현한 코드다. 

```jsx
Promise.reject(1).then(null, error => {
    console.log(error);
});
Promise.reject(1).catch(error => {
    console.log(error);
});
```

예외 처리는 then 메서드의 onReject 함수보다는 catch 메서드를 이용하는 게 가독성 면에서 더 좋다. 

다음은 onReject 함수에서 예외를 처리할 때 발생하는 문제를 보여 준다. 

```jsx
Promise.resolve().then(
	() => {
        throw new Error('some error');
    },
    error => {
        console.log(error);
    }
);
```

then 메서드의 onResolve 함수에서 발생한 예외는 같은 then 메서드의 onReject 함수에서 처리되지 않는다. 위 코드를 실행하면 Unhandle promise rejection 에러가 발생한다. 거부됨 상태인 프로미스를 처리하지 않았기 때문이다. 코드를 다음과 같이 수정하면 이 문제는 해결된다. 

```jsx
Promise.resolve()
	.then(() => {
    	throw new Error('some error');
	})
	.catch(error => {
    	console.log(error);
	});
```

프로미스에서 예외 처리를 할 때는 then 메서드의 onReject 함수보다는 좀 더 직관적인 catch 메서드를 이용할 것을 추천한다. 

then 메서드와 마찬가지로 catch 메서드도 새로운 프로미스를 반환한다. 따라서 다음처럼 catch 메서드 이후에도 계속해서 then 메서드를 사용할 수 있다. 

```jsx
Promise.reject(10)
	.then(data => {
    	console.log('then1: ', data);
    	return 20;
	})
	.catch(error => {
    	console.log('catch: ', error);
    	return 30;
	})
	.then(data => {
    	console.log('then2: ', data);	
	});
// catch: 10
// then2: 30
```

##### 프로미스 이용하기 3: finally

finally는 프로미스가 이행됨 또는 거부됨 상태일 때 호출되는 메서드다. 이 메서드는 2018년에 자바스크립트 표준으로 채택됐다. finally 메서드는 다음과 같이 프로미스 체인의 가장 마지막에 사용된다.

```jsx
requestData()
	.then(data => {
    	// ...
	})
	.catch(error => {
    	// ...
	})
	.finally(() => {
    	// ...
	});
```

finally 메서드는 .then(onFinally, onFinally) 코드와 유사하지만, 이전에 사용된 프로미스를 그대로 반환한다는 점이 다르다. 따라서 처리됨 상태인 프로미스의 데이터를 건드리지 않고 추가 작업을 할 때 유용하게 사용될 수 있다. 다음은 데이터 요청의 성공, 실패 여부와 상관없이 서버에 로그를 보낼 떄 finally 메서드를 사용한 코드다. 

```jsx
function requestData() {
    return fetch()
    	.catch(error => {
        	// ...
  	 	})
    	.finally(() => {
        	sendLogToServer('requestData finished');
    	});
}
requestData().then(data => console.log(data));
```

requestData 함수의 반환값은 finally 메서드 호출 이전의 프로미스다. 따라서 requestData 함수를 사용하는 입장에서는 finally 메서드의 존재 여부를 신경 쓰지 않아도 된다. 

#### 프로미스 활용하기

##### 병렬로 처리하기: Promise.all

Promise.all은 여러 개의 프로미스를 병렬로 처리할 때 사용하는 함수다. then 메서드를 체인으로 연결하면 각각의 비동기 처리가 병렬로 처리되지 않는다는 단점이 있다. 

다음과 같이 여러 개의 비동기 함수를 then 메서드로 연결하면 순차적으로 실행된다. 

```jsx
requestData1() 
	.then(data => {
    	console.log(data);
    	return requestData2();
	})
	.then(data => {
    	console.log(data);	
	})
```

비동기 함수 간에 서로 의존성이 없다면 병렬로 처리하는 게 더 빠르다. then 메서드를 체인으로 연결하지 않고 다음과 같이 비동기 함수를 호출하면 병렬로 처리된다. 

```jsx
requestData1().then(data => console.log(data));
requestData2().then(data => console.log(data));
```

위 코드에서 requestData1, requestData2 두 함수는 동시에 실행된다. 이렇게 여러 프로미스를 병렬로 처리하고 싶은 경우에 다음과 같이 Promise.all을 사용할 수 있다. 

```jsx
Promise.all([requestData1(), requestData2()]).then(([data1, data2]) => {
    console.log(data1, data2);
})
```

Promise.all 함수는 프로미스를 반환한다. Promise.all 함수가 반환하는 프로미스는 입력된 모든 프로미스가 처리됨 상태가 되어야 마찬가지로 처리됨 상태가 된다. 만약 하나라도 거부됨 상태가 된다면 Promise.all 함수가 반환하는 프로미스도 거부됨 상태가 된다. 

##### 가장 빨리 처리된 프로미스 가져오기: Promise.rase

Promise.race는 여러 개의 프로미스 중에서 가장 빨리 처리된 프로미스를 반환하는 함수다. Promise.race 함수에 입력된 여러 프로미스 중에서 하나라도 처리됨 상태가 되면, Promise.race 함수가 반환하는 프로미스도 처리됨 상태가 된다. 

다음 코드는 Promise.race 함수의 사용법을 보여 준다. 

```jsx
Promise.race([
    requestData(),
    new Promise((_, reject) => setTimeout(reject, 3000)),
])
	.then(data => console.log(data));
	.catch(error => console.log(error));
```

requestData 함수가 3초 안에 데이터를 받으면 true 메서드가 호출되고, 그렇지 않으면 catch 메서드가 호출된다.

##### 프로미스를 이용한 데이터 캐싱

처리됨 상태가 되면 그 상태를 유지하는 프로미스의 성질을 이용해서 데이터를 캐싱할 수 있다. 다음은 프로미스를 이용해서 데이터를 캐싱하는 코드다. 

```jsx
let cachedPromise;
function getData() {
    cachedPromise = cachedPromise || requestData();
    return cachedPromise;
}

getData().then(v => console.log(v));
getData().then(v => console.log(v));
```

3행에서 getData 함수를 처음 호출할 때만 requestData가 호출된다. 데이터를 가져오는 작업이 끝나면 그 결과는 cachedPromise 프로미스에 저장된다. 데이터를 가져오는 작업에 실패하는 경우가 고려되지 않았지만, 지금은 프로미스로 캐싱을 구현할 수도 있다는 점만 기억면 된다. 

#### 프로미스 사용 시 주의할 점

##### return 키워드 깜빡하지 않기

then 메서드 내부 함수에서 return 키워드를 입력하는 것을 깜빡하기 쉽다. then 메서드가 반환하는 프로미스 객체의 데이터는 내부 함수가 반환한 값이다. return 키워드를 사용하지 않으면 프로미스 객체의 데이터는 undefined가 된다. 

다음 코드는 then 메서드 내부에서 return 키워드를 깜빡한 경우를 보여 준다. 

```jsx
Promise.resolve(10)
	.then(data => {
    	console.log(data);
    	Promise.resolve(20);
	})
	.then(data => {
    	console.log(data);
	});
```

의도와는 다르게 undefined가 출력된다. 4행의 코드에서 return 키워드를 입력하면 의도한 대로 20이 출력된다. 

##### 프로미스는 불변 객체라는 사실 명심하기

프로미스는 불변 객체다. 이를 인지하지 못하고 코드를 작성하면 다음과 같은 실수를 할 수 있다. 

```jsx
function requestData() {
    const p = Promise.resolve(10);
    p.then(() => {
        return 20;
    });
    return p;
}
requestData().then(v => {
    console.log(v); // 10
});
```

3행에서 then 메서드는 기존 객체를 수정하지 않고, 새로운 프로미스를 반환한다. console에서 20이 출력되길 원한다면 request 함수를 다음과 같이 수정해야 한다. 

```jsx
function requestData() {
    return Promise.resolve(10).then(v => {
        return 20;
    });
}
```

##### 프로미스를 중첩해서 사용하지 않기

프로미스를 중첩해서 사용하면 콜백 패턴처럼 코드가 복잡해지므로 사용을 권장하지 않는다. 무심결에 다음 코드와 같이 중첩해서 사용하기 쉽다. 

```jsx
requestData1().then(result1 => {
    requestData2(result1).then(result2 => {
        // ...
    });
});
```

위의 코드보다는 다음과 같이 사용하는 게 좋다. 

```jsx
requestData1() 
	.then(result1 => {
    	return requestData2(result1);
    .then(result2 => {
        // ...
    })
})
```

만약 5행에서 result1 변수를 참조해야 한다면 어떻게 해야 할까? Promise.all 함수를 사용하면 프로미스를 중첩하지 않고도 다음과 같이 해결할 수 있다. 

```jsx
requestData1()
	.then(result1 => {
    	return Promise.all([result1, requestData2(result1)]);
	})
	.then(([result1, result2]) => {
    	// ...
	});
```

Promise.all 함수로 입력하는 배열에 프로미스가 아닌 값을 넣으면, 그 값 그대로 이행됨 상태인 프로미스처럼 처리된다. 

##### 동기 코드의 예외 처리 신경 쓰기

프로미스를 동기(sync) 코드와 같이 사용할 때는 예외 처리에 신경 써야 한다. 다음과 같이 동기 함수에서 예외가 발생하는 경우에는 이 예외를 처리하는 곳이 없어서 문제가 된다. 

```jsx
function requestData() {
    doSync();
    return fetch()
    	.then(data => console.log(data))
    	.catch(error => console.log(error));
}
```

이제 doSync에서 발생하는 예외는 catch 메서드에서 처리가 된다. 

### 향상된 비동기 프로그래밍 2: async await

async await는 비동기 프로그래밍을 동기 프로그래밍처럼 작성할 수 있도록 함수에 추가된 기능이다. 프로미스가 자바스크립트 표준이 되고 2년 후(ES2017)에 async await도 자바스클비트 표준이 되었는데, async await를 이용해서 비동기 코드를 작성하면 프로미스의 then 메서드를 체인 형식으로 호출하는 것보다 가독성이 좋아진다. 그렇다고 async await가 프로미스를 완전히 대체하는 것은 아니다. 프로미스는 비동기 상태를 값으로 다룰 수 있기 때문에 async await보다 큰 개념이다. 

지금부터 async await의 개념을 알아보고 프로미스로 작성한 비동기 코드와 어떻게 다른지 비교해 보자.

#### async await 이해하기

프로미스는 객체로 존재하지만 async await는 함수에 적용되는 개념이다. 다음과 같이 async await 함수는 프로미스를 반환한다.

```jsx
async function getData() {
    return 123;
}
getData().then(data => console.log(data)); // 123
```

async 키워드를 이용해서 정의된 함수는 async await 함수이며, 항상 프로미스를 반환한다. 따라서 함수 호출 후 then 메서드를 사용할 수 있다. 

async await 함수 내부에서 프로미스를 반환하는 경우를 살펴보자.

```jsx
async function getData() {
    return Promise.resolve(123);
}
getData().then(data => console.log(data)); // 123
```

프로미스의 then 메서드와 마찬가지로 async await 함수 내부에서 반환하는 값이 프로미스라면 그 객체를 그대로 반환한다. 

다음과 같이 async await 함수 내부에서 예외가 발생하는 경우에는 거부됨 상태인 프로미스가 반환된다.

```jsx
async function getData() {
    throw new Error('123');
}
getData().catch(error => console.log(error)); // 에러 발생: 123
```

##### await 키워드를 사용하는 방법

await 키워드는 async await 함수 내부에서 사용된다. await 키워드 오른쪽에 프로미스를 입력하면 그 프로미스가 처리됨 상태가 될 때까지 기다린다. 따라서 await 키워드로 비동기 처리를 기다리면서 순차적으로 코드를 작성할 수 있다. 

다음은 await 키워드를 사용한 예다.

```jsx
function requestData(value) {
    return new Promise(resolve => 
   		setTimeout(() => {
        	console.log('requestData:', value);
        	resolve(value);
    	}, 100),
    );
}

async function getData() {
    const data1 = await requestData(10);
  	const data2 = await requestData(20);
    console.log(data1, data2);
    return [data1, data2];
}
getData();
// requestData: 10
// requestData: 20
// 10 20
```

getData() 함수에서 request 함수가 반환하는 프로미스가 처리됨 상태가 될 때까지 console 출력은 실행되지 않는다. 따라서 getData 함수를 호출한 결과는 맨 아래와 같다. 

await 키워드는 오직 async await 함수 내에서만 사용될 수 있다. 다음과 같이 await 키워드를 일반 함수에서 사용하면 에러가 발생한다. 

```jsx
function getData() {
    const data = requestData(10); // 에러 발생
    console.log(data);
}
```

##### async await는 프로미스보다 가독성이 좋다

async await와 프로미스는 비동기 프로그래밍을 동기 프로그래밍 방식으로 작성할 수 있게 해 준다. 다음 코드는 async await와 프로미스를 비교하기 위해 같은 기능을 각각의 방식으로 구현한 것이다. 

```jsx
function getDataPromise() {
    asyncFunc1()
    	.then(data => {
       		console.log(data);
        	return asyncFunc2();
    	})
    	.then(data => {
        	console.log(data);
   	 	});
}

async function getDataAsync() {
    const data1 = await asyncFunc1();
    console.log(data1);
    const data2 = await asyncFunc2();
    console.log(data2);
}
```

첫 번째는 프로미스로 작성한 함수다. 두 번째의 async await 함수는 then 메서드를 호출할 필요가 없기 때문에 더 간결한다. 

비동기 함수 간에 의존성이 높아질수록 async await와 프로미스의 가독성 차이는 더 선명하게 드러난다. 다음은 서로 의존성이 있는 여러 비동기 함수의 처리를 각각 async await와 프로미스로 작성한 코드다. asyncFunc1, asyncFunc2, asyncFunc3 세 함수는 각각의 반환값을 다른 함수의 인수로 넣으면서 의존성을 가지고 있다. 

```jsx
function getDataPromise() {
    return asyncFunc1()
    	.then(data1 => Promise.all([data1, asyncFunc2(data1)]))
    	.then(([data1, data2]) => {
        	return asyncFunc3(data1, data2);
    	});
}
async function getDataAsync() {
    const data1 = await asyncFunc1();
    const data2 = await asyncFunc2(data1);
    return asyncFunc3(data1, data2);
}
```

3행의 두 반환 값을 asyncFunc3 함수에 전달하기 위해 Promise.all을 사용했다. getDataAsync()의 async await 함수는 복잡한 의존성이 존재함에도 코드가 직관적이다. 

#### async await 활용하기

##### 비동기 함수를 병렬로 실행하기

async await 함수에서 여러 비동기 함수를 병렬로 처리하는 방법을 알아보자. 다음과 같이 여러 비동기 함수에 각각 await 키워드를 사용해서 호출하면 순차적으로 실행된다.

```jsx
async function getData() {
    const data1 = await asyncFunc1();
    const data2 = await asyncFunc2();
    // ...
}
```

앞의 코드에서 두 함수 사이에 의존성이 없어진다면 동시에 실행하는 게 더 좋다. 프로미스는 생성과 동시에 비동기 코드가 실행된다. 따라서 두 개의 프로미스를 먼저 생성하고 await 키워드를 나중에 사용하면 병렬로 실행되는 코드가 된다. 

```jsx
async function getData() {
    const p1 = asyncFunc1();
    const p2 = asyncFunc2();
    const data1 = await p1;
    const data2 = await p2;
}
```

두 개의 프로미스가 생성되고 각자의 비동기 코드가 실행된다. 두 프로미스가 생성된 후 기다리기 때문에 두 개의 비동기 함수가 병렬로 처리된다. 

아래의 코드처럼 Promise.all을 사용하면 다음과 같이 더 간단해진다. 

```jsx
async function getData() {
    const [data1, data2] = await Promise.all([asyncFunc1(), asyncFunc2()]);
    // ...
}
```

##### 예외 처리하기 

async await 함수에서 예외를 처리하는 방법을 알아보자. async await 함수 내부에서 발생하는 예외는 다음과 같이 try catch 문으로 처리하는 게 좋다. 

```jsx
async function getData() {
    try {
        await doAsync();
        return doSync();
    } catch(error) {
        console.log(error);
    }
}
```

3행의 비동기 함수와 4행의 동기 함수에서 발생하는 모든 예외가 catch 문에서 처리된다. 만약 getData가 async await 함수가 아니었다면 doAsync 함수에서 발생하는 예외는 catch 문에서 처리되지 않는다. 이는 doAsync 함수의 처리가 끝나는 시점을 알 수 없기 때문이다. 

##### Thenable을 지원하는 async await

Thenable은 프로미스처럼 동작하는 객체다. 프로미스가 ES6에 등장하기 이전부터 이미 여러 프로미스 라이브러리가 나왔다. 많은 개발자가 이러한 라이브러리를 사용해서 ES6 이전부터 프로미스를 사용해 왔다. async await는 ES6의 프로미스가 아니더라도 then 메서드를 가진 객체를 프로미스처럼 취급한다. 이렇게 ES6의 프로미스가 아니더라도 then 메서드를 가진 객체를 Thenable이라고 부른다. 

다음 코드의 ThenableExample 클래스로 생성한 객체는 Thenable이다. await 키워드와 함께 Thenable을 사용할 수 있다. 

```jsx
class ThenableExample {
    then(resolve, reject) {
        setTimeout(() => resolve(123), 1000);
    }
}
async function asyncFunc() {
    const result = await new ThenableExample();
    console.log(result); // 123
}
```

ThenableExample 클래스는 then 메서드를 갖고 있으므로, ThenableExample 클래스로 생성된 객체는 Thenable이다. async await 함수는 Thenable도 프로미스처럼 처리한다. 

### 템플릿 리터럴로 동적인 문자열 생성하기

ES6에 추가된 템플릿 리터럴(template literals)은 변수를 이용해서 동적으로 문자열을 생성할 수 있는 문법이다. ES6 이전에 동적으로 문자열을 생성할 때는 다음과 같은 코드를 사용했다. 

```jsx
var name = 'mike';
var score = 80;
var msg = 'name: ' + name + ', score/100: ' + score / 100;
```

더하기 기호와 따옴표를 반복적으로 사용해서 문자열을 생성한다. 이 방식은 더하기 기호와 따옴표를 입력하느라 코드를 작성하는 시간이 오래 걸린다. 그리고 코드를 읽는 입장에서는 따옴표의 묶음을 잘 인지해야 하므로 가독성이 떨어진다. 

아래는 위의 msg 변수를 템플릿 리터럴로 변경한 코드다. 

```jsx
const msg = `name: ${name}, score/100: ${score / 100}`;
```

템플릿 리터럴은 백틱(``)을 이용한다. 표현식(expression)을 사용할 때는 ${expression} 형식으로 입력한다. 

##### 여러 줄의 문자열 입력하기

템플릿 리터럴을 사용하면 여러 줄의 문자열을 생성하기 쉽다. ES6 이전에는 여러 줄의 문자열을 생성하기 위해서 다음과 같이 작성했다. 

```jsx
const msg = 'name: ' + name + '\n' + 'age: ' + age + '\n' + 'score: ' + score + '\n';
```

줄의 끝에 \n 기호를 입력하면 줄 바꿈이 된다. 이 방법 외에도 역슬래시(`\`)를 이용한 방법이 있지만 표현식이 들어가는 경우 복잡해지는 건 마찬가지다. 

다음과 같이 템플릿 리터럴을 이용하면 여러 줄의 문자열을 생성할 때 좀 더 자연스러운 방식으로 작성할 수 있다. 

```jsx
const msg = `name: ${name} age: ${age} score: ${score}`;
```

줄의 끝에 \n 기호를 입력할 필요가 없다. 이전의 ES5 코드와 비교해 보면 코드 입력 속도와 가독성 면에서 템플릿 리터럴이 우수하다는 것을 알 수 있다. 

> **태그된 템플릿 리터럴**
>
> 태그된 템플릿 리터럴(tagged template literals)은 템플릿 리터럴을 확장한 기능이다. 태그된 템플릿 리터럴은 함수로 정의된다. 사용할 때는 다음과 같이 함수명과 함께 템플릿 리터럴을 붙여서 작성한다.
>
>  ```jsx
> function taggedFunc(strings, ...expressions) {
>     return 123;
> }
> const v1 = 10;
> const v2 = 20;
> const result = taggedFunc`a ${v1} b ${v2}`;
> console.log(result); // 123
>  ```
>
> taggedFunc는 태그된 템플릿 리터럴 함수다. const result를 선언하여 taggedFunc 함수를 호출한다. 우리가 알고 있는 함수 호출과는 문법이 다르기 때문에 어색할 수 있다. 태그된 템플릿 리터럴 함수는 함수명과 함께 템플릿 리터럴을 붙여서 사용한다. 함수명 오른쪽의 템플릿 리터럴을 파싱한 결과가 1행의 strings, expressions 매개변수로 들어간다. 
>
> 템플릿 리터럴의 표현식을 기준으로 문자열이 분할되어 strings 매개변수에 배열로 들어간다. 지금부터 여러 가지 예제를 통해 strings, expressions 매개변수의 값이 어떻게 만들어지는지 살펴보자. 
>
> ```jsx
> const v1 = 10;
> const v2 = 20;
> 
> taggedFunc`a-${v1}-b-${v2}-c`;
> // strings = [ 'a-', '-b-', '-c' ];
> 
> taggedFunc`a-${v1}-b-${v2}`;
> // strings = [ 'a-', '-b-', '' ];
> 
> taggedFunc`${v1}-b-${v2}`;
> // strings = [ '', '-b-', '' ];
> 
> // expressions = [10, 20];
> 
> function taggedFunc(strings, ...expressions) {
>     console.log(strings.length === expressions.length + 1); // true
> }
> ```
>
> 첫 번째 taggedFunc는 두 개의 표현식을 기준으로 세 개의 문자열로 분할된다. 두 번째 taggedFunc는 템플릿 리터럴 오른쪽이 표현식으로 끝나면 빈 문자열이 들어간다. 세 번째 taggedFunc도 마찬가지로 템플릿 리터럴 왼쪽이 표현식으로 시작하면 빈 문자열이 들어간다. 위 세 가지 예제 모두 expressions 매개변수의 값은 같다. 두 번째 taggedFunc의 strings 배열의 개수는 expressions 배열의 개수보다 항상 하나 더 많다.
>
> 태그된 템플릿 리터럴은 일부 문자열을 강조하고 싶을 때도 쓸 수 있다. 다음은 expressions 매개변수로 전달된 문자열을 HTML strong 태그로 감싸 주는 함수다. 
>
> ```jsx
> function highlight(strings, ...expressions) {
>     return strings.reduce(
>     	(prevValue, str, i) => 
>         	expressions.length === i
>         	? `${prevValue}${str}`
>         	: `${prevValue}${str}<strong>${expressions[i]}</strong>`,
>         '',
>     );
> }
> 
> const v1 = 10;
> const v2 = 20;
> const result = highlight`a ${v1} b ${v2}`;
> console.log(result); // a <strong>10</strong> b <strong>20</strong>
> ```
>
> 태그된 템플릿 리터럴 함수의 반환값이 꼭 문자열일 필요는 없다. styled-components 패키지에서는 태그된 템플릿 리터럴 함수가 리액트 컴포넌트를 반환한다. 