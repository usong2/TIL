## 바벨과 웹팩 자세히 들여다보기

바벨(babel)과 웹팩(webpack)은 웹 애플리케이션을 제작할 때 없어서는 안되는 기반 기술이 되었다. 리액트 또는 뷰(vue)를 기반으로 프로젝트를 구축해 주는 create-react-app, next.js, vue-cli, nuxt 등의 도구는 바벨과 웹팩을 기본적으로 포함한다.

물론 도구의 도움을 받아서 자동으로 프로젝트를 구축하면 바벨과 웹팩을 모르더라도 간단한 웹 애플리케이션을 제작할 수 있다. 리액트와 뷰를 처음 배우는 단계에서는 바벨과 웹팩을 모르는 편이 나을 수도 있다. 하지만 프로젝트의 규모가 점점 커지는 상황에서 바벨과 웹팩을 계속해서 외면하기는 힘들다. 제스트(jest)와 같은 테스트 프레임워크를 도입할 때, 스토리북(storybook)과 같이 별도의 빌드 과정이 필요할 때, 서버사이드 렌더링을 위해서 서버 측 코드를 빌드해야 할 때 등 바벨과 웹팩을 이해해야만 하는 순간이 반드시 온다.

바벨과 웹팩의 주요 개념과 기본적인 사용법을 설명한다. 그리고 바벨의 플러그인, 웹팩의 로더와 플러그인을 직접 제작해 보면서 바벨과 웹팩의 내부 동작에 대한 이해를 돕는다.

### 바벨 실행 및 설정하기

리액트로 개발을 하다 보면 개발자 대부분이 바벨 설정 때문에 애를 먹는다. 바벨을 제대로 이해하지 못하면 인터넷에 떠도는 바벨 설정을 무분별하게 가져오기 쉽다. 그렇게 가져온 설정으로 한동안은 잘 돌아가는 듯 보이지만 예상치 못한 상황에서 문제가 발생하기 마련이다. 여기서는 바벨을 설정하는 여러 가지 방법을 알아보고, 각자의 프로젝트에 적합한 설정을 무엇인지 고민해 보자. 

또한 폴리필은 무엇이고 바벨에서 어떻게 설정하는지 알아보기로 한다. 바벨과 폴리필의 관계를 이해하지 못하면 오래된 브라우저에서 에러가 발생하는 코드가 만들어질 수 있다. core-js 패키지와 @babel/preset-env 프리셋을 통해 폴리필을 관리하는 방법을 알아보자. 

#### 바벨을 실행하는 여러 가지 방법

바벨은 다음과 같이 다양한 방식으로 실행될 수 있다.

+ @babel/cli로 실행하기
+ 웹팩에서 babel-loader로 실행하기
+ @babel/core를 직접 실행하기
+ @babel/register로 실행하기

@babel/register를 이용하면 노드(Node.js)에서 require 코드가 실행될 때 동적으로 바벨이 실행되게 할 수 있다. 리액트를 @babel/register와 함께 사용하는 경우는 많지 않으므로 @babel/register를 제외한 나머지 세 방식을 설명한다. 

> **바벨이란?**
>
> 바벨은 입력과 출력이 모두 자바스크립트 코드인 컴파일러다. 이는 보통의 컴파일러가 고수준의 언어를 저수준의 언어로 변환하는 것과 비교된다.
>
> 초기의 바벨은 ES6 코드를 ES5 코드로 변환해 주는 컴파일러였다. 현재는 바벨을 이용해서 리액트으 JSX 문법, 타입스크립트와 같은 정적 타입 언어, 코드 압축, 제안(proposal) 단계에 있는 문법 등을 사용할 수 있다.

실습을 위한 프로젝트를 생성해 보자.

```bash
$ mkdir test-babel-how
$ cd test-babel-how
$ npm init -y
```

먼저 필요한 패키지를 설치하자.

```bash
$ npm install @babel/core @babel/cli @babel/plugin-transform-arrow-functions @babel/plugin-transform-template-literals @babel/preset-react
```

바벨을 실행하기 위해서는 @babel/core 패키지를 필수로 설치해야 한다. 두 개의 플러그인과 프리셋 하나를 추가로 설치했다. 

이제 컴파일할 코드를 작성해 보자. 프로젝트 루트에 src 폴더를 만들고 그 밑에 code.js 파일을 만들자. code.js 파일의 내용은 다음과 같다.

```jsx
const element = <div>babel test</div>;
const text = `element type is ${element.type}`;
const add = (a, b) => a + b;
```

1행은 리액트 프리셋을 이용해서 JSX 문법을 변환할 예정이다. 2행은 템플릿 리터럴 플러그인을 이용해서 템플릿 리터럴 코드를 변환할 예정이다. 3행은 화삺 ㅛ함수 플러그인을 사용해서 화살표 함수를 변환할 예정이다. 

##### @babel/cli로 실행하기

이제 @babel/cli로 바벨을 실행할 준비가 끝났다. 다음 명령어를 실행해 보자.

```bash
$ npx babel src/code.js --presets=@babel/preset-react --plugins=@babel/plugin-transform-template-lterals,@babel/plugin-transform-arrow-functions
```

이렇게 바벨을 실행하면 콘솔에 다음 내용이 출력된다.

```jsx
const element = React.createElement("div", null, "babel test");
const text = "element type is ".concat(element.type);

const add = function (a, b) {
    return a + b;
};
```

1행에서 JSX 문법은 createElement 함수 호출로 변환된다. 2행에서 템플릿 리터럴 문자열의 concat 메서드 호출로 변환된다. 4행에서 화살표 함수는 일반 함수로 변환된다. 

@babel/cli로 거의 모든 설정값을 표현할 수 있지만, 설정할 내용이 많거나 실행 환경에 따라 설정값이 다른 경우에는 설정 파일을 따로 만드는 게 좋다. 바벨6까지는 .babelrc 파일로 설정값을 관리했지만, 바벨 7부터는 babel.config 파일로 관리하는 것을 추천한다. 

프로젝트 루트에 babel.config.js 파일을 만든 다음 내용을 입력해 보자.

```jsx
const presets = ['@babel/preset-react'];
const plugins = [
    '@babel/plugin-transform-template-literals',
    '@babel/plugin-transform-arrow-functions',
];

module.exports = { presets, plugins };
```

앞에서 @babel/cli 명령어로 입력했던 설정과 같은 내용이다. 자바스크립트 파일이기 때문에 동적으로 설정값을 만들 수 있다. 참고로 바벨 6에서는 .babelrc.js 파일로 위 코드처럼 작성할 수 있다.

이제 명령어는 다음과 같이 간소화된다.

```bash
$ npx babel src/code.js
```

컴파일된 결과를 파일로 저장하고 싶다면 다음과 같이 입력해 보자.

```bash
$ npx babel src/code.js --out-file-dist.js
$ npx babel src --out-dir dist
```

첫 번째 명령어는 파일 단위로 처리하고, 두 번째 명령어는 폴더 단위로 처리한다.

##### 웹팩의 babel-loader로 실행하기

두 번째 방법은 웹팩의 babel-loader로 실행하는 것이다. 웹팩을 이용하기 위해 다음과 같이 추가로 패키지를 설치해 보자.

```bash
$ npm install webpack webpack-cli babel-loader
```

프로젝트 루트에 webpack.config.js 파일을 만들고, 다음 내용을 입력한다.

```jsx
const path = require('path');

module.exports = {
    entry: './src/code.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'code.bundle.js',
    },
    module: {
        rules: [{ test: /\.js$/, use: 'babel-loader' }],
    },
    optimization: { minimizer: [] }, 
};
```

웹팩으로 번들링(bundling)할 파일을 지정한다. 번들링된 결과를 dist/code.bundle.js 파일로 저장한다. 자바스크립트 파일을 babel-loader가 처리하도록 설정한다.  babel-loader는 바벨의 설정 파일을 이용하므로 이전에 만들어 놓은 babel.config.js 파일의 내용이 설정값으로 사용된다. 웹팩은 기본적으로 자바스크립트 파일을 압축한다. 그렇지만 바벨이 제대로 실행됐는지 확인하기 위해 압축 기능을 잠시 끄기로 한다.

이제 웹팩을 실행해 보자.

```bash
$ npx webpack
```

생성된 dist/code.bundle.js 파일의 내용은 다음과 같다.

```jsx
// ...
const element = React.createElement("div", null, "babel test");
const text = "element type is ".concat(element.type);

const add = function (a, b) {
    return a + b;
};
// ...
```

파일의 앞부분에는 웹팩의 런타임 코드가 추가된다. 파일의 뒷부분에서는 바벨이 생성한 코드를 확인할 수 있다.

##### @babel/core를 직접 이용하기

이전에 살펴봤던 @babel/cli와 babel-loader는 모두 @babel/core를 이용해서 바벨을 실행한다. 이번에는 직접 @babel/core를 사용하는 코드를 작성해서 바벨을 실행해 보자.

먼저 프로젝트 루트에 runBabel.js 파일을 만들고, 다음 코드를 입력한다.

```javascript
const babel = require('@babel/core');
const fs = require('fs');

const filename = './src/code.js';
const source = fs.readFileSync(filename, 'utf8');
const presets = ['@babel/preset-react'];
const plugins = [
    '@babel/plugin-transform-template-literals',
    '@babel/plugin-transform-arrow-functions',
];
const { code } = babel.transformSync(source, {
    filename,
    presets,
    plugins,
    configFile: false,
});
console.log(code);
```

1행은 @babel/core 모듈을 가져온다. 5행은 컴파일할 파일의 내용을 가져온다. 6~10행에서 바벨 플러그인과 프리셋을 설정한다. 11행에서 babel.config.js 설정 파일을 사용하지 않도록 한다. 마지막 행에서 변환된 코드를 콘솔에 출력한다. 파일로 저장하기를 원한다면 fs 모듈을 이용하면 된다. 

다음 명령어를 실행하면 의도한 대로 잘 동작하는 것을 확인할 수 있다.

```bash
$ node runBabel.js
```

@babel/core 모듈을 직접 사용하는 방식은 자유도가 높다는 장점이 있다. 같은 코드에 대해 다음과 같이 두 가지 설정을 적용한다고 생각해 보자. 

```jsx
// 설정 1
const presets = ['@babel/preset-react'];
const plugins = ['@babel/plugin-transform-template-literals'];

// 설정 2
const presets = ['@babel/preset-react'];
const plugins = ['@babel/plugin-transform-arrow-functions'];
```

@babel/cli 또는 babel-loader를 이용한다면 바벨을 두 번 실행해야 한다. @babel/core를 사용하면 바벨을 좀 더 효율적으로 실행할 수 있다. 바벨은 컴파일 시 다음 세 단계를 거친다.

+ 파싱(parse) 단계: 입력된 코드로부터 AST(abstract syntax tree)를 생성한다.
+ 변환(transform) 단계: AST를 원하는 형태로 변환한다.
+ 생성(generate) 단계: AST를 코드로 출력한다.

AST는 코드의 구문(syntax)이 분석된 결과를 담고 있는 구조체다. 코드가 같다면 AST도 같기 때문에 같은 코드에 대해서 하나의 AST를 만들어 놓고 재사용할 수 있다. 

프로젝트 루트에 runBabel2.js 파일을 만들고, 다음 코드를 입력해 보자.

```jsx
const babel = require('@babel/core');
const fs = require('fs');

const filename = './src/code.js';
const source = fs.readFileSync(filename, 'utf8');
const presets = ['@babel/preset-react'];

const { ast } = babel.transformSync(source, {
    filename,
    ast: true,
    code: false,
    presets,
    configFile: false,
});

const { code: code1 } = babel.transformFormAstSync(ast, source, {
    filename,
    plugins: ['@babel/plugin-transform-tempalte-literals'],
    configFile: false,
});
const { code: code2 } = babel.transformFormAstSync(ast, source, {
    filename,
    plugins: ['@babel/plugin-transform-arrow-functions'],
    configFile: false,
});
console.log('code1:\n', code1);
console.log('code2:\n', code2);
```

코드는 생성하지 않고 AST만 생성한다. 프리셋은 두 가지 설정 모두 같으므로 AST를 만들 때 해당 프리셋을 미리 적용한다. 이렇게 만들어진 AST로부터 첫 번째 설정의 플러그인이 반영된 코드를 생성한다. 마찬가지로 두 번째 설정이 적용된 코드를 생성한다. 설정의 개수가 많아질수록 이 방식의 효율은 높아진다.

