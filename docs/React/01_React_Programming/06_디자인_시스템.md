# 디자인 시스템

## 01. 비주얼 테스트로 더 쉽게 개발하기

요즘 대부분의 웹 사이트들은 상황에 따라 오류 메시지나 로딩 화면을 출력하는데 이런 화면들은 화면 1개당 최소 2개의 화면을 구성해야 함. 예를 들어 오류가 있거나 없을 때 서로 다른 화면을 보여주어야 하므로 최소 2가지의 화면을 구성해야 함. 이처럼 상황에 맞게 컴포넌트를 제작하고 확인하는 작업은 번거로움

그래서 스토리북(react-storybook)이라는 비주얼 테스트를 위한 도구를 사용하는데 비주얼 테스트란 화면을 구성하는 컴포넌트들을 독립적으로 관리하고 변화를 살펴볼 수 있는 방법을 의미. 실제 가구를 집에 배치하기 전에 제품 사진만 따로 모아둔 책자에서 다양한 색상의 가구를 확인하는 것과 비슷함. 

### 스토리북 설치하고 사용해 보기

#### 1. 스토리북 설치하기

프로젝트의 루트폴더로 이동하여 다음 명령어를 실행하면 package.json에 자동으로 스토리북이 추가된 것을 확인 가능

```bash
$ yarn add --dev @storybook/react
```

#### 2. package.json에 스토리북 실행 명령어 추가하기

설치가 완료된 스토리북을 실행하기 위해서 package.json에 노드 명령어를 추가함. 
package.json의 scripts 블록은 npm 또는 yarn에서 실행할 명령어를 정의하는 곳이며 지금까지 리액트 서버를 구동시킬 때 사용한 yarn start라는 명령어도 이 블록의 명령어를 참조한 것

+ storybook 명령어가 스토리북 서버를 9001 포트를 통해 실행시킬 수 있도록 설정

  ```json
  // ./package.json
  
  ...
    "scripts": {
      "storybook": "start-storybook -p 9001 -c .storybook",
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test",
      "eject": "react-scripts eject"
    },
  ...
  ```

#### 3. 스토리 파일 만들기

스토리는 컴포넌트의 여러 출력 형태를 구성한 페이지인데 여기서는 다양한 형태의 Input 컴포넌트를 가지는 Input 스토리를 만들어봄. 

+ ./src에 stories 폴더를 생성 후 InputStory.jsx 파일을 생성

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from "react";
  import { storiesOf } from "@storybook/react";
  
  import Input from "../03/Input";
  
  storiesOf("Input", module).add("기본 설정", () => <Input />);
  ```

#### 4. 스토리북 config.js에 스토리 연결하기

만든 스토리 파일을 스토리북 config.js에 연결하려면 루트 폴더에 `.storybook`이라는 이름의 폴더가 필요.

+ .storybook 폴더 생성 후 config.js 파일 생성

  ```jsx
  // ./.storybook/config.js
  
  import { configure } from "@storybook/react";
  
  function loadStories() {
    require("../src/stories/InputStory");
    // 스토리 파일을 이곳에 추가할 수 있음
  }
  
  configure(loadStories, module);
  ```

#### 5. 스토리북 실행하기

터미널에서 다음과 같은 명령어 실행 

```bash
$ yarn storybook
```

명령어 실행이 완료되면 명령 프롬프트에 'Storybook 5.2.0 started...'와 같은 메시지가 출력되며, localhost:9001에서 자동으로 접속

#### 6. 스토리북 오류 메시지 수정하기

크롬 브라우저의 콘솔창을 보면 Input 컴포넌트의 필수 프로퍼티인 name이 없다는 오류 메시지가 나타나는데(Input 프로퍼티에서 프로퍼티 name을 isRequired로 정의), Input 스토리에서 add() 함수로 추가한 Input 컴포넌트에 name 프로퍼티를 추가하면 오류 메시지가 사라짐

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module).add('기본 설정', () => <Input name="name" />);
  ```

여기까지 진행하면 스토리북의 모든 설정 작업이 완료된 것

참조: [https://storybook.js.org/basics/guide-react/](https://storybook.js.org/basics/guide-react/)

<br>

### 스토리북 사용하기

스토리에 여러 형태의 컴포넌트를 추가하고, 새 스토리를 자동으로 스토리북에 연결

#### 1. 스토리에 다른 형태의 컴포넌트 추가하기

라벨이 있는 형태의 Input 컴포넌트를 Input 스토리에 추가

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module)
    .add('기본 설정', () => <Input name="name" />)
    .add('label 예제', () => <Input name="name" label="이름" />);
  ```

수정 후 저장하면 크롬 브라우저가 자동으로 새로고침되며 왼쪽 메뉴에 'label 예제' 컴포넌트가 추가

스토리에 여러 형태의 Input 컴포넌트를 추가할 수 있으므로 Input 컴포넌트가 포함된 실제 리액트 앱 화면을 직접 수정하여 확인하는 과정은 스토리북에서 하면 됨. 즉, 컴포넌트에 다양한 기능이나 디자인을 추가할 때는 스토리북을 사용

#### 2. 스토리 추가하기

새 스토리 추가

+ ./src/stories에 NewCounterStory.jsx 생성

  ```jsx
  // ./src/stories/NewCounterStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import NewCounter from '../03/NEwCounter';
  
  storiesOf('NewCounter', module).add('기본 설정', () => <NewCounter count={0} />);
  ```

#### 3. 스토리북에 스토리 추가하기

+ ./.storybook/config.js 수정

  ```jsx
  // ./.storybook/config.js
  
  import { configure } from '@storybook/react';
  
  function loadStories() {
    require('../src/stories/InputStory');
    // 스토리 파일을 이곳에 추가할 수 있음
    require('../src/stories/NewCounterStory');
  }
  
  configure(loadStories, module);
  ```

####  4. 스토리가 자동으로 스토리북에 추가되도록 config.js 설정하기

아래와 같이 수정하면 stories 폴더에 있는 파일 이름을 검사하여 '~Story.jsx'라고 끝나는 이름의 파일들을 config.js에 자동으로 추가 가능

+ ./.storybook/config.js 수정

  ```jsx
  import { configure } from '@storybook/react';
  import interopRequireDefault from 'babel-runtime/helpers/interopRequireDefault';
  
  function loadStories() {
    const context = require.context('../src/stories', true, /Story\.jsx$/);
    context.keys().forEach((srcFile) => {
      interopRequireDefault(context(srcFile));
    });
  }
  
  configure(loadStories, module);
  ```

#### 5. 스토리가 자동으로 스토리북에 추가되는지 확인해 보기

+ ./src/stories에 BooleanComponentStory.jsx 생성

  ```jsx
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import BooleanComponent from '../03/BooleanComponent';
  
  storiesOf('BooleanComponent', module)
    .add('기본 설정', () => <BooleanComponent />)
    .add('bored 설정', () => <BooleanComponent bored />);
  ```

<br>

### 스토리북 확장 도구 사용하기

스토리북에는 여러가지 확장 도구(addons)를 추가 가능

이벤트 작동 테스트와 컴포넌트 사용 코드를 출력하기 위한 확장 도구인 addon-action과 addon-jsx를 설치 및 사용

#### 1. addon-actions 설치하기

addon-actions은 스토리북에서 발생하는 특정 이벤트에 로그를 출력하게 해줌

```bash
$ yarn add --dev @storybook/addons @storybook/addon-actions
```

#### 2. addon-actions 설정 추가하기

설치가 완료되면 확장 도구를 스토리북이 인식할 수 있도록 설정

+ ./.storybook에 addons.js 생성

  ```jsx
  // 확장 도구는 이곳에 설치
  import '@storybook/addon-actions/register';
  ```

#### 3. InputStory 스토리에 addon-actions 적용하기

스토리에 'onChange 예제'라는 항목을 추가하는데 이 컴포넌트는 변경 이벤트가 발생하면 onChange 프로퍼티에 전달한 콜백 함수를 실행

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  import { action } from '@storybook/addon-actions';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module)
    .add('기본 설정', () => <Input name="name" />)
    .add('label 예제', () => <Input name="name" label="이름" />)
    .add('onChange 예제', () => <Input name="name" onChange={action('onChange 이벤트 발생')} />);
  ```

#### 4. 스토리북 다시 시작하고 onChange 예제 살펴보기

스토리북에는 스토리 또는 스토리에 추가한 컴포넌트들을 검색 가능한 창이 있으며 검색창에 'onChange'를 입력하면 'onChange 예제' 항목을 쉽게 찾을 수 있음

#### 5. 로그 확인

입력창에 아무 내용이나 입력하면 아래의 [ACTION LOGGER] 탭에 로그가 출력
action() 함수의 인자로 전달된 문자열과 콜백 함수에서 전달된 인자가 배열 형태로 출력되는 것을 확인

#### 6. addon-jsx 설치하기

addon-jsx는 스토리북에서 바로 JSX 코드를 확인 가능하도록 해줌

```bash
$ yarn add --dev storybook-addon-jsx
```

#### 7. addon-jsx 설정 추가하기

+ ./.storybook/addons.js 수정

  ```jsx
  // ./.storybook/addons.js
  
  // 확장 도구는 이곳에 설치
  import '@storybook/addon-actions/register';
  import 'storybook-addon-jsx/register';
  ```

+ ./.storybook/config.js 수정

  ```jsx
  // ./storybook/config.js
  
  import { configure, setAddon } from '@storybook/react';
  import interopRequireDefault from 'babel-runtime/helpers/interopRequireDefault';
  import JSXAddon from 'storybook-addon-jsx';
  
  function loadStories() {
    const context = require.context('../src/stories', true, /Story\.jsx$/);
    context.keys().forEach((srcFile) => {
      interopRequireDefault(context(srcFile));
    });
  }
  
  setAddon(JSXAddon);
  configure(loadStories, module);
  ```

#### 8. 스토리북 다시 시작하고 addon-jsx 사용해 보기

스토리북 서버를 다시 구동하면 JSX라는 탭이 보이는데 addon-jsx를 통해 JSX를 보내려면 add() 함수가 아닌 addWithJSX() 함수를 사용하여 스토리에 컴포넌트를 추가해야 함

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  import { action } from '@storybook/addon-actions';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module)
    .addWithJSX('기본 설정', () => <Input name="name" />)
    .addWithJSX('label 예제', () => <Input name="name" label="이름" />)
    .addWithJSX('onChange 예제', () => (
      <Input name="name" onChange={action('onChange 이벤트 발생')} />
    ));
  ```


<br>

## 02. CSS로 컴포넌트 스타일 적용하기

화면에 스타일을 적용하는 작업은 웹 개발에서 중요하며 여러 스타일 가이드 중 하나인 머터리얼 디자인(Material Design)을 적용. 머터리얼 디자인은 구글에서 공개한 디자인 가이드를 말함

### CSS 또는 scss 이용하여 머티리얼 디자인 적용하기

#### 1. CDN 방식으로 머티리얼 디자인 적용하기

CDN은 특정 파일을 전세계에 분산하여 복사해두어 현재 접속한 위치와 가장 근접한 곳에서 빠르게 내려받을 수 있도록 파일을 제공하는 방법. 제이쿼와 같이 널리 사용되는 공개 소프트웨어의 경우 CDN에 파일이 제공되는 경우가 많음. 리액트 서버에 파일을 추가하지 않고 직접 이용할 경우 이 방법을 사용

+ ./public/index.html 수정

  ```jsx
  // ./public/index.html
  
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
      <!-- materialize design css -->
      <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
      />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <meta name="theme-color" content="#000000" />
      <meta name="description" content="Web site created using create-react-app" />
      <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
      <!--
        manifest.json provides metadata used when your web app is installed on a
        user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
      -->
      <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
      <!--
        Notice the use of %PUBLIC_URL% in the tags above.
        It will be replaced with the URL of the `public` folder during the build.
        Only files inside the `public` folder can be referenced from the HTML.
  
        Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
        work correctly both with client-side routing and a non-root public URL.
        Learn how to configure a non-root public URL by running `npm run build`.
      -->
      <title>React App</title>
    </head>
    <body>
      <noscript>You need to enable JavaScript to run this app.</noscript>
      <div id="root"></div>
      <!--
        This HTML file is a template.
        If you open it directly in the browser, you will see an empty page.
  
        You can add webfonts, meta tags, or analytics to this file.
        The build step will place the bundled scripts into the <body> tag.
  
        To begin the development, run `npm start` or `yarn start`.
        To create a production bundle, use `npm run build` or `yarn build`.
      -->
    </body>
  </html>
  ```

#### 2. App 컴포넌트에 머티리얼 디자인 요소 추가해 보기

여기서 추가하는 머티리얼 디자인 요소는 nav-wrapper로 상단 내비게이션 영역에 사용됨
파일을 수정한 다음 yarn start로 리액트 서버를 구동하면 CSS 작업을 하지 않아도 미려한 디자인의 상단 내비게이션이 만들어짐

+ ./src/App.js 수정

  ```jsx
  // ./src/App.js 
  
  import React from 'react';
  import './App.css';
  
  class App extends React.Component {
    render() {
      return (
        <div>
          <nav>
            <div className="nav-wrapper">
              <div>리액트 시작하기</div>
            </div>
          </nav>
          <h1>머티리얼 CSS</h1>
        </div>
      );
    }
  }
  export default App;
  ```


CDN 방식은 머티리얼  디자인을 적용할 수 있지만 인터넷 연결이 불안정하면 제대로 동작하지 않는다는 단점이 있음

#### 3. 파일 방식으로 머티리얼 디자인 적용하기

index.html을 열어 머티리얼 디자인 CDN을 삭제한 후 [머티리얼 디자인 공식 사이트](https://materializecss.com/)에 접속하여 [GET STARTED]를 선택하고 [MATERIALIZE]를 누른 후 materialize.zip 파일을 내려받아 압축 해제

#### 4. App 컴포넌트에 materialize.css 파일 추가하기

materialize.css 파일을 찾아 복사한 다음 리액트 프로젝트의 src 폴더에 붙여 넣음

+ ./src/App.js 수정

  ```jsx
  // ./src/App.js 
  
  import React from 'react';
  import './materialize.css';
  import './App.css';
  
  class App extends React.Component {
    render() {
      return (
        <div>
          <nav>
            <div className="nav-wrapper">
              <div>리액트 시작하기</div>
            </div>
          </nav>
          <h1>머티리얼 CSS</h1>
        </div>
      );
    }
  }
  export default App;
  ```

#### 5. scss로 스타일 모듈화하여 머티리얼 디자인 적용하기

CSS 파일은 수정, 관리가 어렵다는 단점이 있으므로 CSS의 단점을 보완한 SCSS 사용
[머티리얼 디자인 공식 사이트](https://materializecss.com/)에서 [GET STARTED] 선택 후 [Source]를 눌러 scss 압축 파일을 내려받은 후 sass라는 이름의 폴더를 모두 복사하여 src에 붙여 넣음

+ ./src/App.js 수정

  ```jsx
  // ./src/App.js
  
  import React from 'react';
  import './sass/materialize.scss';
  import './App.css';
  
  class App extends React.Component {
    render() {
      return (
        <div>
          <nav>
            <div className="nav-wrapper">
              <div>리액트 시작하기</div>
            </div>
          </nav>
          <h1>머티리얼 CSS</h1>
        </div>
      );
    }
  }
  export default App;
  ```

  만약 `run npm install node-sass.'라는 오류가 발생하면 node-sass 라이브러리를 설치해야 함. node-sass 라이브러리는 scss 파일을 컴파일하여 CSS 파일로 생성해줌. 리액트 서버를 잠시 중단하고 아래의 명령어를 입력하여 node-sass 라이브러리를 설치하고 리액트 서버를 다시 구동

  ```bash
  $ yarn add --dev node-sass
  ```

#### 6. scss 파일 수정하여 새 스타일 적용해보기

+ ./src/sass/components/_variables.scss 수정

  ```scss
  // ./src/sass/components/_variables.scss
  
  ...
  
  // 1. Colors
  // ==========================================================================
  
  $primary-color: color('materialize-red', 'lighten-3') !default;
  $primary-color-light: lighten($primary-color, 15%) !default;
  $primary-color-dark: darken($primary-color, 15%) !default;
  ```

SCSS 참고: [https://sass-guidelin.es/ko/](https://sass-guidelin.es/ko/)

<br>

### 컴포넌트에 머티리얼 디자인 본격적으로 적용해 보기

#### 1. 머티리얼 디자인이 적용된 입력 컴포넌트 만들기

+ ./src/04/InputWithStyles.jsx 생성

  ```jsx
  // ./src/04/InputWithStyles
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  
  class Input extends PureComponent {
    constructor(props) {
      super(props);
      this.setRef = this.setRef.bind(this);
      this.handleChange = this.handleChange.bind(this);
    }
    handleChange(e) {
      const { name, onChange } = this.props;
      if (onChange) {
        onChange(name, e.target.value);
      }
    }
    componentDidMount() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    componentWillUpdate() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    setRef(ref) {
      this.ref = ref;
    }
  
    render() {
      const { errorMessage, label, value, name, type } = this.props;
      return (
        <div className="input-field">
          <input
            id={`input_${name}`}
            className="validate"
            ref={this.setRef}
            type={type}
            onChange={this.handleChange}
            value={value}
          />
          <label htmlFor={`input_${name}`}>{label}</label>
          {errorMessage && <span className="helper-text">{errorMessage}</span>}
        </div>
      );
    }
  }
  
  Input.propTypes = {
    type: PropTypes.oneOf(['text', 'number', 'price']),
    name: PropTypes.string.isRequired,
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    errorMessage: PropTypes.string,
    label: PropTypes.string,
    onChange: PropTypes.func,
    onFocus: PropTypes.func,
    autoFocus: PropTypes.bool,
  };
  Input.defaultProps = {
    onChange: () => {},
    onFocus: () => {},
    autoFocus: false,
    type: 'text',
  };
  
  export default Input;
  ```

#### 2. InputWithStyleStory 스토리 만들어 스토리북에 추가하기

+ ./src/stories/InputWithStyleStory.jsx 생성

  ```jsx
  // ./src/stories/InputWithStyleStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Input from '../04/InputWithStyle';
  
  storiesOf('InputWithStyle', module)
    .addWithJSX('기본 설정', () => <Input name="name" />)
    .addWithJSX('label 예제', () => <Input name="name" label="이름" />)
    .addWithJSX('value 예제', () => <Input name="name" label="이름" value="us" />)
    .addWithJSX('errorMessage 예제', () => (
      <Input name="name" label="이름" errorMessage="이름을 입력해주세요" />
    ));
  ```

#### 3. 스토리북 서버에 sass-loader 설치하여 머티리얼 디자인 적용하기

스토리북 서버에 sass-loader 라이브러리가 설치되어 있지 않으므로 현재 새로 추가한 컴포넌트에 머티리얼 디자인이 적용되어 있지 않음

+ 루트폴더로 이동하여 명령어 실행

  ```bash
  $ yarn add --dev sass-loader
  ```

#### 4. 스토리북에 sass-loader 설정하기

+ ./.storybook 폴더에 webpack.config.js 생성

  ```jsx
  // ./.storybook/webpack.config.js
  
  const path = require('path');
  
  module.exports = {
    module: {
      rules: [
        {
          test: /\.scss$/,
          loaders: ['sass-loader'],
          include: path.resolve(__dirname, '../'),
        },
      ],
    },
  };
  ```

#### 5. metarialize.scss 임포트

+ ./.storybook/config.js 수정

  ```jsx
  // ./.storybook/config.js
  
  import { configure, setAddon } from '@storybook/react';
  import interopRequireDefault from 'babel-runtime/helpers/interopRequireDefault';
  import JSXAddon from 'storybook-addon-jsx';
  
  import '../src/sass/materialize.scss';
  
  function loadStories() {
    const context = require.context('../src/stories', true, /Story\.jsx$/);
    context.keys().forEach((srcFile) => {
      interopRequireDefault(context(srcFile));
    });
  }
  
  setAddon(JSXAddon);
  configure(loadStories, module);
  ```

  스토리북 서버를 다시 구동한 다음 머티리얼 디자인 적용 확인

  그런데 'errorMessage 예제'의 '이름을 입력해주세요'라는 안내 문구는 빨간색이 아니며 라벨의 위치도 입력칸 안에 있으므로 색상과 라벨 위치의 조정이 필요

  참조: [https://materializecss.com/text-inputs.html](https://materializecss.com/text-inputs.html)의 customer error or success messages 

+ ./src/04/InputWithStyle.jsx 수정

  ```jsx
  // ./src/04/InputWithStyle.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  
  class Input extends PureComponent {
    constructor(props) {
      super(props);
      this.setRef = this.setRef.bind(this);
      this.handleChange = this.handleChange.bind(this);
    }
    handleChange(e) {
      const { name, onChange } = this.props;
      if (onChange) {
        onChange(name, e.target.value);
      }
    }
    componentDidMount() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    componentWillUpdate() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    setRef(ref) {
      this.ref = ref;
    }
  
    render() {
      const { errorMessage, label, value, name, type } = this.props;
      return (
        <div className="input-field">
          <input
            id={`input_${name}`}
            className={`validate ${errorMessage && 'invalid'}`}
            ref={this.setRef}
            type={type}
            onChange={this.handleChange}
            value={value}
          />
          <label className="active" htmlFor={`input_${name}`}>
            {label}
          </label>
          {errorMessage && (
            <span className="helper-text" data-error={errorMessage}>
              {errorMessage}
            </span>
          )}
        </div>
      );
    }
  }
  
  Input.propTypes = {
    type: PropTypes.oneOf(['text', 'number', 'price']),
    name: PropTypes.string.isRequired,
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    errorMessage: PropTypes.string,
    label: PropTypes.string,
    onChange: PropTypes.func,
    onFocus: PropTypes.func,
    autoFocus: PropTypes.bool,
  };
  Input.defaultProps = {
    onChange: () => {},
    onFocus: () => {},
    autoFocus: false,
    type: 'text',
  };
  
  export default Input;
  ```

위의 방법을 사용하면 버튼, 아이콘, 테이블 등의 컴포넌트를 머티리얼 스타일로 꾸밀 수 있음

<br>

## 03. 스타일 컴포넌트 만들기

스타일 컴포넌트는 css 혹은 sass와 같은 스타일 파일을 따로 작성하지 않고 컴포넌트 안에서 스타일을 정의하여 바로 사용하는 방법. react-with-styles 라이브러리 사용

### 스타일 파일의 단점을 극복한 스타일 컴포넌트

기존에 사용하던 머티리얼 CSS 파일 또는 scss 파일을 그대로 컴포넌트에 스타일을 적용하면 내려받은 파일에 의존하므로 컴포넌트를 공유할 때 별도의 스타일 파일(css 또는 scss)을 공유해야 한다는 단점이 있음. 그리고 CSS 방식은 스타일 관리도 어려움

```jsx
const Title = () => <div className="title">리액트</div>

const Page = () => (
  <div>
    <h1><Title /></h1>
    책 목록
    <ul>
      <Title />
    </ul>
  </div>
)
```

만약 웹 디자이너 A가 아래와 같은 CSS 파일을 작성하여 Title 컴포넌트에 적용했다면 Title 컴포넌트의 글자 크기는 16px, 글자 색상은 검정으로 지정

```css
/* title.css */

.title {
  font-size: 16px;
  color: black;
}
```

그런데 웹디자이너 B가 page.css 파일을 작성하여 새로운 스타일을 적용한다면, h1 엘리먼트의 자식 엘리먼트 중 클래스 이름이 .title인 엘리먼트는 글자 크기 18px, 글자 색상은 파란색으로 지정

```css
/* page.css */

h1 > .title {
  font-size: 18px;
  color: blue;
}
```

처음에는 모든 Title 컴포넌트의 스타일이 동일하게 적용되었지만 page.css가 추가되며 클래스 이름이 .title인 엘리먼트와 h1 > .title인 엘리먼트의 스타일이 다르게 적용됨

만약 프로젝트의 크기가 커지면 이런 문제는 자주 발생하게 될 것이며 원인을 찾는 데도 많은 시간이 걸림. 이 외에도 CSS 규칙이 복잡해진다면 다음과 같이 스타일링 정의 이름만으로도 상당한 용량을 차지하게 됨

```css
body > section > div#message > .my-custom-title > #special-element-id > [data-important-value] ... {
  font-size: 16px;
  color: black;
}
```

이러한 문제점을 해결하기 위해 컴포넌트 파일과 함께 컴포넌트에만 적용되는 스타일을 결합하는 컴포넌트 개발법(CSS-in-JS)이 등장. 스타일 컴포넌트는 이와 같은 긴 클래스 이름을 a123wrs와 같이 짧게 변환해줌. 덕분에 CSS 방식보다 적은 용량으로 스타일 파일을 관리 가능. 

<br>

### react-with-styles로 스타일을 적용한 Text 컴포넌트 만들기

 react-with-styles는 에어비앤비에서 공개한 스타일 컴포넌트 라이브러리이며 자바스크립트 문법에 친화적이면서 '하이어오더 컴포넌트(higher order component, HoC)' 형태로 구현되어 있어 코드를 읽고 이해하기 쉬운 장점이 있음. 또한, 서버 출력 라이브러리와 스타일 클래스 압축(예를 들어 a123wrs)을 지원하기 때문에 스타일 컴포넌트 라이브러리 중에서는 우수한 성능을 자랑

#### 1. react-with-styles 라이브러리 설치하기

+ 프로젝트 루트 폴더에서 다음 명령어를 입력하여 react-with-styles 라이브러리를 설치
  함께 설치되는 라이브러리는 서버 출력을 도와주는 아프로디테(Aphrodite)

  ```bash
  $ yarn add react-with-styles aphrodite react-with-styles-interface-aphrodite
  ```

  여기서 서버 출력이란 자바스크립트로 스타일을 적용하면 화면이 모두 출력된 이후 자바스크립트 엔진이 동작하며 작동하게 되므로 스타일 적용 시 시간 간격이 생김. 시간 간격이 생기면 잠시나마 색상과 글꼴이 적용되지 않은 왜곡된 화면이 노출될 수 있으므로 이 시간 간격을 줄이려면 **화면 출력을 시작하는 순간에 스타일 코드를 서버에서 생성하여 같이 출력**하면 됨. 

#### 2. 테마 파일 만들기

설치가 완료되면 프로젝트 전체에서 사용할 스타일 파일(테마 파일)을 생성

+ ./src/04/Theme.js 생성

  ```jsx
  // ./src/04/Theme.js
  
  export default {
    // 색상
    color: {
      primary: '#03a9f4', // 주 색상
      secondary: '#795548', // 부 색상
      white: '#ffffff',
      gray: '#cccccc',
      default: '#999999', // 기본 문자 색상
    },
    // 글꼴 크기
    size: {
      xg: 24,
      lg: 18,
      md: 14,
      sm: 12,
      xs: 10,
    },
    lineHeight: {
      xg: '60px',
      lg: '54px',
      md: '36px',
      sm: '24px',
      xs: '18px',
    },
    // 길이 단위
    unit: 4,
  };
  ```

#### 3. 공용 스타일 컴포넌트 함수 만들기

react-with-styles를 모든 컴포넌트에서 사용하려면 아래와 같은 공용 파일을 만들어 설정해두는 것이 좋음. 공용 파일에는 앞에서 정의한 테마 파일을 등록한 후 공통된 테마 설정값을 사용하여 스타일 컴포넌트를 구성

+ ./src/04/withStyles.js 생성

  ```jsx
  // ./src/04/withStyles.js
  
  import ThemedStyleSheet from 'react-with-styles/lib/ThemedStyleSheet';
  import aphroditeInterface from 'react-with-styles-interface-aphrodite';
  import { css, withStyles, withStylesPropTypes } from 'react-with-styles';
  import Theme from './Theme';
  
  ThemedStyleSheet.registerTheme(Theme);
  ThemedStyleSheet.registerInterface(aphroditeInterface);
  
  export { css, withStyles, withStylesPropTypes, ThemedStyleSheet };
  export default withStyles;
  ```

#### 4. 텍스트 예제 컴포넌트 만들기

react-with-styles를 적용할 컴포넌트를 작성. 글자를 출력하는 텍스트 컴포넌트

+ ./src/04/Text.jsx 생성

  ```jsx
  // ./src/04/Text.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  
  class Text extends PureComponent {
    render() {
      const { children } = this.props;
      return <span>{children}</span>;
    }
  }
  
  Text.propTypes = {
    children: PropTypes.node.isRequired,
  };
  
  export default Text;
  ```

#### 5. 스토리 추가하기

스토리북에서 컴포넌트 출력하기

+ ./src/stories/TextStory.jsx 생성

  ```jsx
  // ./src/stories/TextStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Text from '../04/Text';
  
  storiesOf('Text', module).addWithJSX('기본 설정', () => <Text>안녕하세요</Text>);
  ```

  ```bash
  $ yarn storybook # 스토리북 확인
  ```

#### 6. react-with-styles로 스타일 적용 시 사용하는 withStyles() 함수 살펴보기

Text 컴포넌트에 react-with-styles로 스타일을 적용하기 전에 반환값이 함수인 커링 형태의 withStyles() 함수를 사용해야 함

```jsx
...
// withStyles() 함수가 구현된 코드의 일부
function withStyles(styleFunc) {
  return function getComponent(Component) {
    return class WithStyleComponent extends React.Component {
      render() {
        return <Component {...this.props} />
      }
    }
  }
}
class MyComponent extends React.Component { ... }
const MyComponentWithStyle = withStyles(...)(MyComponent);
...
```

#### 7. withStyles() 함수로 react-with-styles 사용해 보기

아직 스타일을 추가하지 않았으므로 오류 없이 같은 화면이 출력되는 것 확인

+ ./src/04/Text.jsx 수정

  ```jsx
  // ./src/04/Text.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  import withStyles from './withStyles';
  
  class Text extends PureComponent {
    render() {
      const { children } = this.props;
      return <span>{children}</span>;
    }
  }
  
  Text.propTypes = {
    children: PropTypes.node.isRequired,
  };
  
  export default withStyles()(Text);
  ```

#### 8. Text 컴포넌트에 스타일 추가하기

테마 파일에서 정의한 글꼴의 크기, 색상 등을 이용하여 텍스트 스타일을 추가하는데 스타일을 추가하면 HTML 스타일 코드가 생성되고 추가된 스타일 클래스가 출력된 노드의 프로퍼티에 자동 적용

+ ./src/04/Text.jsx 수정

  ```jsx
  // ./src/04/Text.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  import withStyles, { css } from './withStyles';
  
  class Text extends PureComponent {
    render() {
      const { children, styles } = this.props;
      return <span {...css(styles.default)}>{children}</span>;
    }
  }
  
  Text.propTypes = {
    children: PropTypes.node.isRequired,
  };
  
  export default withStyles(({ color, size }) => ({
    default: {
      color: color.default,
      fontSize: size.md,
    },
  }))(Text);
  ```

'안녕하세요'라는 문구 스타일이 테마 파일에서 지정된 default 색상(#999999의 rgb 값으로 변환됨)과 md 크기(14px)로 변경된 것을 알 수 있음. 개발자 도구로 문구에 적용된 스타일을 보면 실제로 default_xxxxx라는 이름의 스타일 클래스가 적용되어 있음. default라는 키워드는 테마 파일에 정의된 키값(default)과 동일하고 뒤에 연결된 문자는 무작위로 생성된 문자열

참고로 현재 실행하고 있는 환경은 개발자 환경이며 이후 스페셜 페이지에서 리액트 앱을 배포하면 스타일 이름은 테마 파일의 키값(default)을 제외한 문자열(예를 들면 x8ak)로 변경될 것

#### 9. 프로퍼티에 따라 Text 컴포넌트에 다양한 스타일 변경하기

문자 컴포넌트가 프로퍼티값에 의해 크기와 색을 변경할 수 있도록 수정
css() 함수는 전개된 인자들의 속성값을 병합해주는 기능이 있음
예를 들어, css(style1, style2, style3)는 style1, style2, style3을 병합해줌

+ ./src/04/Text.js 수정

  ```jsx
  // ./src/04/Text.js
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  import withStyles, { css } from './withStyles';
  
  class Text extends PureComponent {
    render() {
      const { children, styles, large, xlarge, small, xsmall, primary, secondary } = this.props;
      return (
        <span
          {...css(
            styles.default,
            xsmall && styles.xsmall,
            small && styles.small,
            large && styles.large,
            xlarge && styles.xlarge,
            secondary && styles.secondary,
            primary && styles.primary,
          )}
        >
          {children}
        </span>
      );
    }
  }
  
  Text.propTypes = {
    children: PropTypes.node.isRequired,
    xsmall: PropTypes.bool,
    small: PropTypes.bool,
    large: PropTypes.bool,
    xlarge: PropTypes.bool,
    secondary: PropTypes.bool,
    primary: PropTypes.bool,
  };
  
  export default withStyles(({ color, size }) => ({
    default: {
      color: color.default,
      fontSize: size.md,
    },
    xlarge: {
      fontSize: size.xg,
    },
    large: {
      fontSize: size.lg,
    },
    small: {
      fontSize: size.sm,
    },
    xsmall: {
      fontSize: size.xs,
    },
    primary: {
      color: color.primary,
    },
    secondary: {
      color: color.secondary,
    },
  }))(Text);
  ```

+ ./src/stories/TextStory.jsx

  ```jsx
  // ./src/stories/TextStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Text from '../04/Text';
  
  storiesOf('Text', module)
    .addWithJSX('기본 설정', () => <Text>안녕하세요</Text>)
    .addWithJSX('large 예제', () => <Text large>안녕하세요</Text>)
    .addWithJSX('xlarge 예제', () => <Text xlarge>안녕하세요</Text>)
    .addWithJSX('small 예제', () => <Text small>안녕하세요</Text>)
    .addWithJSX('xsmall 예제', () => <Text xsmall>안녕하세요</Text>)
    .addWithJSX('primary 예제', () => <Text primary>안녕하세요</Text>)
    .addWithJSX('secondary 예제', () => <Text secondary>안녕하세요</Text>)
    .addWithJSX('primary와 large 함께 쓰는 예제', () => (
      <Text primary large>
        안녕하세요
      </Text>
    ));
  ```

<br>

### react-with-styles로 스타일을 적용한 Button 컴포넌트 만들기

Text 컴포넌트와 유사한 방법으로 간단한 Button 컴포넌트를 제작하고 스타일을 적용

#### 1. Button 컴포넌트 기능 구현하기

+ ./src/04/Button.jsx 생성

  ```jsx
  // ./src/04/Button.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  
  class Button extends PureComponent {
    render() {
      const { children, disabled, onPress } = this.props;
      return <button onClick={onPress}>{children}</button>;
    }
  }
  
  Button.propTypes = {
    children: PropTypes.node.isRequired,
    onPress: PropTypes.func,
  };
  Button.defaultProps = {
    onPress: () => {},
  };
  export default Button;
  ```

#### 2. Button 컴포넌트 스타일 적용하기

Button 컴포넌트의 기본 모양을 둥근 테두리로 꾸며보며 추가로 Text 컴포넌트와 동일하게 크기와 색상이 변하도록 프로퍼티와 스타일을 구성

+ ./src/04/Button.jsx

  ```jsx
  // ./src/04/Button.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  import withStyles, { css } from './withStyles';
  
  class Button extends PureComponent {
    render() {
      const {
        children,
        disabled,
        styles,
        large,
        xlarge,
        small,
        xsmall,
        primary,
        secondary,
        onPress,
      } = this.props;
      return (
        <button
          {...css(
            styles.default,
            xsmall && styles.xsmall,
            small && styles.small,
            large && styles.large,
            xlarge && styles.xlarge,
            secondary && styles.secondary,
            primary && styles.primary,
          )}
          onClick={onPress}
        >
          {children}
        </button>
      );
    }
  }
  
  Button.propTypes = {
    children: PropTypes.node.isRequired,
    xsmall: PropTypes.bool,
    small: PropTypes.bool,
    large: PropTypes.bool,
    xlarge: PropTypes.bool,
    secondary: PropTypes.bool,
    primary: PropTypes.bool,
    onPress: PropTypes.func,
  };
  Button.defaultProps = {
    onPress: () => {},
    xsmall: false,
    small: false,
    large: false,
    xlarge: false,
    secondary: false,
    primary: false,
  };
  export default withStyles(({ color, size, unit }) => ({
    default: {
      border: 1,
      borderSize: 'solid',
      borderColor: color.default,
      borderRadius: 2,
      color: color.default,
      fontSize: size.md,
      padding: unit * 2,
      cursor: 'pointor',
    },
    xlarge: {
      fontSize: size.xg,
    },
    large: {
      fontSize: size.lg,
    },
    small: {
      fontSize: size.sm,
      padding: unit,
    },
    xsmall: {
      fontSize: size.xs,
      padding: unit,
    },
    primary: {
      borderColor: color.primary,
      color: color.white,
      backgroundColor: color.primary,
    },
    secondary: {
      borderColor: color.secondary,
      color: color.secondary,
    },
  }))(Button);
  ```

#### 3. Button 컴포넌트 스토리 예제 추가하기

+ ./src/stories/ButtonStory.jsx 생성

  ```jsx
  // ./src/stories/ButtonStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Button from '../04/Button';
  
  storiesOf('Button', module)
    .addWithJSX('기본 설정', () => <Button>전송하기</Button>)
    .addWithJSX('large 예제', () => <Button large>전송하기</Button>)
    .addWithJSX('xlarge 예제', () => <Button xlarge>전송하기</Button>)
    .addWithJSX('small 예제', () => <Button small>전송하기</Button>)
    .addWithJSX('xsmall 예제', () => <Button xsmall>전송하기</Button>)
    .addWithJSX('primary 예제', () => <Button primary>전송하기</Button>)
    .addWithJSX('secondary 예제', () => <Button secondary>전송하기</Button>)
    .addWithJSX('primary와 large 함께 쓰는 예제', () => (
      <Button primary large>
        전송하기
      </Button>
    ));
  ```

<br>

### 반응형으로 스타일 구성하기

모바일 사용자를 위해 '해상도에 따라 화면이 달라지는' 반응형으로 스타일을 구성

#### 1. 테마 파일에 미디어 속성값 추가하기

small은 휴대폰 화면, medium은 태블릿, large는 데스크톱의 기본 해상도를 기준으로 구분
미디어 속성값 중 'small'은 모바일 기기에 특화된 해상도를, 'largeAndAboves'는 모니터에 특화된 해상도를 말함

+ ./src/Theme.js 수정

  ```jsx
  // ./src/04/Theme.js
  
  export const LARGE_AND_ABOVE = 'largeAndAbove';
  const BREAKPOINT_NAMES = {
    LARGE: 'large',
    MEDIUM: 'medium',
    SMALL: 'small',
  };
  
  const breakpoints = {
    [BREAKPOINT_NAMES.LARGE]: 1128,
    [BREAKPOINT_NAMES.MEDIUM]: 744,
    [BREAKPOINT_NAMES.SMALL]: 327,
  };
  
  const responsive = {
    [LARGE_AND_ABOVE]: `@media (min-width: ${breakpoints[BREAKPOINT_NAMES.LARGE]}px)`,
    [BREAKPOINT_NAMES.SMALL]: `@media (max-width: ${breakpoints[BREAKPOINT_NAMES.MEDIUM] - 1}px)`,
    print: '@media print',
  };
  
  export default {
    // 색상
    color: {
      primary: '#03a9f4', // 주 색상
      secondary: '#795548', // 부 색상
      white: '#ffffff',
      gray: '#cccccc',
      default: '#999999', // 기본 문자 색상
    },
    // 글꼴 크기
    size: {
      xg: 24,
      lg: 18,
      md: 14,
      sm: 12,
      xs: 10,
    },
    lineHeight: {
      xg: '60px',
      lg: '54px',
      md: '36px',
      sm: '24px',
      xs: '18px',
    },
    // 길이 단위
    unit: 4,
    // 반응형 미디어 속성
    responsive,
  };
  ```

#### 2. 버튼 컴포넌트에 미디어 속성값 적용하기

휴대폰 해상도에서 버튼의 넓이를 100%를 늘려 변경하고 테마 파일로 작성된 미디어 속성값(responsive)은 withStyles() 함수의 인자로 전달

+ ./src/04/Button.jsx 수정

  ```jsx
  // ./src/04/Button.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  import withStyles, { css } from './withStyles';
  
  class Button extends PureComponent {
    render() {
      const {
        children,
        disabled,
        styles,
        large,
        xlarge,
        small,
        xsmall,
        primary,
        secondary,
        onPress,
      } = this.props;
      return (
        <button
          {...css(
            styles.default,
            xsmall && styles.xsmall,
            small && styles.small,
            large && styles.large,
            xlarge && styles.xlarge,
            secondary && styles.secondary,
            primary && styles.primary,
          )}
          onClick={onPress}
        >
          {children}
        </button>
      );
    }
  }
  
  Button.propTypes = {
    children: PropTypes.node.isRequired,
    xsmall: PropTypes.bool,
    small: PropTypes.bool,
    large: PropTypes.bool,
    xlarge: PropTypes.bool,
    secondary: PropTypes.bool,
    primary: PropTypes.bool,
    onPress: PropTypes.func,
  };
  Button.defaultProps = {
    onPress: () => {},
    xsmall: false,
    small: false,
    large: false,
    xlarge: false,
    secondary: false,
    primary: false,
  };
  
  export default withStyles(({ color, size, unit, responsive }) => ({
    default: {
      border: 1,
      borderSize: 'solid',
      borderColor: color.default,
      borderRadius: 2,
      color: color.default,
      fontSize: size.md,
      padding: unit * 2,
      cursor: 'pointor',
      [responsive.small]: {
        width: '100%',
      },
    },
    xlarge: {
      fontSize: size.xg,
    },
    large: {
      fontSize: size.lg,
    },
    small: {
      fontSize: size.sm,
      padding: unit,
    },
    xsmall: {
      fontSize: size.xs,
      padding: unit,
    },
    primary: {
      borderColor: color.primary,
      color: color.white,
      backgroundColor: color.primary,
    },
    secondary: {
      borderColor: color.secondary,
      color: color.secondary,
    },
  }))(Button);
  ```

스토리북 실행 후 화면을 줄여 확인

<br>

## 04. 테스트 위주 개발 방법 사용해 보기

작성한 코드가 제대로 기능하는지 확인하기 위해 작성하는 코드를 '테스트 코드(test code)'라 하고, 수행 기능을 작성하기 전에 테스트 코드부터 개발 방법을 '테스트 위주 개발(Test-Driven Development)'이라고 함. 많은 개발자들이 코드의 품질을 향상하기 위해 이 방법을 사용. 팀원과 협업 시 내가 작성한 코드를 다른 사람이 수정했을 때 '원래 기능이 고장 나지 않게' 보호할 수 있음. 또한 기존에 작성한 코드가 변경된 기능에도 정상적으로 작동하는지 검증할 때에도 사용

### 리액트의 기본 테스트 환경 jest 도구 사용해 보기

jest는 create-react-app에서 제공하는 기본 테스트 환경

#### 1. package.json 파일 확인하기

test라는 이름의 테스트 항목

+ ./package.json 확인

  ```json
  // ./package.json
  
    "scripts": {
      "dev": "next",
      "predeploy": "yarn build-all",
      "deploy": "firebase deploy",
      "build-all": "yarn ssrbuild && yarn build-firebase",
      "build-firebase": "cd \"./functions\" && yarn --ignore-engines",
      "ssrbuild": "next build",
      "storybook": "start-storybook -p 9001 -c .storybook",
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test,
      "mockserver": "json-server --watch --delay 500 --port 4000 mock/create.js",
      "errorserver": "node mock/fake.js",
      "eject": "react-scripts eject"
    },
  ```

#### 2. 테스트 환경 구동하기

+ ./src/App.test.js 파일 삭제

+ 명령어 수행

  ```bash
  $ yarn test
  ```

#### 3. 테스트 코드 작성하기

create-react-app은 파일 이름이 `.test.js`, `.spec.js`로 끝나는 파일이나 `src/__tests__ `폴더에 작성된 모든 .js, jsx 확장자 파일을 테스트 환경에서 실행.

간략한 테스트를 위해 ReactDOM() 함수를 사용하여 가상으로 웹 문서를 생성하고 컴포넌트 출력

+ `./src/__test__/04/Input.test.jsx` 생성

  ```jsx
  // ./src/__test__/04/Input.test.jsx
  
  import React from 'react';
  import ReactDOM from 'react-dom';
  import Input from '../../03/Input';
  
  describe('<Input>', () => {
    it('renders without crashing', () => {
      const div = document.createElement('div');
      ReactDOM.react(<Input />, div);
      ReactDOM.unmountComponentAtNode(div);
    });
  });
  ```

#### 4. 경고 메시지 확인하기

파일 저장 후 테스트 환경을 구동하면 'Warning: Failed prop type: The prop 'name' is marked...'라는 경고 메시지가 나타남. 필수 프로퍼티 name이 Input 컴포넌트로 전달되지 않았기 때문에 테스트가 제대로 통과되지 않음. Input.test.jsx 파일을 다음과 같이 수정하여 저장하면 테스트 환경이 테스트 코드 파일을 감시하고 있다가 변경 내용을 확인하고 테스트를 다시 실행

+ `./src/__test__/04/Input.test.jsx` 수정

  ```jsx
  // ./src/__test__/04/Input.test.jsx
  
  import React from 'react';
  import ReactDOM from 'react-dom';
  import Input from '../../03/Input';
  
  describe('<Input>', () => {
    it('renders without crashing', () => {
      const div = document.createElement('div');
      ReactDOM.react(<Input name="name" />, div);
      ReactDOM.unmountComponentAtNode(div);
    });
  });
  ```

<br>

<br>

## 05. CheckBox 컴포넌트 만들기

### CheckBox 컴포넌트 만들기

+ ./src/04/CheckBox.jsx 생성

  ```jsx
  // ./src/04/CheckBox.js
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  import withStyles, { css } from './withStyles';
  
  class CheckBox extends PureComponent() {
    constructor(props) {
      super(props);
      this.setRef = this.setRef.bind(this);
      this.handleClick = this.handleClick.bind(this);
    }
    componentDidMount() {
      if (this.props.autoFocus) {
        this.ref.focus();
      }
    }
    handleClick(e) {
      const { name, onChange } = this.props;
      onChange(name, e.target.checked);
    }
    setRef(ref) {
      this.ref = ref;
    }
    render() {
      const { errorMessage, label, children, styles, checked } = this.props;
      return (
        <label>
          {label}
          <div>
            <input
              ref={this.setRef}
              type="checkbox"
              checked={checked && 'checked'}
              onClick={this.handleClick}
            />
            ;
          </div>
          {errorMessage && (
            <div>
              <span {...css(styles.errorText)}>{errorMessage}</span>
            </div>
          )}
        </label>
      );
    }
  }
  
  CheckBox.propTypes = {
    name: PropTypes.string.isRequired,
    autoFocus: PropTypes.bool,
    checked: PropTypes.bool,
    onChange: PropTypes.func,
  };
  CheckBox.defaultProps = {
    autoFocus: false,
    checked: false,
    onChange: () => {},
  };
  
  export default withStyles(({ color, size }) => ({
    errorText: {
      fontSize: size.sm,
      color: color.error,
    },
  }))(CheckBox);
  ```

  



