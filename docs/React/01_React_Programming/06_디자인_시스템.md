# 디자인 시스템

## 01. 비주얼 테스트로 더 쉽게 개발하기

요즘 대부분의 웹 사이트들은 상황에 따라 오류 메시지나 로딩 화면을 출력하는데 이런 화면들은 화면 1개당 최소 2개의 화면을 구성해야 함. 예를 들어 오류가 있거나 없을 때 서로 다른 화면을 보여주어야 하므로 최소 2가지의 화면을 구성해야 함. 이처럼 상황에 맞게 컴포넌트를 제작하고 확인하는 작업은 번거로움

그래서 스토리북(react-storybook)이라는 비주얼 테스트를 위한 도구를 사용하는데 비주얼 테스트란 화면을 구성하는 컴포넌트들을 독립적으로 관리하고 변화를 살펴볼 수 있는 방법을 의미. 실제 가구를 집에 배치하기 전에 제품 사진만 따로 모아둔 책자에서 다양한 색상의 가구를 확인하는 것과 비슷함. 

### 스토리북 설치하고 사용해 보기

#### 1. 스토리북 설치하기

프로젝트의 루트폴더로 이동하여 다음 명령어를 실행하면 package.json에 자동으로 스토리북이 추가된 것을 확인 가능

```bash
$ yarn add --dev @storybook/react
```

#### 2. package.json에 스토리북 실행 명령어 추가하기

설치가 완료된 스토리북을 실행하기 위해서 package.json에 노드 명령어를 추가함. 
package.json의 scripts 블록은 npm 또는 yarn에서 실행할 명령어를 정의하는 곳이며 지금까지 리액트 서버를 구동시킬 때 사용한 yarn start라는 명령어도 이 블록의 명령어를 참조한 것

+ storybook 명령어가 스토리북 서버를 9001 포트를 통해 실행시킬 수 있도록 설정

  ```json
  // ./package.json
  
  ...
    "scripts": {
      "storybook": "start-storybook -p 9001 -c .storybook",
      "start": "react-scripts start",
      "build": "react-scripts build",
      "test": "react-scripts test",
      "eject": "react-scripts eject"
    },
  ...
  ```

#### 3. 스토리 파일 만들기

스토리는 컴포넌트의 여러 출력 형태를 구성한 페이지인데 여기서는 다양한 형태의 Input 컴포넌트를 가지는 Input 스토리를 만들어봄. 

+ ./src에 stories 폴더를 생성 후 InputStory.jsx 파일을 생성

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from "react";
  import { storiesOf } from "@storybook/react";
  
  import Input from "../03/Input";
  
  storiesOf("Input", module).add("기본 설정", () => <Input />);
  ```

#### 4. 스토리북 config.js에 스토리 연결하기

만든 스토리 파일을 스토리북 config.js에 연결하려면 루트 폴더에 `.storybook`이라는 이름의 폴더가 필요.

+ .storybook 폴더 생성 후 config.js 파일 생성

  ```jsx
  // ./.storybook/config.js
  
  import { configure } from "@storybook/react";
  
  function loadStories() {
    require("../src/stories/InputStory");
    // 스토리 파일을 이곳에 추가할 수 있음
  }
  
  configure(loadStories, module);
  ```

#### 5. 스토리북 실행하기

터미널에서 다음과 같은 명령어 실행 

```bash
$ yarn storybook
```

명령어 실행이 완료되면 명령 프롬프트에 'Storybook 5.2.0 started...'와 같은 메시지가 출력되며, localhost:9001에서 자동으로 접속

#### 6. 스토리북 오류 메시지 수정하기

크롬 브라우저의 콘솔창을 보면 Input 컴포넌트의 필수 프로퍼티인 name이 없다는 오류 메시지가 나타나는데(Input 프로퍼티에서 프로퍼티 name을 isRequired로 정의), Input 스토리에서 add() 함수로 추가한 Input 컴포넌트에 name 프로퍼티를 추가하면 오류 메시지가 사라짐

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module).add('기본 설정', () => <Input name="name" />);
  ```

여기까지 진행하면 스토리북의 모든 설정 작업이 완료된 것

참조: [https://storybook.js.org/basics/guide-react/](https://storybook.js.org/basics/guide-react/)

<br>

### 스토리북 사용하기

스토리에 여러 형태의 컴포넌트를 추가하고, 새 스토리를 자동으로 스토리북에 연결

#### 1. 스토리에 다른 형태의 컴포넌트 추가하기

라벨이 있는 형태의 Input 컴포넌트를 Input 스토리에 추가

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module)
    .add('기본 설정', () => <Input name="name" />)
    .add('label 예제', () => <Input name="name" label="이름" />);
  ```

수정 후 저장하면 크롬 브라우저가 자동으로 새로고침되며 왼쪽 메뉴에 'label 예제' 컴포넌트가 추가

스토리에 여러 형태의 Input 컴포넌트를 추가할 수 있으므로 Input 컴포넌트가 포함된 실제 리액트 앱 화면을 직접 수정하여 확인하는 과정은 스토리북에서 하면 됨. 즉, 컴포넌트에 다양한 기능이나 디자인을 추가할 때는 스토리북을 사용

#### 2. 스토리 추가하기

새 스토리 추가

+ ./src/stories에 NewCounterStory.jsx 생성

  ```jsx
  // ./src/stories/NewCounterStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import NewCounter from '../03/NEwCounter';
  
  storiesOf('NewCounter', module).add('기본 설정', () => <NewCounter count={0} />);
  ```

#### 3. 스토리북에 스토리 추가하기

+ ./.storybook/config.js 수정

  ```jsx
  // ./.storybook/config.js
  
  import { configure } from '@storybook/react';
  
  function loadStories() {
    require('../src/stories/InputStory');
    // 스토리 파일을 이곳에 추가할 수 있음
    require('../src/stories/NewCounterStory');
  }
  
  configure(loadStories, module);
  ```

####  4. 스토리가 자동으로 스토리북에 추가되도록 config.js 설정하기

아래와 같이 수정하면 stories 폴더에 있는 파일 이름을 검사하여 '~Story.jsx'라고 끝나는 이름의 파일들을 config.js에 자동으로 추가 가능

+ ./.storybook/config.js 수정

  ```jsx
  import { configure } from '@storybook/react';
  import interopRequireDefault from 'babel-runtime/helpers/interopRequireDefault';
  
  function loadStories() {
    const context = require.context('../src/stories', true, /Story\.jsx$/);
    context.keys().forEach((srcFile) => {
      interopRequireDefault(context(srcFile));
    });
  }
  
  configure(loadStories, module);
  ```

#### 5. 스토리가 자동으로 스토리북에 추가되는지 확인해 보기

+ ./src/stories에 BooleanComponentStory.jsx 생성

  ```jsx
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import BooleanComponent from '../03/BooleanComponent';
  
  storiesOf('BooleanComponent', module)
    .add('기본 설정', () => <BooleanComponent />)
    .add('bored 설정', () => <BooleanComponent bored />);
  ```

<br>

### 스토리북 확장 도구 사용하기

스토리북에는 여러가지 확장 도구(addons)를 추가 가능

이벤트 작동 테스트와 컴포넌트 사용 코드를 출력하기 위한 확장 도구인 addon-action과 addon-jsx를 설치 및 사용

#### 1. addon-actions 설치하기

addon-actions은 스토리북에서 발생하는 특정 이벤트에 로그를 출력하게 해줌

```bash
$ yarn add --dev @storybook/addons @storybook/addon-actions
```

#### 2. addon-actions 설정 추가하기

설치가 완료되면 확장 도구를 스토리북이 인식할 수 있도록 설정

+ ./.storybook에 addons.js 생성

  ```jsx
  // 확장 도구는 이곳에 설치
  import '@storybook/addon-actions/register';
  ```

#### 3. InputStory 스토리에 addon-actions 적용하기

스토리에 'onChange 예제'라는 항목을 추가하는데 이 컴포넌트는 변경 이벤트가 발생하면 onChange 프로퍼티에 전달한 콜백 함수를 실행

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  import { action } from '@storybook/addon-actions';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module)
    .add('기본 설정', () => <Input name="name" />)
    .add('label 예제', () => <Input name="name" label="이름" />)
    .add('onChange 예제', () => <Input name="name" onChange={action('onChange 이벤트 발생')} />);
  ```

#### 4. 스토리북 다시 시작하고 onChange 예제 살펴보기

스토리북에는 스토리 또는 스토리에 추가한 컴포넌트들을 검색 가능한 창이 있으며 검색창에 'onChange'를 입력하면 'onChange 예제' 항목을 쉽게 찾을 수 있음

#### 5. 로그 확인

입력창에 아무 내용이나 입력하면 아래의 [ACTION LOGGER] 탭에 로그가 출력
action() 함수의 인자로 전달된 문자열과 콜백 함수에서 전달된 인자가 배열 형태로 출력되는 것을 확인

#### 6. addon-jsx 설치하기

addon-jsx는 스토리북에서 바로 JSX 코드를 확인 가능하도록 해줌

```bash
$ yarn add --dev storybook-addon-jsx
```

#### 7. addon-jsx 설정 추가하기

+ ./.storybook/addons.js 수정

  ```jsx
  // ./.storybook/addons.js
  
  // 확장 도구는 이곳에 설치
  import '@storybook/addon-actions/register';
  import 'storybook-addon-jsx/register';
  ```

+ ./.storybook/config.js 수정

  ```jsx
  // ./storybook/config.js
  
  import { configure, setAddon } from '@storybook/react';
  import interopRequireDefault from 'babel-runtime/helpers/interopRequireDefault';
  import JSXAddon from 'storybook-addon-jsx';
  
  function loadStories() {
    const context = require.context('../src/stories', true, /Story\.jsx$/);
    context.keys().forEach((srcFile) => {
      interopRequireDefault(context(srcFile));
    });
  }
  
  setAddon(JSXAddon);
  configure(loadStories, module);
  ```

#### 8. 스토리북 다시 시작하고 addon-jsx 사용해 보기

스토리북 서버를 다시 구동하면 JSX라는 탭이 보이는데 addon-jsx를 통해 JSX를 보내려면 add() 함수가 아닌 addWithJSX() 함수를 사용하여 스토리에 컴포넌트를 추가해야 함

+ ./src/stories/InputStory.jsx 수정

  ```jsx
  // ./src/stories/InputStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  import { action } from '@storybook/addon-actions';
  
  import Input from '../03/Input';
  
  storiesOf('Input', module)
    .addWithJSX('기본 설정', () => <Input name="name" />)
    .addWithJSX('label 예제', () => <Input name="name" label="이름" />)
    .addWithJSX('onChange 예제', () => (
      <Input name="name" onChange={action('onChange 이벤트 발생')} />
    ));
  ```


<br>

## 02. CSS로 컴포넌트 스타일 적용하기

화면에 스타일을 적용하는 작업은 웹 개발에서 중요하며 여러 스타일 가이드 중 하나인 머터리얼 디자인(Material Design)을 적용. 머터리얼 디자인은 구글에서 공개한 디자인 가이드를 말함

### CSS 또는 scss 이용하여 머티리얼 디자인 적용하기

#### 1. CDN 방식으로 머티리얼 디자인 적용하기

CDN은 특정 파일을 전세계에 분산하여 복사해두어 현재 접속한 위치와 가장 근접한 곳에서 빠르게 내려받을 수 있도록 파일을 제공하는 방법. 제이쿼와 같이 널리 사용되는 공개 소프트웨어의 경우 CDN에 파일이 제공되는 경우가 많음. 리액트 서버에 파일을 추가하지 않고 직접 이용할 경우 이 방법을 사용

+ ./public/index.html 수정

  ```jsx
  // ./public/index.html
  
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
      <!-- materialize design css -->
      <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
      />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <meta name="theme-color" content="#000000" />
      <meta name="description" content="Web site created using create-react-app" />
      <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
      <!--
        manifest.json provides metadata used when your web app is installed on a
        user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
      -->
      <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
      <!--
        Notice the use of %PUBLIC_URL% in the tags above.
        It will be replaced with the URL of the `public` folder during the build.
        Only files inside the `public` folder can be referenced from the HTML.
  
        Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
        work correctly both with client-side routing and a non-root public URL.
        Learn how to configure a non-root public URL by running `npm run build`.
      -->
      <title>React App</title>
    </head>
    <body>
      <noscript>You need to enable JavaScript to run this app.</noscript>
      <div id="root"></div>
      <!--
        This HTML file is a template.
        If you open it directly in the browser, you will see an empty page.
  
        You can add webfonts, meta tags, or analytics to this file.
        The build step will place the bundled scripts into the <body> tag.
  
        To begin the development, run `npm start` or `yarn start`.
        To create a production bundle, use `npm run build` or `yarn build`.
      -->
    </body>
  </html>
  ```

#### 2. App 컴포넌트에 머티리얼 디자인 요소 추가해 보기

여기서 추가하는 머티리얼 디자인 요소는 nav-wrapper로 상단 내비게이션 영역에 사용됨
파일을 수정한 다음 yarn start로 리액트 서버를 구동하면 CSS 작업을 하지 않아도 미려한 디자인의 상단 내비게이션이 만들어짐

+ ./src/App.js 수정

  ```jsx
  // ./src/App.js 
  
  import React from 'react';
  import './App.css';
  
  class App extends React.Component {
    render() {
      return (
        <div>
          <nav>
            <div className="nav-wrapper">
              <div>리액트 시작하기</div>
            </div>
          </nav>
          <h1>머티리얼 CSS</h1>
        </div>
      );
    }
  }
  export default App;
  ```


CDN 방식은 머티리얼  디자인을 적용할 수 있지만 인터넷 연결이 불안정하면 제대로 동작하지 않는다는 단점이 있음

#### 3. 파일 방식으로 머티리얼 디자인 적용하기

index.html을 열어 머티리얼 디자인 CDN을 삭제한 후 [머티리얼 디자인 공식 사이트](https://materializecss.com/)에 접속하여 [GET STARTED]를 선택하고 [MATERIALIZE]를 누른 후 materialize.zip 파일을 내려받아 압축 해제

#### 4. App 컴포넌트에 materialize.css 파일 추가하기

materialize.css 파일을 찾아 복사한 다음 리액트 프로젝트의 src 폴더에 붙여 넣음

+ ./src/App.js 수정

  ```jsx
  // ./src/App.js 
  
  import React from 'react';
  import './materialize.css';
  import './App.css';
  
  class App extends React.Component {
    render() {
      return (
        <div>
          <nav>
            <div className="nav-wrapper">
              <div>리액트 시작하기</div>
            </div>
          </nav>
          <h1>머티리얼 CSS</h1>
        </div>
      );
    }
  }
  export default App;
  ```

#### 5. scss로 스타일 모듈화하여 머티리얼 디자인 적용하기

CSS 파일은 수정, 관리가 어렵다는 단점이 있으므로 CSS의 단점을 보완한 SCSS 사용
[머티리얼 디자인 공식 사이트](https://materializecss.com/)에서 [GET STARTED] 선택 후 [Source]를 눌러 scss 압축 파일을 내려받은 후 sass라는 이름의 폴더를 모두 복사하여 src에 붙여 넣음

+ ./src/App.js 수정

  ```jsx
  // ./src/App.js
  
  import React from 'react';
  import './sass/materialize.scss';
  import './App.css';
  
  class App extends React.Component {
    render() {
      return (
        <div>
          <nav>
            <div className="nav-wrapper">
              <div>리액트 시작하기</div>
            </div>
          </nav>
          <h1>머티리얼 CSS</h1>
        </div>
      );
    }
  }
  export default App;
  ```

  만약 `run npm install node-sass.'라는 오류가 발생하면 node-sass 라이브러리를 설치해야 함. node-sass 라이브러리는 scss 파일을 컴파일하여 CSS 파일로 생성해줌. 리액트 서버를 잠시 중단하고 아래의 명령어를 입력하여 node-sass 라이브러리를 설치하고 리액트 서버를 다시 구동

  ```bash
  $ yarn add --dev node-sass
  ```

#### 6. scss 파일 수정하여 새 스타일 적용해보기

+ ./src/sass/components/_variables.scss 수정

  ```scss
  // ./src/sass/components/_variables.scss
  
  ...
  
  // 1. Colors
  // ==========================================================================
  
  $primary-color: color('materialize-red', 'lighten-3') !default;
  $primary-color-light: lighten($primary-color, 15%) !default;
  $primary-color-dark: darken($primary-color, 15%) !default;
  ```

SCSS 참고: [https://sass-guidelin.es/ko/](https://sass-guidelin.es/ko/)

<br>

### 컴포넌트에 머티리얼 디자인 본격적으로 적용해 보기

#### 1. 머티리얼 디자인이 적용된 입력 컴포넌트 만들기

+ ./src/04/InputWithStyles.jsx 생성

  ```jsx
  // ./src/04/InputWithStyles
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  
  class Input extends PureComponent {
    constructor(props) {
      super(props);
      this.setRef = this.setRef.bind(this);
      this.handleChange = this.handleChange.bind(this);
    }
    handleChange(e) {
      const { name, onChange } = this.props;
      if (onChange) {
        onChange(name, e.target.value);
      }
    }
    componentDidMount() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    componentWillUpdate() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    setRef(ref) {
      this.ref = ref;
    }
  
    render() {
      const { errorMessage, label, value, name, type } = this.props;
      return (
        <div className="input-field">
          <input
            id={`input_${name}`}
            className="validate"
            ref={this.setRef}
            type={type}
            onChange={this.handleChange}
            value={value}
          />
          <label htmlFor={`input_${name}`}>{label}</label>
          {errorMessage && <span className="helper-text">{errorMessage}</span>}
        </div>
      );
    }
  }
  
  Input.propTypes = {
    type: PropTypes.oneOf(['text', 'number', 'price']),
    name: PropTypes.string.isRequired,
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    errorMessage: PropTypes.string,
    label: PropTypes.string,
    onChange: PropTypes.func,
    onFocus: PropTypes.func,
    autoFocus: PropTypes.bool,
  };
  Input.defaultProps = {
    onChange: () => {},
    onFocus: () => {},
    autoFocus: false,
    type: 'text',
  };
  
  export default Input;
  ```

#### 2. InputWithStyleStory 스토리 만들어 스토리북에 추가하기

+ ./src/stories/InputWithStyleStory.jsx 생성

  ```jsx
  // ./src/stories/InputWithStyleStory.jsx
  
  import React from 'react';
  import { storiesOf } from '@storybook/react';
  
  import Input from '../04/InputWithStyle';
  
  storiesOf('InputWithStyle', module)
    .addWithJSX('기본 설정', () => <Input name="name" />)
    .addWithJSX('label 예제', () => <Input name="name" label="이름" />)
    .addWithJSX('value 예제', () => <Input name="name" label="이름" value="us" />)
    .addWithJSX('errorMessage 예제', () => (
      <Input name="name" label="이름" errorMessage="이름을 입력해주세요" />
    ));
  ```

#### 3. 스토리북 서버에 sass-loader 설치하여 머티리얼 디자인 적용하기

스토리북 서버에 sass-loader 라이브러리가 설치되어 있지 않으므로 현재 새로 추가한 컴포넌트에 머티리얼 디자인이 적용되어 있지 않음

+ 루트폴더로 이동하여 명령어 실행

  ```bash
  $ yarn add --dev sass-loader
  ```

#### 4. 스토리북에 sass-loader 설정하기

+ ./.storybook 폴더에 webpack.config.js 생성

  ```jsx
  // ./.storybook/webpack.config.js
  
  const path = require('path');
  
  module.exports = {
    module: {
      rules: [
        {
          test: /\.scss$/,
          loaders: ['sass-loader'],
          include: path.resolve(__dirname, '../'),
        },
      ],
    },
  };
  ```

#### 5. metarialize.scss 임포트

+ ./.storybook/config.js 수정

  ```jsx
  // ./.storybook/config.js
  
  import { configure, setAddon } from '@storybook/react';
  import interopRequireDefault from 'babel-runtime/helpers/interopRequireDefault';
  import JSXAddon from 'storybook-addon-jsx';
  
  import '../src/sass/materialize.scss';
  
  function loadStories() {
    const context = require.context('../src/stories', true, /Story\.jsx$/);
    context.keys().forEach((srcFile) => {
      interopRequireDefault(context(srcFile));
    });
  }
  
  setAddon(JSXAddon);
  configure(loadStories, module);
  ```

  스토리북 서버를 다시 구동한 다음 머티리얼 디자인 적용 확인

  그런데 'errorMessage 예제'의 '이름을 입력해주세요'라는 안내 문구는 빨간색이 아니며 라벨의 위치도 입력칸 안에 있으므로 색상과 라벨 위치의 조정이 필요

  참조: [https://materializecss.com/text-inputs.html](https://materializecss.com/text-inputs.html)의 customer error or success messages 

+ ./src/04/InputWithStyle.jsx 수정

  ```jsx
  // ./src/04/InputWithStyle.jsx
  
  import React, { PureComponent } from 'react';
  import PropTypes from 'prop-types';
  
  class Input extends PureComponent {
    constructor(props) {
      super(props);
      this.setRef = this.setRef.bind(this);
      this.handleChange = this.handleChange.bind(this);
    }
    handleChange(e) {
      const { name, onChange } = this.props;
      if (onChange) {
        onChange(name, e.target.value);
      }
    }
    componentDidMount() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    componentWillUpdate() {
      if (this.props.autoFocus) {
        this.refs.focus();
      }
    }
    setRef(ref) {
      this.ref = ref;
    }
  
    render() {
      const { errorMessage, label, value, name, type } = this.props;
      return (
        <div className="input-field">
          <input
            id={`input_${name}`}
            className={`validate ${errorMessage && 'invalid'}`}
            ref={this.setRef}
            type={type}
            onChange={this.handleChange}
            value={value}
          />
          <label className="active" htmlFor={`input_${name}`}>
            {label}
          </label>
          {errorMessage && (
            <span className="helper-text" data-error={errorMessage}>
              {errorMessage}
            </span>
          )}
        </div>
      );
    }
  }
  
  Input.propTypes = {
    type: PropTypes.oneOf(['text', 'number', 'price']),
    name: PropTypes.string.isRequired,
    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    errorMessage: PropTypes.string,
    label: PropTypes.string,
    onChange: PropTypes.func,
    onFocus: PropTypes.func,
    autoFocus: PropTypes.bool,
  };
  Input.defaultProps = {
    onChange: () => {},
    onFocus: () => {},
    autoFocus: false,
    type: 'text',
  };
  
  export default Input;
  ```

위의 방법을 사용하면 버튼, 아이콘, 테이블 등의 컴포넌트를 머티리얼 스타일로 꾸밀 수 있음

<br>



