# 리액트 컴포넌트

## 01. 컴포넌트를 표현하는 JSX

### JSX란?

+ 자바스크립트에 XML을 추가한 확장형 문법
+ 하나의 파일에 자바스크립트와 HTML을 동시에 작성 가능

### JSX 사용하기

```jsx
import React from 'react';

class App extends React.Component {
  render() {
    return (
      // 아래는 JSX 양식입니다
      <div>
        <img src="https://picsum.photos/200/300" />
        <div>안녕하세요</div>
      </div>
    );
  }
}
export default App;
```

+ render() 함수의 반환값을 보면 HTML과 거의 비슷하지만 XML 마크업 규칙을 따르므로 &lt;와 /의 짝이 맞지 않으면 리액트 엔진이 JSX를 분석할 때 오류 발생

### JSX와 기존 개발 방법의 차이점

1. App 컴포넌트를 사용하지 않고 화면 구성하기

   ```js
   /* ./src/index.js */
   
   // 필수 리액트 구동 모듈
   import React from 'react';
   import ReactDOM from 'react-dom';
   // 초기 화면 구성하는 사용자 코드
   import './index.css'
   import App from './App';
   import * as serviceWorker from './serviceWorker';
   
   // 리액트 엔진이 화면을 출력하는 코드
   // id가 root인 엘리먼트에 컴포넌트를 출력
   ReactDOM.render(<App />, document.getElementById('root'));
   
   // 아래 부분은 서비스워커 구동 코드로 오프라인 모드 작동 시 도움이 되는 모듈
   // If you want your app to work offline and load faster, you can change
   // unregister() to register() below. Note this comes with some pitfalls.
   // Learn more about service workers: http://bit.ly/CRA-PWA
   serviceWorker.unregister();
   ```

2. 만약 App 컴포넌트를 사용하지 않는다면 index.js 파일을 아래와 같이 수정

   ```js
   // src 폴더 안의 index.js를 연 다음 기존 내용을 모두 지우고 아래의 내용을 작성
   let img = document.createElement('img');
   img.setAttribute('src', '<img src="https://picsum.photos/200/300" />');
   let divEl = document.createElement('div');
   divEl.innerText = '안녕하세요';
   let welcomeEl = document.createElement('div');
   welcomeEl.append(img);
   welcomeEl.append(divEl);
   
   let root = document.getElementById('root');
   root.append(welcomeEl);
   ```

3. App 컴포넌트를 사용해 구현했던 코드보다 복잡하고 비효율적이므로 다시 index.js 파일을 원래대로 돌려 놓음.

   ```js
   import React from 'react';
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(<App />, document.getElementById('root'));
   ```

### JSX의 작동 원리

```jsx
...
return ( // 아래의 내용이 JSX가 자바스크립트로 변환된 것
	React.createElement(
    	"div",
        null,
        React.createElement("img", {
            src: "https://picsum.photos/200/300"
        }),
        ,
        null,
        "안녕하세요React.createElement(
        	"div"
        )
    )
);
```

+ 리액트 엔진은 JSX의 XML 구조를 분석하여 위와 같은 자바스크립트 함수 코드로 변환
+ React.createElement() 함수는 리액트 엔진에 포함되어 있으며, 이 함수는 기존 자바스크립트의 document.createElement() 함수를 사용하여 객체 모델을 생성
+ 하지만 리액트를 사용하면 이런 과정들을 일일이 알 필요 없이 JSX로 화면을 빠르게 구성

<br>

## 02. 컴포넌트와 구성 요소

### 컴포넌트의 개념

+ 기존의 웹 프레임워크는 MVC 방식으로 정보, 화면, 구동 코드를 분리하여 관리하는데 정보 담당을 모델(Model), 화면 담당을 뷰(View), 구동 담당을 컨트롤러(Controller)라고 부르는 것에서 MVC 용어가 탄생했고 이 방식은 코드 관리를 효율적으로 할 수 있다는 장점이 있으나 MVC 각 요소의 의존성이 높아 재활용이 어려움
+ 웹 사이트의 화면은 각 요소가 비슷하고 반복적으로 사용한 경우가 많은데 이 점을 착안하여 컴포넌트가 등장
+ 컴포넌트는 MVC의 뷰를 독립적으로 구성하여 재사용할 수 있고 컴포넌트를 통해 새로운 컴포넌트를 쉽게 생성 가능

### 간단한 컴포넌트 추가하고 화면으로 띄우기

1. TodaysPlan 컴포넌트 만들기

   + ./src/03/TodayPlans.jsx 파일 생성

     ```jsx
     import React from 'react';
     
     class TodaysPlan extends React.Component {
       render() {
         return <div className="message-container">놀러가자</div>;
       }
     }
     
     export default TodaysPlan;
     ```

   + RCC 후 탭을 누르면 파일 이름에 맞게 컴포넌트의 뼈대를 생성

2. App 컴포넌트에 TodaysPlan 컴포넌트 추가하기

   + ./src/App.js 수정

     ```jsx
     import React from 'react';
     import TodaysPlan from './03/TodaysPlan';
     
     class App extends React.Component {
       render() {
         return (
           // 아래는 JSX 양식입니다
           <div className="body">
             <TodaysPlan />
           </div>
         );
       }
     }
     export default App;
     ```

### 컴포넌트의 구성요소

| 데이터 구성요소 | 특징                                                         |
| --------------- | ------------------------------------------------------------ |
| 프로퍼티        | 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터  |
| state           | 컴포넌트의 상태를 저장하고 변경할 수 있는 데이터             |
| 컨텍스트        | 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터 |

<br>

## 03. 컴포넌트에 데이터를 전달하는 프로퍼티

+ 프로퍼티는 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용
+ 이 때 프로퍼티값은 수정 불가

### 프로퍼티의 기초

+ 속성(attribute) 형태로 전달되는 값을 프로퍼티라고 함

  ```jsx
  class App extends React.Component {
      render() {
          return (
          	<div className="body">
              	<MyComponent name="message" />
              </div>
          );
      }
  }
  ...
  ```

+ MyComponent 컴포넌트에서는 name이라는 이름의 프로퍼티로 전달받은 "message"라는 문자열값을 render() 함수에서 참조 가능

+ render() 함수에서 this.props.name으로 프로퍼티값을 참조하고 있음

  ```jsx
  class MyComponent extends React.Component {
      render() {
          const name = this.props.name;
          return <span>{name}</span>;
      }
  }
  ```

+ 중요한 것은 프로퍼티가 상위 컴포넌트에서 하위 컴포넌트로 전달된다는 것

+ App 컴포넌트는 MyComponent 컴포넌트를 포함하고 있으며 프로퍼티는 App &gt; MyComponent 방향으로 전달되고 이것을 '단방향으로 데이터가 흐른다'라고 표현

<br>

### 프로퍼티의 다양한 사용 방법

+ 프로퍼티에서는 자바스크립트의 자료형을 모두 사용 가능
+ 이때 프로퍼티의 자료형은 미리 선언해주는 것이 좋은데 프로퍼티의 자료형을 미리 선언하면 리액트 엔진이 프로퍼티로 전달하는 값의 변화(실행 중 수정이 아님)를 효율적으로 감지할 수 있고, 갭라자가 실수로 지정되지 않은 자료형을 프로퍼티에 전달하려고 할 때 경고 메시지로 알려줌(버그 예방)

#### 문자열형 프로퍼티

+ 프로퍼티의 자료형을 선언하는 방법은 리액트에서 제공하는 prop-types를 이용

  ```jsx
  /* ./src/03/PropsComponent */
  
  import React from 'react';
  import PropTypes from 'prop-types';
  
  class PropsComponent extends React.Component {
    render() {
      return (
        <div className="message-container">
          {this.props.name}
        </div>
      );
    }
  }
  
  // 자료형을 선언하는 예제
  PropsComponent.propTypes = {
    name: PropTypes.string,
  };
  
  export default PropsComponent;
  ```

  ```jsx
  /* ./src/App.jsx */
  
  import React from 'react';
  import PropsComponent from './03/PropsComponent';
  
  class App extends React.Component {
    render() {
      return <PropsComponent name="리액트" />;
    }
  }
  export default App;
  ```

#### 다양한 프로퍼티

+ 프로퍼티에 문자열을 전달할 때는 큰따옴표(" ")를 사용하지만 숫자형이나 불리언 등의 값을 전달할 때는 큰따옴표를 사용할 수 없음
+ 문자열 외의 값은 따옴표 대신 중괄호([ ])를 사용

```jsx
/* ./src/03/ChildComponent.jsx */

import React from 'react';
import PropTypes from 'prop-types';

class ChildComponent extends Component {
    render() {
        const {
            boolValue,
            numValue,
            arrayValue,
            objValue,
            nodeValue,
            funcValue,
        } = this.props;

        return (
            <div>
                <span>불리언값: {boolValue}</span>        
                <span>숫자값: {numValue}</span>        
                <span>배열값: {arrayValue}</span>        
                <span>객체값: {String(objValue)}</span>        
                <span>노드값: {nodeValue}</span>        
                <span>함수값: {String(funcValue)}</span>        
            </div>
        );
    }
}

ChildComponent.propTypes = {
    boolValue: PropTypes.bool,
    numValue: PropTypes.number,
    arrayValue: PropTypes.arrayOf(PropTypes.number),
    objValue: PropTypes.object,
    nodeValue: PropTypes.node,
    funcValue: PropTypes.func,
}

export default ChildComponent;
```

+ 객체 구조 분해 할당식을 사용하여 프로퍼티에 전달된 값들을 함수 내의 지역 변수로 재정의하면 this.props.boolValue에서 boolValue와 같이 this.props를 제외하는 방법으로 프로퍼티에 간단히 접근 가능

```jsx
/* ./src/App.jsx */

import React from 'react';
import ChildComponent from './03/ChildComponent';

class App extends React.Component {
  render() {
    const array = [1, 2, 3];
    const obj = { name: '제목', age: 30 };
    const node = <h1>노드</h1>;
    const func = () => {
      console.log('메시지');
    };
    return (
      <ChildComponent
        boolValue={true}
        numValue={1}
        arrayValue={array}
        objValue={obj}
        nodeValue={node}
        funcValue={func}
      />
    );
  }
}
export default App;
```

+ 실수를 줄이기 위해 변수에 객체를 담아 전달하는 방식 선호

#### 불리언 프로퍼티

+ true 또는 false만 정의할 수 있는 특수한 자료형

+ 선언 방식

  ```jsx
  <ChildComponent boolValue /> // ChildComponent에 true 전달
  <ChildComponent /> // ChildComponent에 false 전달
  ```

```jsx
/* ./src/03/BooleanComponent.jsx */

import React from 'react';

class BooleanComponent extends React.Component {
  render() {
    // 불리언 타입을 조건문에 적용한 예제
    const message = this.props.bored ? '놀러가자' : '하던 일 열심히 마무리하기';
    return <div className="message-container">{message}</div>;
  }
}

export default BooleanComponent;
```

```jsx
/* ./src/App.jsx */

import React from 'react';
import BooleanComponent from './03/BooleanComponent';

class App extends React.Component {
  render() {
    return (
      <div>
        <div>
          <b>지루할 때:</b>
          <BooleanComponent bored />
        </div>
        <div>
          <b>즐거울 때:</b>
          <BooleanComponent />
        </div>
      </div>
    );
  }
}
export default App;
```

#### 객체형 프로퍼티

+ 여러 값을 저장할 수 있는 자료형
+ PropTypes.shape를 사용하여 객체 프로퍼티를 정의하면 객체 목록을 한눈에 확인 가능

```jsx
/* ./src/03/ChildComponent2.jsx */

import React from 'react';
import PropTypes from 'prop-types';

class ChildComponent2 extends React.Component {
  render() {
    const { objValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
      </div>
    );
  }
}

ChildComponent2.propTypes = {
  // 객체 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
};

export default ChildComponent2;
```

#### 필수 프로퍼티

+ 특정 컴포넌트에 꼭 전달되어야 하는 프로퍼티가 있다면 프로퍼티를 필수 프로퍼티로 지정

```jsx
/* ./src/03/ChildComponent2.jsx */

import React from 'react';
import PropTypes from 'prop-types';

class ChildComponent2 extends React.Component {
  render() {
    const { objValue, requiredStringValue } = this.props;

    return (
      <div>
        <div>객체값: {String(Object.entries(objValue))}</div>
        <div>필수값: {requiredStringValue}</div>
      </div>
    );
  }
}

ChildComponent2.propTypes = {
  // 객체 프로퍼티
  objValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
  // 필수 프로퍼티
  requiredStringValue: PropTypes.string.isRequired,
};

export default ChildComponent2;
```

```jsx
/* ./src/App.jsx */

import React from 'react';
import ChildComponent2 from './03/ChildComponent2';

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildComponent2 objValue={{ age: 20 }} requiredStringValue="문자" />
      </div>
    );
  }
}
export default App;
```

#### 프로퍼티에 기본값 지정하기

+ 프로퍼티에 기본값을 지정하고 싶다면 기본값을 지정할 컴포넌트의 defaultProps 값을 이용

```jsx
/* ./src/03/DefaultPropsComponent.jsx */

import React from 'react';
import PropTypes from 'prop-types';

class DefaultPropsComponent extends React.Component {
  render() {
    let message1 = '';
    if (this.props.boolValue === false) {
      message1 = 'boolValue 기본값이 false입니다';
    }
    let message2 = '';
    if (this.props.boolValueWithoutDefault === false) {
      message2 = 'boolValueWithoutDefault 기본값이 false입니다';
    }
    return (
      <div class="message-container">
        {message1}
        {message2}
      </div>
    );
  }
}

DefaultPropsComponent.propTypes = {
  boolValue: PropTypes.bool,
  boolValueWithoutDefault: PropTypes.bool,
};

// 기본값을 선언하는 예제
DefaultPropsComponent.defaultProps = {
  boolValue: false,
};

export default DefaultPropsComponent;
```

```jsx
/* ./src/App.jsx */

import React from 'react';
import DefaultPropsComponent from './03/DefaultPropsComponent';

class App extends React.Component {
  render() {
    return (
      <div>
        <DefaultPropsComponent />
      </div>
    );
  }
}
export default App;
```

#### 자식 프로퍼티 사용하기

+ JSX에서는 컴포넌트 하위에 배치한 노드(또는 컴포넌트)를 하위 컴포넌트에서 프로퍼티로 접근 가능

```jsx
/* ./src/App.jsx */

import React from 'react';
import ChildProperty from './03/ChildProperty';

class App extends React.Component {
  render() {
    return (
      <div>
        <ChildProperty>
          <div>
            <span>자식 노드</span>
          </div>
        </ChildProperty>
      </div>
    );
  }
}
export default App;
```

```jsx
/* ./src/03/ChildProperty.jsx */

import React, { Component } from 'react';
import PropTypes from 'prop-types';

class ChildProperty extends Component {
  render() {
    return <div>{this.props.children}</div>;
  }
}
ChildProperty.propTypes = {
  children: PropTypes.node,
};

export default ChildProperty;
```

<br>

## 04. 컴포넌트 상태 관리하기

+ 프로퍼티의 특징은 '컴포넌트 내부에서 값을 바꿀 수 없음'
+ 쇼핑몰에서 물건 수량을 입력하거나 상품에 댓글을 남기는 등 '값을 바꿔야 하는 경우'는?
+ 그럴 때 state를 사용하여 컴포넌트의 상태를 관리

### state로 상태 관리하기

+ state는 '값을 저장하거나 변경할 수 있는 객체'로 보통 버튼을 클릭하거나 값을 입력하는 등의 이벤트와 함께 사용
+ 예를 들어, 어떤 버튼을 눌렀을 때 버튼 색을 변경하거나 모양을 바꿀 때 사용
+ setTimeout() 함수를 통해 4초 후 state에 저장되어 있는 값을 변경하는 예제

```jsx
/* ./src/03/StateExample.jsx  */

import React from 'react';

class StateExample extends React.Component {
  constructor(props) {
    super(props);
    // state 정의
    this.state = {
      loading: true,
      formData: 'no data',
    };
    this.handleData = this.handleData.bind(this);
    setTimeout(this.handleData, 4000);
  }

  handleData() {
    const data = 'new data';
    const { formData } = this.state;
    // state 변경
    this.setState({
      loading: false,
      formData: data + formData,
    });
    // this.state.loading은 현재 true
    console.log('loading값', this.state.loading);
  }

  render() {
    return (
      <div>
        {/* state 데이터는 this.state로 접근 가능 */}
        <span>로딩중: {String(this.state.loading)}</span>
        <span>결과: {this.state.formData}</span>
      </div>
    );
  }
}

export default StateExample;
```

```jsx
/* ./src/App.js */

import React from 'react';
import StateExample from './03/StateExample';

class App extends React.Component {
  render() {
    return (
      <div>
        <StateExample />
      </div>
    );
  }
}
export default App;
```

#### state를 사용할 때 주의할 점

1. 생성자(constructor)에서 반드시 초기화해야 함
2. state값을 변경할 때는 setState() 함수(상태 관리 함수)를 반드시 사용해야 함
3. setState() 함수는 비동기로 처리되며, setState() 코드 이후로 연결된 함수들의 실행이 완료된 시점에 화면 동기화 과정을 거침

#### state값은 setState() 함수로 변경

+ state값을 직접 변경하면 안 되는 이유는 render() 함수로 화면을 그려주는 시점은 리액트 엔진이 정하기 때문
+ 즉, state값을 직접 변경해도 render() 함수는 새로 호출되지 않음 
+ 하지만 setState() 함수를 호출하여 state값을 변경하면 리액트 엔진이 자동으로 render() 함수를 호출하므로 화면에 변경된 state값을 새롭게 출력할 수 있음
+ setState() 함수는 컴포넌트의 생명주기와 깊게 연관되어 있음
+ 실제로 리액트 엔진은 setState() 함수로 state값을 변경하면 몇 단계의 검증 과정을 거쳐 render() 함수를 호출

#### setState() 함수의 인자로 함수를 전달하면 이전 state값을 쉽게 읽을 수 있음

+ setState() 함수의 인자로 함수를 전달하면 이전 state값을 따로 읽는 과정을 생략할 수도 있음
+ 일반 함수와 화살표 함수를 setState() 함수의 인자로 전달하여 state값을 변경하는 예제

```jsx
// 일반 함수를 사용한 예
handleData() {
  this.setState(function(prevState) {
    const newState = {
        loading: false,
        formData: data + prevState.formData,
    };
    return newState;
  });
}

// 화살표 함수를 사용한 예
handleData(data) {
  this.setState(prevState => ({
    loading: false,
    formData: data + prevState.formData
  });
}
```

### 클래스 인스턴스 변수와 forceUpdate() 함수로 state 관리하기

+ 꼭 setState() 함수로 state를 관리할 필요는 없음
+ setState() 함수를 사용하는 이유는 리액트 엔진이 state의 변경과 화면 동기화 과정을 처리해야 하기 때문
+ 만약 출력 검증 작업 없이 함수가 호출될 때마다 새롭게 화면을 출력하고 싶다면 클래스 인스턴스 변수와 화면을 강제로 출력해주는 focusUpdate() 함수를 사용하면 됨

```jsx
/* ./src/03/ForceUpdateExample */

import React from 'react';

class ForceUpdateExample extends React.Component {
  constructor(props) {
    super(props);
    // state 정의
    this.loading = true;
    this.formData = 'no data';

    this.handleData = this.handleData.bind(this);
    // 4초 후 handleData 호출
    setTimeout(this.handleData, 4000);
  }

  handleData() {
    const data = 'new data';
    // state 변경
    this.loading = false;
    this.formData = data + this.formData;
    this.forceUpdate();
  }

  render() {
    return (
      <div>
        {/* state 데이터는 this.state로 접근 가능 */}
        <span>로딩중: {String(this.loading)}</span>
        <span>결과: {this.formData}</span>
      </div>
    );
  }
}

export default ForceUpdateExample;
```

```jsx
/* ./src/App.js */

import React from 'react';
import ForceUpdateExample from './03/ForceUpdateExample';

class App extends React.Component {
  render() {
    return (
      <div>
        <ForceUpdateExample />
      </div>
    );
  }
}
export default App;
```

+ *이 방법은 리액트 성능에 제약이 있으므로 매번 새롭게 화면을 출력해야 되는 경우가 아니라면 가급적 사용하지 않는 것이 좋음*

상<br>

## 05. 컴포넌트의 생명주기

+ 컴포넌트의 생명주기(Lifecycle): 컴포넌트의 생성부터 소멸까지의 과정
+ 컴포넌트는 생명주기마다 함수를 가지고 있는데 이 함수들을 이용하면 특정 시점에 원하는 동작을 하도록 만들 수 있음

### 생명주기 함수 살펴보기

+ 생명주기 함수는 render()를 포함하여 총 8종의 함수가 있는데 리액트 엔진에서 자동으로 호출

#### constructor(props) 함수

+ 맨 처음에 생성될 때 한 번만 호출되며, 상태(status 또는 객체 변수)를 선언할 때 사용
+ constructor() 함수 정의 시에는 **항상 super() 함수를 가장 위에 호출**
  super() 함수에는 프로퍼티와 생명 주기 상태 등을 초기화하는 중요한 과정을 포함

```jsx
...
constructor(props) {
    super(props);
    // 이후에 추가적인 state 데이터 혹은 변수를 선언
} 
...
```

#### render() 함수

+ 데이터가 변경되어 새 화면을 그려야할 때 자동으로 호출되는 함수
+ render() 함수가 반환하는 JSX를 화면에 그려줌

#### static getDerivedStateFromProps(props, state) 함수

+ 정적 함수로 함수 안에서 this.props나 this.state와 같은 방법으로 프로퍼티나 state값에 접근할 수 없음
+ 만약 각 값에 접근하는 경우 반드시 인자로 전달된 props, state를 이용해야 함
+ 이때 props는 상위 컴포넌트에서 전달된 값이며, state는 현재 컴포넌트의 state값
+ 상위 컴포넌트에서 전달받은 프로퍼티로 state 값을 연동할 때 주로 사용되며, 반환값으로 state를 변경

#### componentDidMount() 함수

+ render() 함수가 JSX를 화면에 그린 이후에 호출되는 함수
+ 컴포넌트가 화면에 모두 표현된 이후 해야 하는 작업들은 이곳에서 호출

#### shouldComponentUpdate(nextProps, nextState) 함수

+ 프로퍼티를 변경하거나 setState() 함수를 호출하여 state값을 변경하면 '화면을 새로 출력해야 하는지' 판단
+ **화면을 새로 출력할지 말지 판단하며, 데이터 변화를 비교하는 작업을 포함하므로 리액트 성능에 영향을 많이 줌**
+ 화면 변경을 위해 검증 작업을 해야 하는 경우 이 함수를 사용

#### getSnapshotBeforeUpdate(prevProps, prevState) 함수

+ 컴포넌트의 변경된 내용이 가상 화면에 완성된 이후 호출되는 함수
+ 컴포넌트가 화면에 실제로 출력되기 전에 호출되므로 화면에 출력될 엘리먼트의 크기 또는 스크롤 위치 등의 **DOM 정보에 접근할 때 사용**

#### componentDidUpdate(prevProps, prevState, snapshot) 함수

+ 컴포넌트가 실제 화면에 출력된 이후 호출되는 함수
+ 부모 컴포넌트로부터 전달된 이전 프로퍼티(prevProps)와 이전 state값(prevState)과 함께 getSnapshotBeforeUpdate() 함수에서 반환된 값(snapshot)을 인자로 전달받음
+ 이 값들을 이용하여 스크롤 위치를 옮기거나 커서를 이동시키는 등의 **DOM 정보를 변경할 때 사용**

#### componentWillUnmount() 함수

+ 컴포넌트가 소멸되기 직전에 호출되는 함수
+ 보통 컴포넌트에서 감시하고 있는 작업들을 해제할 때 필요한 함수
+ 예를 들어 컴포넌트에 setInterval() 함수가 사용되었다면 이 함수에서 setInterval() 함수를 clearInterval() 함수로 해제해야 하는데 이러한 해제 작업이 생략되면 메모리 누수 현상이 발생하여 웹 브라우저의 작동이 멈추기도 함

<br>

### 생명주기 함수의 실행 과정 살펴보기

#### 생성 과정의 생명주기 함수들 실행해 보기

```jsx
// ./src/index.js 

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';

ReactDOM.render(<App />, document.getElementById('root'));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister();
```

+ index.js 파일의 ReactDOM.render() 함수가 실행되면 App 컴포넌트의 최초 생명주기 함수인 consructor()가 실행
+ 이때 App 컴포넌트는 자식 컴포넌트를 가지고 있는데 자식 컴포넌트 역시 독립적인 생명주기를 가짐

```jsx
// ./src/03/LifecycleExample.jsx 

import React from 'react';

class LifecycleExample extends React.Component {
  static getDerivedStateFromProps() {
    console.log('getDerivedStateFromProps 호출');
    return {};
  }
  constructor(props) {
    super(props);
    // getDerivedStateFromProps() 함수를 사용하므로
    // 경고 메세지를 건너 뛰기 위해 state 초깃값을 설정
    this.state = {};
    console.log('constructor 호출');
  }
  componentDidMount() {
    console.log('componentDidMount 호출');
  }
  componentDidUpdate() {
    console.log('componentDidUpdate 호출');
  }
  componentWillUnmount() {
    console.log('componentWillUnmount 호출');
  }
  getSnapshotBeforeUpdate() {
    console.log('getSnapshotBeforeUpdate 호출');
    return {};
  }
  shouldComponentUpdate() {
    console.log('shouldComponentUpdate 호출');
    return true;
  }
  render() {
    console.log('render 호출');
    return null;
  }
}

export default LifecycleExample;
```

```jsx
// ./src/App.js 

import React from 'react';
import LifecycleExample from './03/LifecycleExample';

class App extends React.Component {
  render() {
    return (
      <div>
        <LifecycleExample />
      </div>
    );
  }
}
export default App;
```

> **컴포넌트 생성** - constructor - getDerivedStateFromProp - render - componentDidMount - **생성 완료**

<br>

#### 변경 과정의 생명주기 함수들 실행해 보기

```jsx
// ./src/03/LifecycleExample.jsx

...
  componentDidMount() {
    console.log('componentDidMount 호출');
    this.setState({ updated: true });
  }
...
```

+ 변경 과정은 shouldComponentDidUpdate() 함수의 반환값이 true인 경우 진행

```jsx
// ./src/03/LifecycleExample.jsx 

...
  shouldComponentUpdate() {
    console.log('shouldComponentUpdate 호출');
    return false;
  }
...
```

+ shouldComponentUpdate() 함수의 반환값이 false이므로 **리액트 엔진은 데이터 비교 후 변경 사항이 없다**라고 판단하므로 이후 변경 과정의 생명주기 함수 실행되지 않음
+ 만약 shouldComponentUpdate() 함수의 결괏값과 상관없이 화면 동기화 과정을 진행하고 싶다면 forceUpdate() 함수를 사용해야 함
+ 확인을 위해 componentDidUpdate() 함수의 반환값을 false로 두고 LifecycleExample 컴포넌트의 componentDidMount() 함수에 작성했던 setState() 함수를 forceUpdate() 함수로 변경

```jsx
// ./src/03/LifecycleExample.jsx 

...
componentDidMount() {
    this.forceUpdate();
}
...
```

+ 결과를 보면 shouldComponentUpdate() 함수의 반환값은 false지만 **변경 과정의 생명주기 함수가 모두 실행**

<br>

#### 소멸 과정의 생명주기 함수들 실행해 보기

+ 소멸과정은 컴포넌트가 화면에서 생략되면 시작됨

```jsx
// ./src/App.jsx

import React from 'react';
import LifecycleExample from './03/LifecycleExample';

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasDstroyed: false };
  }
  componentDidMount() {
    this.setState({ hasDestroyed: true });
  }
  render() {
    return <div>{this.state.hasDestroyed ? null : <LifecycleExample />}</div>;
  }
}
export default App;
```

+ 콘솔창을 확인해보면 componentWillUnmount() 함수 실행

<br>

#### 카운터 프로그램 만들며 생명주기 함수 사용해 보기

+ 부모 컴포넌트로부터 count의 초깃값을 전달받아 숫자를 증가하는 카운터 프로그램

1. Counter 컴포넌트 작성하기

   ```jsx
   // ./src/03/Counter.jsx
   
   import React from 'react';
   
   class Counter extends React.Component {
     constructor(props) {
       super(props);
       this.state = {
         // count 초깃값을 프로퍼티에서 전달된 값으로 설정
         count: props.count,
       };
       this.increaseCount = this.increaseCount.bind(this);
     }
     increaseCount() {
       this.setState(({ count }) => ({
         count: count + 1,
       }));
     }
     render() {
       return (
         <div>
           현재 카운트: {this.state.count}
           <button onClick={this.increaseCount}>카운트 증가</button>
         </div>
       );
     }
   }
   
   export default Counter;
   ```

2. New Counter 컴포넌트 작성하기

   ```jsx
   // ./src/03/NewCounter.jsx
   
   import React from 'react';
   
   class NewCounter extends React.Component {
     constructor(props) {
       super(props);
       this.state = {};
       this.increaseCount = this.increaseCount.bind(this);
     }
   
     static getDerivedStateFromProps(props, state) {
       const { count } = props;
       return {
         // 프로퍼티에서 전달된 count값을 보관
         count,
         newCount:
           count === state.count
             ? // 프로퍼티가 변경되지 않았다면 기존 state값으로 설정
               state.newCount
             : // 프로퍼티가 변경되었다면 변경된 프로퍼티값으로 설정
               count,
       };
     }
   
     increaseCount() {
       this.setState(({ newCount }) => ({
         newCount: newCount + 1,
       }));
     }
   
     render() {
       return (
         <div>
           현재 카운트: {this.state.newCount}
           <button onClick={this.increaseCount}>카운트 증가</button>
         </div>
       );
     }
   }
   
   export default NewCounter;
   ```

3. App 컴포넌트에 각 컴포넌트를 출력해 보기

   ```jsx
   // ./src/App.jsx
   
   import React from 'react';
   import Counter from './03/Counter';
   import NewCounter from './03/NewCounter';
   
   class App extends React.Component {
     constructor(props) {
       super(props);
       this.state = { count: 10 };
       this.resetCount = this.resetCount.bind(this);
     }
     resetCount() {
       this.setState(({ count }) => ({ count: count + 10 }));
     }
     render() {
       return (
         <div>
           <div>
             <Counter count={this.state.count} />
           </div>
           <div>
             <NewCounter count={this.state.count} />
           </div>
           <button onClick={this.resetCount}>{this.state.count + 10}으로 초기화</button>
         </div>
       );
     }
   }
   export default App;
   ```

   + NewCounter 컴포넌트만 getDerivedStateFromProps() 함수로 App 컴포넌트로부터 갱신된 프로퍼티값을 동기화
   + Counter 컴포넌트는 처음 생성될 때만 프로퍼티값으로 state값을 설정하므로 갱신 과정에서는 state값이 변경되지 않음


<br>

## 06. 클래스형 컴포넌트

+ 클래스형 컴포넌트는 두 종류의 클래스(Component, PureComponent)를 사용

### Component 알아보기

+ 프로퍼티, state와 생명주기 함수가 들어있는 구조의 컴포넌트를 만들 때 사용
+ 항상 render() 함수를 호출

```jsx
import React from 'react';

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log('생성 함수');
  }
  componentDidMount() {} // 상속받은 생명주기 함수
  myMethod() {} //추가 확장 함수
  render() {
    // 상속받은 화면 출력 함수
    return;
  }
}

export default MyComponent;
```

### PureComponent 알아보기

+ Component 클래스를 상속받은 클래스로 shouldComponentUpdate() 함수를 '얕은 비교'를 하도록 재정의
+ '얕은 비교를 통해 데이터가 변경된 경우'에만 render() 함수를 호출

```jsx
// 얕은 비교를 위해 shallow-equal 라이브러리의 shallowEqual() 함수 사용

import React from 'react';
import shallowEqual from 'shallow-equal';

export class PureComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
  }
}
```

+ shallowEqual() 함수로 현재 프로퍼티, state를 갱신한 프로퍼티, state와 얕은 비교를 하고 있음

#### 검증 비교를 위한 얕은 비교 알아보기

+ ==, ===, shallowEqual() 함수를 이용하여 얕은 비교와 그렇지 않은 비교의 차이점

```jsx
import shallowEqual from 'shallow-equal';

const obj = { name: 'park' }
const mylist = [1, 2, 3, obj];
const list1 = [1, 2, 3, obj];
const list2 = [1, 2, 3, { name: 'park' }];
```

```jsx
mylist === list1 // false
```

+ 같은 요소를 가지고 있지만 각각 새롭게 정의된 배열이므로 요소 하나하나를 모두 비교해볼 수 없음
+ 이러한 경우 얕은 비교를 해주는 shallowEqual() 함수를 사용

```jsx
shallowEqual(mylist, list1) // true
```

+ list1과 list2를 넣어보면 false가 나오는데 list2의 마지막 요소는 obj와 같은 내용을 포함하고 있지만 새 객체이므로 false 반환

```jsx
shallowEqual(list1, list2) // false
```

+ 내용물을 모두 비교하지 않는 이유는 비교 검사 작업이 성능에 영향을 끼치기 때문
+ PureComponent 클래스로 선언한 컴포넌트에서는 shouldComponentUpdate() 함수에서 shallowEqual() 함수로 얕은 비교를 하여 데이터의 변경이 있으면 화면을 새로 출력하고 Component 클래스로 선언한 컴포넌트는 이러한 비교 과정 없이 항상 새로 출력

#### PureComponent와 불변 변수로 성능 높이기

+ 불변 변수를 활용해 정보가 바뀔 때마다 새 배열을 할당하는 방식으로 비교 속도를 최적화할 수 있음

<br>

## 07. 함수형 컴포넌트

+ 조금 길게 표현하여 state가 없는 함수형 컴포넌트(Stateless Functional Component)라고 부름(=SFC)
+ state를 포함하지 않으며 데이터를 받아 출력할 컴포넌트를 반환

### 함수형 컴포넌트의 구조 알아보기

+ 입력받은 프로퍼티와 컨텍스트를 이용하여 화면 출력

  > 데이터(프로퍼티, 컨텍스트) => 함수 컴포넌트 => 출력할 컴포넌트(JSX)

```jsx
import React from 'react';
import PropTypes from 'props-types';

function SFC(props, context) {
  // 클래스형 컴포넌트의 this.props값과 동일
  const { somePropValue } = props;
  // 클래스형 컴포넌트의 this.context와 동일
  const { someContextValue } = context;
  return <h1>Hello, {somePropValue}</h1>;
}

SFC.propTypes = { somePropValue: PropTypes.any };
SFC.defaultProps = { somePropValue: 'default value' };

export default SFC;
```

+ 함수형 컴포넌트에는 클래스 선언이 없으므로 상위 컴포넌트로부터 전달받은 프로퍼티와 컨텍스트만을 이용하여 화면을 구성
+ **함수형 컴포넌트는 state와 생명주기 함수를 사용할 수 없음**
+ 단순한 구조의 UI 컴포넌트를 제작할 때 많이 사용

#### 함수형 컴포넌트 사용해 보기

```jsx
// 클래스형 컴포넌트

import React from 'react';

class SFCTodayPlanApp extends React.Component {
  render() {
    const { onButtonClick, hasPlan } = this.props;
    return (
      <div className="body">
        {hasPlan ? <TodaysPlan /> : null}
        <button onClick={onButtonClick}>계획없음</button>
      </div>
    );
  }
}

export default SFCTodayPlanApp;
```

```jsx
// 함수형 컴포넌트

import React from 'react';

function TodaysPlanApp(props) {
  const { onButtonClick, hasPlan } = this.props;
  return (
    <div className="body">
      {hasPlan ? <TodaysPlan /> : null}
      <button onClick={onButtonClick}>계획없음</button>
    </div>
  );
}
```

<br>

## 08. 배열 컴포넌트

+ 자바스크립트의 배열은 다양한 자료형을 저장할 수 있는 성질을 이용하여 XML와 JSX도 배열에 저장 가능

```jsx
// JSX 배열
const componentList = [<MyComponent />, <MySecondComponent />, <b>Hi</b>];
```

### 배열 컴포넌트를 위한 map() 함수 사용 방법

+ map() 함수를 사용하면 배열로 저장된 데이터를 바로 JSX로 변경할 수 있음
+ todoList에 저장된 객체를 map() 함수를 통해 JSX로 변경

```jsx
const todoList = [
  { taskName: '빨래하기', finished: false },
  { taskName: '공부하기', finished: true },
];
const todos = todoList.map(todo => <div>{todo.taskName}</div>);
// 결과
// [<div>빨래하기</div>, <div>공부하기</div>]
```

+ 배열 데이터를 컴포넌트의 프로퍼티에 전달 가능

```jsx
const todoList = [
  { taskName: '빨래하기', finished: false },
  { taskName: '공부하기', finished: true },
];
const todos = todoList.map(todo => <TodoTask taskName={todo.taskNAme} />);
// 결과
// [<TodoTask taskName="빨래하기" />, <TodoTask taskName="공부하기" />]
```

+ 가격표 목록을 출력한 예제

```jsx
import React from 'react';

class ListExample extends React.PureComponent {
  render() {
    const priceList = [1000, 2000, 3000, 4000];
    const prices = priceList.map((price) => <div>가격: {price}원</div>);
    return (
      <div>
        <label>가격 목록</label>
        {prices}
      </div>
    );
  }
}

export default ListExample;
```

### map() 함수를 사용하여 배열 컴포넌트 출력하기

```jsx
...
render() {
  const todoList = [
    { taskName: '빨래하기', finished: false },
    { taskName: '공부하기', finished: true },
  ];
  return (
    <div>
    	<div>{todo[0].taskName}</div>  
    	<div>{todo[1].taskName}</div>  
    </div>
  )
}
...
```

+ map() 함수를 이용하여 위의 코드를 수정 가능

```jsx
...
render() {
  const todoList = [
    { taskName: '빨래하기', finished: false },
    { taskName: '공부하기', finished: true },
  ];
  const todos = todoList.map(todo => <div>{todo.taskName}</div>)
  return (
    <div>
      {todos}
    </div>
  )
}
...
```

+ map() 함수는 반환된 배열을 반환하므로 다음과 같이 더 간략하게 표현 가능

```jsx
...
render() {
  const todoList = [
    { taskName: '빨래하기', finished: false },
    { taskName: '공부하기', finished: true },
  ];
  return (
    <div>
      {todoList.map(todo => <div>{todo.taskName}</div>)}
    </div>
  )
}
...
```

+ 배열 컴포넌트의 경우 배열 요소의 개수만큼 반복하므로 성능에 영향을 많이 줌 
+ 따라서 **배열 컴포넌트에는 키값을 key로 꼭 정의**해주어야 함
+ 키값을 정의하여 추력한 배열 컴포넌트는 다시 출력해야 하는 경우 리액트 엔진이 기존의 컴포넌트를 재활용하여 성능을 높일 수 있기 때문

```jsx
...
render() {
  const todoList = [
    { taskName: '빨래하기', finished: false },
    { taskName: '공부하기', finished: true },
  ];
  return (
    <div>
      {todoList.map((todo, i) => <div key={`tl_${i}`}>{todo.taskName}</div>)}
    </div>
  )
}
...
```

+ filter 함수를 추가하여 배열 항목에서 finished의 값이 false인 항목을 제외하는 등의 항목을 변형하는 경우 인덱스 번호를 키로 사용한다면 키값이 함께 변경되는 문제가 발생

```jsx
{todoList.filter(todo => todo.finished).map((todo, i) => (
  <div key={`tl_${i}`}>{todo.taskName}</div>
))}
```

+ 위의 경우 '공부하기'의 키값은 'tl_1'에서 'tl_0'으로 바뀌는데 리액트가 '공부하기' 항목의 컴포넌트를 재활용하지 못하고 새로 그리게 되어 '비효율적 문제'가 발생
+ 이 문제를 해결하기 위해서는 키값으로 고유한 배열 항목을 사용

```jsx
import React from 'react';

class TodoList extends React.Component {
  render() {
    const todoList = [
      { taskName: '빨래하기', finished: false },
      { taskName: '공부하기', finished: true },
    ];
    return (
      <div>
        {todoList.map((todo) => (
          <div key={todo.taskName}>{todo.taskName}</div>
        ))}
      </div>
    );
  }
}

export default TodoList;
```

### render() 함수에서 여러 개의 JSX 노드 반환하기

+ render() 함수는 트리 구조의 노드를 반환
+ 리액트는 트리 구조의 노드 외에도 배열 구조의 노드를 반환 가능
+ 예를 들어 Option 컴포넌트를 3개 반환해야 하는 경우 다음과 같이 코드를 생각해볼 수 있으나 이 코드는 동작하지 않음(render() 함수는 트리 구조의 노드를 반환해야 하기 때문)

```jsx
...
// 잘못 사용된 예
render() {
  return (
    <input type="radio" name="option1" value="1" label="1개" />
    <input type="radio" name="option1" value="2" label="2개" />
    <input type="radio" name="option1" value="3" label="3개" />
  );
}
...
```

+ 리액트 16.3 버전까지 render() 함수는 트리 구조의 노드 1개만 반환할 수 있음
+ 여러 개의 노드를 반환하고 싶은 경우 의미 없는 최상위 노드를 추가해야 했음

```jsx
...
// 어쩔 수 없이 div 엘리먼트를 추가
render() {
  return (
    <div>
      <input type="radio" name="option1" value="1" label="1개" />
      <input type="radio" name="option1" value="2" label="2개" />
      <input type="radio" name="option1" value="3" label="3개" />
    </div>
  );
}
...
```

+ 리액트 16.3 버전 이후 '의미 없는 노드를 추가하는 것'이 개선되었음
+ React.Fragment 컴포넌트가 추가

```jsx
...
render() {
  return (
    <React.Fragment>
      <input type="radio" name="option1" value="1" label="1개" />
      <input type="radio" name="option1" value="2" label="2개" />
      <input type="radio" name="option1" value="3" label="3개" />
    </React.Fragment>
  );
}
...
```

+ React.Fragment 컴포넌트는 여러 노드를 반환할 때 사용
+ 즉, HTML로 변환되지 않으며 아래와 같이 사용 가능

```jsx
...
render() {
  return (
    <>
      <input type="radio" name="option1" value="1" label="1개" />
      <input type="radio" name="option1" value="2" label="2개" />
      <input type="radio" name="option1" value="3" label="3개" />
    </>
  );
}
...
```

+ map() 함수를 사용하면 감싸는 것조차 생략 가능

```jsx
...
render() {
  return [1, 2, 3].map((num) =>{
    <input type="radio" name="option1" key{`${num}`} value={num} label={`${num}개`} />   
  });
}
...
```

<br>

## 09. 컴포넌트에서 콜백 함수와 이벤트 처리하기

+ 하위 컴포넌트에서 프로퍼티를 변경해야 할 때는 프로퍼티 원본을 수정할 수 있는 함수를 하위 컴포넌트에 제공
+ 콜백 햄수는 정의된 위치에서 실행되지 않고, 이후 특정 상황(이벤트, 다른 함수 호출 등)에서 실행되는 함수이므로 콜백 함수를 프로퍼티로 전달

### 콜백 함수로 프로퍼티 수정해 보기

```jsx
// ./src/03.CounterApp.jsx


```

