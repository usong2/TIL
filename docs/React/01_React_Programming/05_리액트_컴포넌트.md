# 리액트 컴포넌트

## 01. 컴포넌트를 표현하는 JSX

### JSX란?

+ 자바스크립트에 XML을 추가한 확장형 문법
+ 하나의 파일에 자바스크립트와 HTML을 동시에 작성 가능

### JSX 사용하기

```jsx
import React from 'react';

class App extends React.Component {
  render() {
    return (
      // 아래는 JSX 양식입니다
      <div>
        <img src="https://picsum.photos/200/300" />
        <div>안녕하세요</div>
      </div>
    );
  }
}
export default App;
```

+ render() 함수의 반환값을 보면 HTML과 거의 비슷하지만 XML 마크업 규칙을 따르므로 &lt;와 /의 짝이 맞지 않으면 리액트 엔진이 JSX를 분석할 때 오류 발생

### JSX와 기존 개발 방법의 차이점

1. App 컴포넌트를 사용하지 않고 화면 구성하기

   ```js
   /* ./src/index.js */
   
   // 필수 리액트 구동 모듈
   import React from 'react';
   import ReactDOM from 'react-dom';
   // 초기 화면 구성하는 사용자 코드
   import './index.css'
   import App from './App';
   import * as serviceWorker from './serviceWorker';
   
   // 리액트 엔진이 화면을 출력하는 코드
   // id가 root인 엘리먼트에 컴포넌트를 출력
   ReactDOM.render(<App />, document.getElementById('root'));
   
   // 아래 부분은 서비스워커 구동 코드로 오프라인 모드 작동 시 도움이 되는 모듈
   // If you want your app to work offline and load faster, you can change
   // unregister() to register() below. Note this comes with some pitfalls.
   // Learn more about service workers: http://bit.ly/CRA-PWA
   serviceWorker.unregister();
   ```

2. 만약 App 컴포넌트를 사용하지 않는다면 index.js 파일을 아래와 같이 수정

   ```js
   // src 폴더 안의 index.js를 연 다음 기존 내용을 모두 지우고 아래의 내용을 작성
   let img = document.createElement('img');
   img.setAttribute('src', '<img src="https://picsum.photos/200/300" />');
   let divEl = document.createElement('div');
   divEl.innerText = '안녕하세요';
   let welcomeEl = document.createElement('div');
   welcomeEl.append(img);
   welcomeEl.append(divEl);
   
   let root = document.getElementById('root');
   root.append(welcomeEl);
   ```

3. App 컴포넌트를 사용해 구현했던 코드보다 복잡하고 비효율적이므로 다시 index.js 파일을 원래대로 돌려 놓음.

   ```js
   import React from 'react';
   import ReactDOM from 'react-dom';
   import App from './App';
   
   ReactDOM.render(<App />, document.getElementById('root'));
   ```

### JSX의 작동 원리

```jsx
...
return ( // 아래의 내용이 JSX가 자바스크립트로 변환된 것
	React.createElement(
    	"div",
        null,
        React.createElement("img", {
            src: "https://picsum.photos/200/300"
        }),
        ,
        null,
        "안녕하세요React.createElement(
        	"div"
        )
    )
);
```

+ 리액트 엔진은 JSX의 XML 구조를 분석하여 위와 같은 자바스크립트 함수 코드로 변환
+ React.createElement() 함수는 리액트 엔진에 포함되어 있으며, 이 함수는 기존 자바스크립트의 document.createElement() 함수를 사용하여 객체 모델을 생성
+ 하지만 리액트를 사용하면 이런 과정들을 일일이 알 필요 없이 JSX로 화면을 빠르게 구성

<br>

## 02. 컴포넌트와 구성 요소

### 컴포넌트의 개념

+ 기존의 웹 프레임워크는 MVC 방식으로 정보, 화면, 구동 코드를 분리하여 관리하는데 정보 담당을 모델(Model), 화면 담당을 뷰(View), 구동 담당을 컨트롤러(Controller)라고 부르는 것에서 MVC 용어가 탄생했고 이 방식은 코드 관리를 효율적으로 할 수 있다는 장점이 있으나 MVC 각 요소의 의존성이 높아 재활용이 어려움
+ 웹 사이트의 화면은 각 요소가 비슷하고 반복적으로 사용한 경우가 많은데 이 점을 착안하여 컴포넌트가 등장
+ 컴포넌트는 MVC의 뷰를 독립적으로 구성하여 재사용할 수 있고 컴포넌트를 통해 새로운 컴포넌트를 쉽게 생성 가능

### 간단한 컴포넌트 추가하고 화면으로 띄우기

1. TodaysPlan 컴포넌트 만들기

   + ./src/03/TodayPlans.jsx 파일 생성

     ```jsx
     import React from 'react';
     
     class TodaysPlan extends React.Component {
       render() {
         return <div className="message-container">놀러가자</div>;
       }
     }
     
     export default TodaysPlan;
     ```

   + RCC 후 탭을 누르면 파일 이름에 맞게 컴포넌트의 뼈대를 생성

2. App 컴포넌트에 TodaysPlan 컴포넌트 추가하기

   + ./src/App.js 수정

     ```jsx
     import React from 'react';
     import TodaysPlan from './03/TodaysPlan';
     
     class App extends React.Component {
       render() {
         return (
           // 아래는 JSX 양식입니다
           <div className="body">
             <TodaysPlan />
           </div>
         );
       }
     }
     export default App;
     ```

### 컴포넌트의 구성요소

| 데이터 구성요소 | 특징                                                         |
| --------------- | ------------------------------------------------------------ |
| 프로퍼티        | 상위 컴포넌트에서 하위 컴포넌트로 전달되는 읽기 전용 데이터  |
| state           | 컴포넌트의 상태를 저장하고 변경할 수 있는 데이터             |
| 컨텍스트        | 부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터 |

<br>

## 03. 컴포넌트에 데이터를 전달하는 프로퍼티

+ 프로퍼티는 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용
+ 이 때 프로퍼티값은 수정 불가

### 프로퍼티의 기초

+ 속성(attribute) 형태로 전달되는 값을 프로퍼티라고 함

  ```jsx
  class App extends React.Component {
      render() {
          return (
          	<div className="body">
              	<MyComponent name="message" />
              </div>
          );
      }
  }
  ...
  ```

+ MyComponent 컴포넌트에서는 name이라는 이름의 프로퍼티로 전달받은 "message"라는 문자열값을 render() 함수에서 참조 가능

+ render() 함수에서 this.props.name으로 프로퍼티값을 참조하고 있음

  ```jsx
  class MyComponent extends React.Component {
      render() {
          const name = this.props.name;
          return <span>{name}</span>;
      }
  }
  ```

+ 중요한 것은 프로퍼티가 상위 컴포넌트에서 하위 컴포넌트로 전달된다는 것

+ App 컴포넌트는 MyComponent 컴포넌트를 포함하고 있으며 프로퍼티는 App &gt; MyComponent 방향으로 전달되고 이것을 '단방향으로 데이터가 흐른다'라고 표현

<br>

### 프로퍼티의 다양한 사용 방법

+ 프로퍼티에서는 자바스크립트의 자료형을 모두 사용 가능
+ 이때 프로퍼티의 자료형은 미리 선언해주는 것이 좋은데 프로퍼티의 자료형을 미리 선언하면 리액트 엔진이 프로퍼티로 전달하는 값의 변화(실행 중 수정이 아님)를 효율적으로 감지할 수 있고, 갭라자가 실수로 지정되지 않은 자료형을 프로퍼티에 전달하려고 할 때 경고 메시지로 알려줌(버그 예방)

#### 문자열형 프로퍼티

+ 프로퍼티의 자료형을 선언하는 방법은 리액트에서 제공하는 prop-types를 이용

  ```jsx
  /* ./src/03/PropsComponent */
  
  import React from 'react';
  import PropTypes from 'prop-types';
  
  class PropsComponent extends React.Component {
    render() {
      return (
        <div className="message-container">
          {this.props.name}
        </div>
      );
    }
  }
  
  // 자료형을 선언하는 예제
  PropsComponent.propTypes = {
    name: PropTypes.string,
  };
  
  export default PropsComponent;
  ```

  ```jsx
  /* ./src/App.jsx */
  
  import React from 'react';
  import PropsComponent from './03/PropsComponent';
  
  class App extends React.Component {
    render() {
      return <PropsComponent name="리액트" />;
    }
  }
  export default App;
  ```

#### 다양한 프로퍼티

+ 프로퍼티에 문자열을 전달할 때는 큰따옴표(" ")를 사용하지만 숫자형이나 불리언 등의 값을 전달할 때는 큰따옴표를 사용할 수 없음
+ 문자열 외의 값은 따옴표 대신 중괄호([ ])를 사용

```jsx
/* ./src/03/ChildComponent.jsx */

import React from 'react';
import PropTypes from 'prop-types';

class ChildComponent extends Component {
    render() {
        const {
            boolValue,
            numValue,
            arrayValue,
            objValue,
            nodeValue,
            funcValue,
        } = this.props;

        return (
            <div>
                <span>불리언값: {boolValue}</span>        
                <span>숫자값: {numValue}</span>        
                <span>배열값: {arrayValue}</span>        
                <span>객체값: {String(objValue)}</span>        
                <span>노드값: {nodeValue}</span>        
                <span>함수값: {String(funcValue)}</span>        
            </div>
        );
    }
}

ChildComponent.propTypes = {
    boolValue: PropTypes.bool,
    numValue: PropTypes.number,
    arrayValue: PropTypes.arrayOf(PropTypes.number),
    objValue: PropTypes.object,
    nodeValue: PropTypes.node,
    funcValue: PropTypes.func,
}

export default ChildComponent;
```

