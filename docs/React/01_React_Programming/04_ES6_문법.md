# ES6 문법

## 1. 템플릿 문자열(template string)

+ 문자열 안에 변수와 연산식을 혼합하여 사용

### 기존 자바스크립트의 문자열 사용 방법

```javascript
let string1 = '안녕하세요';
let string2 = '반갑습니다';
let greeting = string1 + ' ' + string2;
let product = { name: '도서', price: '4200원' };
let message = '제품' + product.name + '의 가격은 ' + product.price + '입니다';
let multiline = '문자열1\n문자열2';
let value1 = 1;
let value2 = 2;
let boolValue = false;
let operator1 = '곱셈값은 ' + (value1 * value2) + '입니다';
let operator2 = '불리언값은 ' + (boolValue ? '참' : '거짓') + '입니다';
```

### ES6 문자열 사용 방법

```javascript
let string1 = '안녕하세요';
let string2 = '반갑습니다';
let greeting = `${string1} ${string}`;
let product = { name: '도서', price: '4200원' };
let message = `제품 ${product.name}의 가격은 ' ${product.price}입니다`;
let multiline = `문자열1
문자열2`;
let value1 = 1;
let value2 = 2;
let boolValue = false;
let operator1 = `곱셈값은 ${value1 * value2}입니다`;
let operator2 = `${boolValue ? '참' : '거짓'}입니다`;
```

#### TEST

```javascript
let cart = { name: '도서', price: 1500 };
let getTotal = function(cart) { 
	return cart.price + '원';
}
let myCart = '장바구니에 ' + cart.name + '가 있습니다. 총 금액은 ' + getTotal(cart) + '입니다.'; 
```

```javascript
let cart = { name: '도서', price: 1500 };
let getTotal = function(cart) { 
    return `${cart.price}원`;
}
let myCart = `장바구니에 ${cart.name}가 있습니다. 총 금액은 ${getTotal(cart)}입니다.`;

```

<br>

## 2. 전개 연산자

+ 나열형 자료를 추출하거나 연결할 때 사용합니다. 
+ 배열이나 객체, 변수명 앞에 마침표 세 개(...)를 입력하여 사용합니다. 
+ 배열, 객체, 함수 인자 표현식([], {}, ()) 안에서만 사용해야 합니다.

### 배열 전개

#### 기존 자바스크립트 배열 전개 사용 방법

```javascript
let array1 = ['one', 'two'];
let array2 = ['three', 'four'];
let combined = [array1[0], array1[1], array2[0], array2[1]];
let combined = array1.concat(array2);
let combined = [].concat(array1, array2);
let first = array1[0];
let second = array1[1];
let three = array[2] || 'empty';
function func() {
    let args = Array.prototype.slice.call(this, arguments);
    let first = arg[0];
    let others - args.slice(1, args.length);
}
```

#### ES6 배열 전개 연산자 사용 방법

```javascript
let array1 = ['one', 'two'];
let array2 = ['three', 'four'];
const combined = [...aray1, ...array2]; // combined = ['one', 'two', 'three', 'four'];
const [first, second, three = 'empty', ...others] = array1;
// first = 'one', second = 'two', three = 'empty', others = []
func(...args) { var [first, ...others] = args; }
```

### 객체 전개

#### 기존 객체 내장 함수 사용 방법

```javascript
let objectOne = { one: 1, two: 2, other: 0 };
let objectTwo = { three: 3, four: 4, other: -1 };
let combined = {
    one: objectOne.one,
    two: objectOne.two,
    three: objectTwo.three,
    four: objectTwo.four,
};
let combined = Object.assign({}, objectOne, objectTwo); 
// combined = { one: 1, two: 2, three: 3, four: 4, other: -1 }
let combined = Object.assign({}, objectTwo, objectOne);
// combined = { one: 1, two: 2, three: 3, four: 4, other: 0 }
let others = Object.assign({}, combined);
delete others.other;
// others = { one: 1, two: 2, three: 3, four: 4 }
```

#### ES 전개 연산자 사용 방법

```javascript
let objectOne = { one: 1, two: 2, other: 0 };
let objectTwo = { three: 3, four: 4, other: -1 };
let combined - {
    ...objectOne,
    ...objectTwo
};
// combined = { one: 1, two: 2, three: 3, four: 4, other: -1 }
let combined = {
    ...objectTwo,
    ...objectOne,
};
// combined = { one: 1, two: 2, three: 3, four: 4, other: 0 }
let { other, ...others } = combined;
// others = { one: 1, two: 2, three: 3, four: 4 }
```

<br>

## 3. 가변 변수와 불변 변수

### ES6의 가변 변수 사용 방법

+ 가변 변수는 let 키워드로 선언 
+ let으로 선언한 변수는 읽거나 수정 가능

```javascript
let num = 1;
num = num * 3;
let str = '문자';
str = '다른 문자';
let arr = [];
arr = [1, 2, 3];
let obj = {};
obj = { name: '새 객체' };
```

### ES의 불변 변수 사용 방법

+ 불변 변수는 const 키워드로 선언
+ const로 선언한 변수는 읽기만 가능
+ **값을 다시 할당할 수 없으나 값을 변경하는 것은 가능**

```javascript
const num = 1;
num = 3; // 자료형 오류 발생
const str = '문자';
str = '새 문자'; // 자료형 오류 발생
const arr = [];
arr = [1, 2, 3]; // 자료형 오류 발생
obj = { name: '내 이름' };
```

+ 자바스크립트 내장 함수(push, splice, ...)를 사용하면 값을 변경 가능

```javascript
const arr2 = [];
arr2.push(1); // arr2 = [1]
arr2.splice(0, 0, 0); // arr2 = [0, 1]
arr2.pop(); // arr2 = [1]
const obj2 = {};
obj2['name'] = '내이름'; // obj2 = { name: '내이름' }
Object.assign(obj2, { name: '새이름' }); // obj2 = { name: '새이름' }
delete obj2.name; // obj2 = {}
```

+ 불변 변수는 값을 수정할 수 없으나 수정하는 경우 '무결성 제약 조건에 위배되었다'라고 함
+ 무결성을 유지하면서 불변 변수의 값을 수정해야 하는 경우 수정할 불변 변수를 새로 만들어 새 값을 할당하는 방법으로 수정한다면 무결성 제약 조건을 지킬 수 있음

```javascript
const num1 = 1;
const num2 = num1 * 3; // num2 = 3;
const str1 = '문자';
const str2 = str1 + '추가'; // str2 = '문자추가'
const arr3 = [];
const arr4 = arr3.concat(1); // arr4 = [1]
const arr5 = [...arr4, 2, 3]; // arr5 = [1, 2, 3]
const arr6 = arr5.slice(0, 1); // arr6 = [1], arr5 = [1, 2, 3]
const [first, ...arr7] = arr5; // arr7 = [2, 3], first = 1
const obj3 = { name: '내이름', age: 20 };
const objValue = { name: '새이름', age: obj3.age };
const obj4 = { ...obj3, name: '새이름' }; // obj4 = { name: '새이름', age: 20 }
const { name, ...obj5 } = obj4; // obj5 = { age: 20 }
```

+ 배열에 새로운 값을 추가할 때는 push() 함수 대신 concat() 함수를, 삭제할 때는 pop(), shift() 함수 대신 slice(), concat() 함수에 전개 연산자를 조합하여 사용
+ 새 값을 할당하는 것이 아닌 기존의 값을 이용(추출)하여 새 불변 변수에 할당하는 것은 무결성 제약 조건을 위반하지 않음

| 가변 내장 함수         | 무결성 내장 함수                               |
| ---------------------- | ---------------------------------------------- |
| push(...items)         | concat(...items)                               |
| splice(s, c, ...items) | slice(0, s)<br />.concat(...items, slice(s+c)) |
| pop()                  | slice(0, len - 1)                              |
| shift()                | slice(1)                                       |

+ 불변 변수를 사용하면 무결성 제약 규칙에 의해 변수가 변하는 시점을 쉽게 파악할 수 있으므로 수정 전과 후의 변수 값을 비교할 수 있어 가변 변수보다 유용