# 재사용 가능한 모듈적인 코드로

대규모 소프트웨어 프로젝트에서 매우 중요한 특성 중 하나인 **모듈성**은, 프로그램을 더 작고 독립적인 부분으로 나눌 수 있는 정도를 뜻합니다. 모듈적 프로그램은 자신을 구성하는 부속들로부터 자신의 의미를 도출할 수 있다는 점에서 뚜렷이 구분됩니다. 이들 부속(하위 프로그램)은 다른 시스템에 그대로 또는 더 쪼개서 통합할 수 있는 재사용 가능한 컴포넌트입니다. 개발자의 생산성을 높일 뿐만 아니라 코드 유지보수성 및 가독성을 향상시키는 데에도 도움이 되지요. 아주 쉬운 예로, 유닉스 셸 프로그램을 떠올려봅시다. 

```jsx
tr 'A-Z' 'a-z' < sords.in | uniq | sort
```

유닉스 프로그래밍을 한 번도 안 해본 사람이라도 이 코드가 단어를 대문자에서 소문자로 바꾸고 중복을 제거한 다음 그 단어들을 정렬하는 순차적인 과정임을 알 수 있습니다. 서로 다른 명령어는 파이프 연산자(|)로 연결합니다. 입/출력을 이렇게 명료한 규약에 맞게 서술하고 작은 프로그램들을 서로 이어 붙여 복잡한 작업을 수행할 수 있다는 게 경이롭지 않나요? 같은 프로그램을 기존 명령형 자바스크립트로 작성하려면, 루프를 반복하며 문자열을 비교하고, 전역 변수로 상태를 추적하고, 조건문도 몇 개 넣어야 할 겁니다. 이런 코드는 그 자체로 모듈적인 코드가 아니지요. 프로그래밍 세계에서는 대부분 문제를 더 작은 조각으로 쪼갠 후, 이들을 다시 재구성하여 해법을 완성하는 방식을 선호합니다. 

이전에는 고수준 함수를 써서 하나의 래퍼 객체를 중심으로 단단히 결합된 메서드 체인으로 문제를 해결했습니다. 지금부터는 이 아이디어를 더 발전시켜 함수 합성을 통해 느슨하게 결합된 파이프라인을 만들고, 보다 유연한 독립적인 컴포넌트들을 재료 삼아 전체 프로그램을 구축하겠습니다. 컴포넌트 각자로는 별로 가치가 없지만, 서로 뭉치면 작게는 함수, 크게는 온전한 모듈 형태로 만들어 전체 프로그램에 의미를 부여할 수 있습니다. 

코드 모듈화는 결코 쉬운 작업이 아닙니다. 선언적 함수 파이프라인을 통해 무인수 형태로 문제를 해결하려면 먼저 코드를 적정 수준으로 추상해야 합니다. 이번에는 람다JS라는 함수형 프레임워크의 도움을 받아 부분 평가 및 합성 같은 주요 함수형 기법을 어떻게 구사하는지 살펴보겠습니다. 

## 메서드 체인 대 함수 파이프 라인

함수들을 메서드 체인으로 연결하는 코드를 보며 함수형 프로그래밍의 독특한 개발 스타일을 엿보았습니다. **파이프라이닝**은 함수를 연결하는 또 다른 기법입니다. 함수는 입력과 출력을 기준으로 서술하는 것이 유용합니다. 앞으로 자주 보게 되겠지만, 함수형 커뮤니티에서는 다음과 같은 하스켈 언어 표기법을 많이 씁니다.

```jsx
<function-name>         ::              <Inputs*>       ->    <Output>
    함수명      형식을 알려주는 연산자  0개 이상의 입력 형식       단일 출력 형식
```

함수형 프로그래밍에서 함수란 입력 형식과 출력 형식 간의 수학적인 매핑을 뜻합니다. 가령 문자열을 받아 불리언을 반환하는 isEmpty 함수는 이렇게 표기합니다. 

```jsx
isEmpty :: String -> Boolean
```

이 함수는 주어진 문자열을 전부 불리언 값으로, 참조 투명하게 매핑합니다. 다음은 이 함수를 자바스크립트 람다 표현식으로 나타낸 것입니다. 

```jsx
// isEmpty :: String -> Boolean
const isEmpty = s => !s || !s.trim();
```

함수 체이닝과 파이프라이닝을 이해하려면 함수를 형식 간의 매핑으로 바라보아야 합니다.

+ 메서드를 체이닝(단단한 결합, 제한된 표현성)
+ 함수 파이프라인을 배열(느슨한 결합, 유연성)

### 메서드를 여럿 체이닝

map과 filter 함수는 배열을 넘겨받아 새 배열을 돌려준다고 했습니다. 암시적으로 생성된 LodashWrapper 객체를 매개로 이들 함수를 서로 체이닝하면 물밑에서 전혀 새로운 자료구조를 만듭니다. 예제 코드를 다시 볼까요?

```jsx
_.chain(names)	// 뒤에 "점(.)"을 붙여 로대시JS의 다른 메서드를 호출
	.filter(isValid)
	.map(s => s.replace(/_/, ' '))
	.uniq()
	.map(_.startCase)
	.sort()
	.value();
```

명령형 코드에 비해 분명히 구조적으로 향상됐고 가독성도 엄청 좋아졌습니다. 다만, 자신을 소유한 객체에 부자연스럽게 매여 있어 아쉽게도 체인에서 실행 가능한 메서드 가짓수가 줄고 코드의 표현성도 제약을 받습니다. 이 예제는 로대시JS가 제공하는 연산만 쓸 수 있기 때문에 다른(또는 직접 만든) 라이브러리 함수를 쉽게 연결할 수 있습니다. 

> 믹스인으로 객체에 기능을 추가하여 확장하는 방법이 있지만 그 결과 만들어진 믹스인 객체를 책임지고 관리하는 일은 개발자의 몫입니다. 

고수준에서 보면 배열 메서드의 순차열은 체인을 끊어버리고 독립적인 함수열을 자유룝게 배열할 수 있으면 좋습니다. 그래서 바로 함수 파이프 라인이 필요합니다. 

### 함수를 파이프라인에 나열

함수형 프로그래밍에서는 메서드 체이닝의 한계에서 벗어나, 출신에 관계없이 어떤 함수라도 유연하게 결합할 수 있습니다. **파이프라인**이란 한 함수의 출력이 다음 함수의 입력이 되게끔 느슨하게 배열한, 방향성 함수 순차열입니다. 

함수 호출을 고수준의 간명한 함수 파이프라인으로 배열하는 기법을 연구해봅니다. 객체지향 디자인 패턴 중 '파이프 및 필터'와 동등한 패턴이라 그리 낯설지 않을 것입니다. 기업용 애플리케이션에서 자주 쓰는 이패턴도 실은 함수형 프로그래밍의 영향을 받았습니다(여기선 개별 함수가 필터에 해당합니다).

체이닝은 객체 메서드를 통해 함수들을 단단히 결합하지만, 파이프라인은 함수 입출력을 서로 연결 지어 느슨하게 결합된 컴포넌트,를 만들비낟. 단, 함수의 항수(인수 개수)와 형식이 호환되지 않으면 연결할 수 없습니다.

## 함수 호환 요건

객체지향 프로그램에서는 파이프라인을 특정한 경우(보통 인증/인가 처리)에 드문드문 사용하지만, 함수형 프로그래밍에서는 파이프라인이 프로그램을 구축하는 유일한 수단입니다. 일을 하다 보면 대부분 정의된 문제와 그 해결 방안 간에 차이점이 생기게 마련이므로 단계별로 명확하게 정의된 계산을 해야 합니다. 이 계산 단계가 코드에서는 함수로 표현되는데요, 각 함수는 두 가지 측면에서 입력과 출력이 서로 호환돼야 합니다. 

+ **형식**: 한 함수의 반환 형식과 수신 함수의 인수 형식이 일치해야 합니다.
+ **항수**: 수신 함수는 앞 단계 함수가 반환한 값을 처리하기 위해 적어도 하나 이상의 매개변수를 선언해야 합니다.

### 형식이 호환되는 함수

함수 파이프라인을 설계할 때에는 한 함수가 반환하는 것과 다른 함수가 받는 것이 반드시 호환되어야 합니다. 형식은 정적 형식 언어에서는 큰 관심사이지만 자바스크립트는 형식이 느슨한 언어라서 그렇지 않습니다. 따라서 어떤 객체가 실제로 특정 형식처럼 작동하면 그 형식은 그냥 그 객체의 형식인 것입니다. 이것을 다른 말로 **덕 타이핑**(오리처럼 걷고 오리처럼 말하는 동물이 있다면 그건 다름아닌 오리다)이라고 합니다. 

> 정적 형식 언어에서는 자료형 체계를 통해 코드를 실행하기 전에도 잠재된 문제점을 미리 알 수 있습니다. 

자바스크립트에는 동적 파견 체제 덕분에 형식과 무관하게 객체에서 속성과 메서드를 가져올 수 있습니다. 매우 유연한 구조이지만, 함수가 어떤 형식의 값을 기대하는지 알아야 할 때가 있어서 형식을(하스켈 표기법으로 코드에 주석을 붙여 문서화하는 식이나마) 명확하게 정의하면 프로그램을 이해하는 게 더 쉬워집니다. 

교과서식으로 말하면, 함수 f와 g가 있고 f의 출력 형식과 g의 입력 형식이 동등하면 두 함수의 형식은 호환됩니다. 예로 학생 SSN을 처리하는 간단한 프로그램을 봅시다. 

```jsx
trim :: String -> String // 앞뒤 공백을 제거
normalize :: String -> String // 입력 문자열의 대시(-)를 제거
```

여기서 normalize의 입력 형식과 trim의 출력 형식이 맞아야 파이프라인을 수동으로 간단하게 구성하여 실행할 수 있습니다. 

```jsx
// trim :: String -> String
const trim = (str) => str.replace(/^\s*|\s*$/g, '');

// normalize :: String -> String
const normalize = (str) => str.replace(/\-/g, '');

normalize(trim(' 444-44-4444 ')); // -> '444444444'
```

형식은 틀림없이 중요한 이슈지만, 자바스크립트에서는 함수가 취하는 인수 개수의 호환 여부가 더 중요합니다. 

### 함수와 항수: 튜플

**항수**란 함수가 받는 인수의 개수입니다. 함수의 **길이**라고도 합니다. 다른 프로그래밍에서는 항수를 당연하게 생각하지만, FP에서는 함수에 선언된 인수의 개수가 참조 투명성의 당연한 결과로서 복잡도와 정확히 비례하는 경우가 많습니다. 가령 문자열 인수를 하나만 받는 함수는 서너 개 받는 함수보다 훨씬 단순하다고 볼 수 있지요.

```jsx
// isValid :: String -> Boolean
function isValid(str) { // 사용하기 쉬움
    ...
}

// makeAsyncHttp :: String, String, Array => Boolean
function makeAsyncHttp (method, url, data) { // 모든 인수를 먼저 계산해야 하므로 사용하기 어려움
    ...
}
```

인수가 1개인 순수함수는 한 가지 용도, 즉 단일 책임을 담당하므로 가장 단순한 함수라고 볼 수 있습니다. 목표는 함수의 인수를 가능한 한 적게 하는 것입니다. 그래야 인수가 많은 함수보다 더 유연하게 다목적으로 활용할 수 있습니다. 하지만 단항 함수는 쉽게 얻어지지 않습니다. isValid 함수가 오류 내용까지 메시지 형태로 반환하도록 고치면 다음과 같을 겁니다. 

```jsx
isValid :: String -> (Boolean, String) // 검증 결과 및 에러가 날 경우 해당 메시지까지 담긴 자료구조를 반환

isValid(' 444-444-4444'); // -> (false, '입력값이 너무 길어요!')
```

그런데 이렇게 두 가지 다른 값을 동시에 반환할 수 있을까요? 함수형 언어는 **튜플**이라는 자료구조를 지원합니다. 튜플은 유한 원소를 지닌 정렬된 리스트로, 보통 한 번에 두 세개 값을 묶어 (a, b, c)와 같이 씁니다. isValid가 검사 결과와 에러 메시지를 함께 묶은 튜플 형태로 결과를 내면 한 개체로 반환할 수 있고 필요 시 그 다음 함수에 건네줄 수 있습니다. 튜플을 좀 더 자세히 알아 봅시다. 

튜플은 형식이 다른 원소를 한데 묶어 다른 함수에 건네주는 일이 가능한 불변성 자료구조입니다. 물론, 객체 리터럴이나 배열 같은 임의 형식으로 반환하는 방법도 있습니다.

```jsx
return {
    status: false,
    message: '입력값이 너무 길어요!'
};
// 또는 return [false, '입력값이 너무 길어요!'];
```

그래도 함수 간에 데이터를 변환할 때는 튜플이 다음 측면에서 더 유리합니다. 

+ **불변성**: 튜플은 한번 만들어지면 나중에 내용을 못 바꿉니다. 
+ **임의 형식의 생성 방지**: 튜플은 전혀 무관한 값을 서로 연관 지을 수 있습니다. 단지 데이터를 묶겠다고 새로운 형식을 정의하고 인스턴스화하는 건 괜스레 데이터 모형을 복잡하게 할 뿐입니다. 
+ **이형 배열의 생성 방지**: 형식이 다른 원소가 배열에 석여 있으면 형식을 검사하는 방어 코드를 수반하므로 다루기가 까다롭습니다. 배열은 태생 자체가 동일한 형식의 객체를 담는 자료구조입니다. 

튜플은 값 객체와 작동 방식이 유사합니다. 이를테면 상태 플래그와 오류 메시지를 (false, 'Some error ouccurred!') 식으로 담기 위해 단순 자료형 Status를 만들어 쓸 수 있습니다. 자바스크립트는 스칼라 등의 함수형 언어와 달리튜플 자료형을 처음부터 지원하지 않습니다. 스칼라에서는 다음과 같이 튜플을 정의할 수 있습니다.

```jsx
var t = (30, 60, 90);
```

그러면 각 원소에는 이렇게 접근할 수 있습니다.

```jsx
var sumAnglesTriangle = t._1 + t._2 + t._3 = 180;
```

자바스크립트 개발자는 직접 알아서 자신만의 튜플을 구현하여 쓰면 됩니다.

```jsx
const Tuple = function( /* 형식 */ ) {
	const typeInfo = Array.prototype.slice.call(arguments);
    const _T = function( /* 값 */ ) {
        const values = Array.prototype.slice.call(arguments);
        if(values.some(val => val === null || val === undefined)) {
            throw new ReferenceError('튜플은 null 값을 가질 수 없습니다!');
        }
        if(values.length !== typeInfo.length) {
            throw new TypeError('튜플 항수가 프로토타입과 맞지 않습니다!');
        }
        values.forEach((val, index) => {this['_' + (index + 1) = checkType(typeInfo[index])(val);}, this);
        Object.freeze(this);
    };
    _T.prototype.values = () => {
        return Object.keys(this).map(k => this[k], this);
    };
    return _T;
}
```

위 코드에서 튜플 객체는 크기가 고정된 불변성 자료구조로, 함수 간 통신에 사용 가능한 n개의 이형 값을 담을 수 있습니다. 예를 들어 간단히 Status 같은 값 객체를 만들어 쓰면 이렇게 돼죠.

```jsx
const Status = Tuple(Boolean, String);
```

그럼, 튜플을 써서 학생 SSN을 검증하는 예제를 완성합시다.

```jsx
// trim :: String -> String
const trim = (str) => str.replace(/^\s*|\s*$/g, '');

// normalize :: String -> String
const normalize = (str) => str.replace(/\-/g, '');

// isValid :: String -> Status
const isValid = function (str) {
    if(str.length === 0) {
        return new Status(false, '잘못된 입력입니다. 빈 값일 리 없지요!'); // 상태(불리언) 및 에러 메시지(문자열) 값을 보관할 Status 형식을 선언
    } else {
        return new Status(true, '성공!');
    }
}

isValid(normalize(strim('444-44-4444'))); // -> (true, '성공!')
```

소프트웨어에서 튜플은 단골 손님이라 일급 객체로 만들어두면 편리합니다. ES6부터 지원하는 **해체 할당**과 조합하면 튜플 값을 변수로 깔끔하게 매핑할 수 있습니다. 다음 코드는 튜플로 만든 StringPair 객체입니다. 

```jsx
const StringPair = Tuple(String, String);
const name = new StringPair('Barkley', 'Rosser');

[first, last] = name.values();
first; //-> 'Barkley'
last; //-> 'Rosser'

const fullname = new StringPair('J', 'Barkley', 'Rosser'); // 항수가 맞지 않아 에러가 납니다.
```

튜플로 함수 항수를 줄일 순 있지만, 튜플만으로 만족스럽지 못할 땐 더 나은 대체 방안이 있습니다.  다음 주제는 항수를 추상하는 동시에 모듈성, 재사용성을 높이는 함수 커링이라는 천연 조미료입니다.