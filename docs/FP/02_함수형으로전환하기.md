# 함수형으로 전환하기

## 자료구조는 적게, 일은 더 많이

이전에 두 가지 중요한 목표를 달성했습니다. 첫째, 함수형으로 사고하는 방법, 함수형 프로그래밍에 필요한 도구를 소개했습니다. 둘째, 고계함수를 비롯하여 많이 등장할 자바스크립트의 제반 특성을 압축해서 살펴보았습니다. 함수를 순수하게 만드는 법을 알았으니 이제 서로 연결하는 방법을 배울 차롑니다. 

자료구조를 순차적으로 탐색/변환하는데 쓰이는 실용적인 연산 몇 가지(map, reduce, filter)를 소개합니다. 이들은 사실상 모든 함수형 프로그램이 나름대로 응용해서 쓰기 때문에 매우 중요한 함수입니다. 대부분의 루프는 이들이 처리하는 하나의 특정 케이스에 지나지 않으므로 코드에서 수동 루프를 없앨 목적으로도 쓰입니다. 

또한 로대시JS의 사용법을 배웁니다. 애플리케이션의 구조는 물론 자료구조도 처리하고 이해할 수 있게 해주는 함수형 자바스크립트 라이브러리입니다. 또 함수형 프로그래밍에서 재귀가 차지하는 막대한 비중에 대해 알아보고 재귀적인 사고방식이 어떤 점에서 좋은지 설명합니다. 이런 개념들이 밑거름이 되어야 코드의 메인 로직에서 제어 흐름을 명확하게 분리하여 간결하고 확장성 좋은, 선언적 프로그램을 작성할 수 있습니다. 

### 애플리케이션의 제어 흐름

프로그램이 정답에 이르기까지 거치는 경로를 **제어 흐름**이라고 합니다. 명령형 프로그램은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다. 보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어차지요. 명령형 프로그램의 틀을 고수준에서 바라보면 다음 코드와 같습니다. 

```jsx
var loop = optC();
while(loop) {
    var condition = optA();
    if(condition) {
        optB1();
    }
    else {
        optB2();
    }
    loop = optc();
}
optD();
```

아래는 간단히 표현한 프로그램 흐름입니다.

> optA
>
> + 예: optB1
> + 아니오: optB2
> + 루프  optC -> optD

반면, 선언적 프로그램, 특히 함수형 프로그램은 독립적인 블랙박스 연산들이 단순하게, 즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높습ㄴ디ㅏ. 이렇게 연결한 연산들은 각자 다음 연산으로 상태를 이동시키는 고계함수에 불과합니다. 실제로 함수형 프로그램은 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다. 

> optA -> optB -> optC -> optD
>
> 프로그램실행 순서 -> 

함수형 프로그램은 서로 연결된 블랙박스 연산을 제어합니다. 정보는 한 연산에서 다른 연산으로 독립적으로(각 연산은 개별적인 순수함수이므로) 흘러가며, 분기와 반복은 상당 부분 줄이거나 아예 없애고 고수준의 추상화로 대체합니다.

덕분에 다음과 같이 코드가 짧아집니다.

```jsx
optA().optB().optC().optD();
// 점으로 연결하려면 이들 메서드가 모두 포함된 공유 객체가 있어야 합니다.
```

연산을 체이닝하면 간결하면서 물 흐르는 듯한, 표현적인 형태로 프로그램을 작성할 수 있어 제어 흐름과 계산 로직을 분리할 수 있고 코드와 데이터를 더욱 효과적으로 헤아릴 수 있습니다. 

### 메서드 체이닝

**메서드 체이닝**은 여러 메서드를 단일 구문으로 호출하는 OOP 패턴입니다. 메서드가 모두 동일한 객체에 속해 있으면 메서드 흘리기라고도 합니다. 대부분 객체지향 프로그램에서 불변 객체에 많이 적용하는 패턴이지만 함수형 프로그래밍에도 잘 맞습니다. 함수형에서 객체 변이는 금지되어 있습니다. 문자열을 다루는 예제를 하나 봅시다. 

```jsx
'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun';
```

substring과 toLowerCase 메서드는 각각 자신을 소유한 문자열 객체에 (this로 접근하여) 어떤 작업을 한 다음 새로운 문자열을 반환합니다. 자바스크립트 문자열에서 플러스(+) 연산자는 문자열을 합친 다음 새 문자열을 반환하도록 오버로드한 간편 구문입니다. 이러한 변환 과정을 거치면 원본 문자열은 전혀 건드리지 않고도 원본과는 무관한 문자열이 생성됩니다. 문자열은 처음부터 불변값으로 설계됐으니 당연한 결과지요. 객체지향 관점에서 보면 지극히 당연한 일이지만, 함수형 입장에서는 문자열 따위에 렌즈까지 들이댈 필요가 없으니 아주 다행스런 일입니다. 

함수형으로 리팩터링한 코드는 다음과 같습니다. 

```jsx
concat(toLowerCase(substring('Functional Programming', 1, 10)),' is fun');
```

매개변수는 모두 함수 선언부에 명시해서 부수효과를 없애고 원본 객체를 바꾸지 않아야 한다는 함수형 교리를 충실히 반영한 코드입니다. 그러나 이렇게 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝 방식만큼 매끄럽지 못합니다. 로직을 파악하려면 가장 안쪽에 감싼 함수부터 한 꺼풀씩 벗겨내야 하고 가독성도 현저히 떨어지지요. 

변이를 일으키지 않는 한 함수형 프로그래밍에서도 단일 객체 인스턴스에 속한 메서드를 체이닝하는 건 나름대로 쓸모가 있습니다. 이 패턴을 배열에도 적용할 수는 없을까요? 자바스크립트 배열에도 문자열 객체에 메서드를 체이닝하는 패턴을 확장시켜 적용할 수는 있지만, 안타깝게도 많은 사람이 익숙지 않은 탓에 바로 머릿속에 떠오르는 지저분한 루프를 다시 꺼내 쓰기 쉽습니다. 

### 함수 체이닝

객체지향 프로그램은 주로 상속을 통해 코드를 재사용합니다. 이전 예제에서 Student는 Person을 상속했고 부모형의 상태 및 메서드를 모두 물려받았습니다. 순수 객체지향 언어에서, 특히 언어 자체의 자료구조를 구현한 코드를 보면 이런 패턴이 자주 눈에 띕니다. 가령 자바에는 List 인터페이스를 용도에 맞게 달리 구현한 ArrayList, LinkedList, DoublyLinkedList, CopyOnWriteArrayList 등이 있습니다. 이들은 모두 한 부모에서 출발하여 나름대로 특수한 기능을 덧붙인 클래스입니다. 

함수형 프로그래밍은 접근 방법이 다릅니다. 자료구조를 새로 만들어 어떤 요건을 충족시키는 게 아니라, 배열 등의 흔한 자료구조를 이용해 다수의 굵게 나뉜 고계 연산을 적용합니다. 이러한 고계 연산으로 다음과 같은 일을 합니다. 

+ 작업을 수행하기 위해 무슨 일을 해야 하는지 기술된 함수를 인수로 받습니다. 
+ 임시 변수의 값을 계속 바꾸면서 부수효과를 일으키는 기존 수동 루프를 대체합니다. 그 결과 관리할 코드가 줄고 에러가 날 만한 코드 역시 줄어듭니다. 

좀 더 자세히 살펴볼까요? 예제 코드는 모두 다음 Person 객체의 컬렉션을 기준으로 합니다. 테스트 객체는 편의상 4개만 만들었지만, 수량은 앞으로 설명할 내용과 무관합니다. 

```jsx
const p1 = new Person('Haskell', 'Curry', '111-11-1111');
p1.address = new Address('US');
p1.birthYear = 1900;

const p2 = new Person('Barkley', 'Rosser', '222-22-2222');
p2.address = new Address('Greece');
p2.birthYear = 1907;

const p3 = new Person('John', 'von Neumann', '333-33-3333');
p3.address = new Address('Hungary');
p3.birthYear = 1903;

const p4 = new Person('Alonzo', 'Church', '444-44-4444');
p4.address = new Address('US');
p4.birthYear = 1903;
```

#### 람다 표현식

함수형 프로그래밍에서 탄생한 **람다 표현식**(자바스크립트에서는 **두 줄 화살표 함수**라고도 함)은 한 줄짜리 익명 함수를 일반 함수 선언보다 단축된 구문으로 나타냅니다. 람다 함수는 여러 줄로도 표기할 수 있지만 거의 대부분 한 줄로 씁니다. 람다 함수든, 일반 함수든 코드 가독성의 차이만 있을 뿐, 실제 하는 일은 같습니다. 사람 이름을 추출하는 간단한 예제를 봅시다. 

```jsx
const name = p => p.fullname;
console.log(name(p1)); // -> 'Haskell Curry'
```

(p) => p.fullname은 매개변수 p를 받아 p.fullname을 반환함을 의미하는 간편 구문입니다. 

람다 표현식은 항상 어떤 값을 반환하게 만들어 함수 정의부를 확실히 함수형으로 굳힙니다. 한 줄짜리 표현식의 반환값은 함수 본체를 실행한 결괏값입니다. 여기서 주목할 점은 일급 함수와 람다 표현식의 관계입니다. 위 예제에서 name은 실제하는 값이 아니라, 그 값을 얻기 위한 (느긋한) 방법을 가리킵니다. 즉 name으로 데이터를 계싼하는 로직이 담긴 두 줄 화살표 함수를 가리키는 것입니다. 함수형 프로그램은 이렇게 함수를 마치 값처럼 쓸 수 있습니다. 

함수형 프로그래밍은 람다 표현식과 잘 어울리는 세 주요 고계함수 map, reduce, filter를 적극 사용할 것을 권장합니다. 사실 함수형 자바스크립트는 대부분 자료 리스트를 처리하는 코드입니다. 자바스크립트의 전신이자 원조 함수형 언어인 LISP의 이름도 List Processor(리스트 처리기)에서 비롯된 것입니다. 함수형 배열 연산을 지원하는 array extras 함수는 ES5에도 있지만 이와 유사한 다른 유형의 연산까지 포괄하는 완전한 솔루션을 만들기 위해 **로대시JS**라는 함수형 라이브러리를 사용합니다. 로대시JS는 개발자가 함수형 프로그램을 작성하도록 유도하는 중요한 장치를 제공하고, 여러 가지 공통적인 프로그래밍 작업을 처리하는 데 유용한 도우미 함수들을 풍성하게 지원합니다. 라이브러리 설치 후 전역 객체 _(언더스코어 또는 로대시라고 읽음)을 통해 로대시JS 함수를 꺼내 쓰면 됩니다. 

> **로대시JS 속 언더스코어**
>
> 로대시JS는 언더스코어(http://underscorejs.org)라는 유명 프로젝트에서 파생된 라이브러리이므로 언더스코어JS의 관례를 따릅니다. 현재도 로대시JS는 언더스코어JS 대신 그냥 써도 될 정도로 언더스코어 API를 충실히 반영해왔습니다. 하지만 내부적으로는 함수 체인을 좀 더 우아하게 구축하는 방향으로 완전히 재작성되었고 성능 문제도 개선된 라이브러리입니다. 

#### _.map: 데이터를 변환

덩치 큰 데이터 컬렉션의 원소를 모두 변환해야 할 때가 있습니다. 예를 들어 학생 리스트에서 각자의 성명을 추출한다고 합시다. 이런 코드를 다음과 같이 구현했던 적이 부지기수였겠죠? 

```jsx
var result = [];
var persons = [p1, p2, p3, p4];

for(let i = 0; i < persons.length; i++) {
    var p = persons[i];
    if(p !== null && p !== undefined) {
        result.push(p.fullname); // 명령형 관점에서는 fullname이 Student의 메서드입니다.
    }
}
```

map(collect라고도 합니다)은 배열 각 원소에 이터레이터 함수를 적용하여 크기가 같은 새 배열을 반환하는 고계함수입니다. _.map을 써서 함수형 스타일로 바꿔볼까요? 

```jsx
_.map(persons, s => (s !-- null && s !-- undefined) ? s.fullname : ''); 
// 고계함수를 써서 변수 선언부를 모두 없앴습니다. 
```

map 연산을 수학적으로 쓰면 다음과 같습니다. 

```jsx
map(f, [e0, e1, e2...]) -> [r0, r1, r2...];
// 여기서 f(en) = rn
```

map 함수는 루플ㄹ 쓰거나 괴팍한 스코프 문제를 신경 쓸 필요 없이 컬렉션의 원소를 전부 파싱할 경우 아주 유용합니다. 항상 새로운 배열을 반환하므로 불변성도 간직되지요. map은 함수 f와 n개의 원소가 담긴 컬렉션을 받아 왼쪽 -> 오른쪽 방향으로 각 원소에 f를 적용한 계산 결과를, 역시 크기가 n인 새 배열에 담아 반환합니다. 

예제에서 _.map은 배열을 반복하며 각 학생의 이름을 얻습니다. 이터레이터 함수는 (일반적으로) 람다 표현식으로 나타냅니다. 연산이 끝나면, 원본 배열은 건드리지 않은 채 다음 원소가 포함된 새 배열이 반환됩니다. 

```jsx
['Haskell Curry', 'Barkley Rosser', 'John von Neumann', 'Alonzo Church']
```

추상화 내부를 알면 이해하는 데 도움이 될 테니 _.map을 구현한 코드를 봅시다. 

```jsx
function map(arr, fn) { // 배열과 함수를 인수로 받아 배열 원소마다 함수를 실행하고 원본과 크기가 같은 새 배열을 반환
	const len = arr.length,
          result = new Array(len); // 입력 받은 배열과 크기가 동일한 배열 result를 선언
    for (let idx = 0; idx < len; ++idx) {
        result[idx] = fn(arr[idx], idx, arr); // 함수 fn을 각 원소에 실행하고 그 결과를 배열에 도로 담음
    }
    return result;
}
```

위 코드를 보면 _.map도 안에서는 일반 루프를 씁니다. _.map이 반복을 대행하는 덕분에 개발자는 루프 변수를 하나씩 늘리면 경계 조건을 체크하는 등의 따분한 일은 이 함수에게 맡기고 이터레이터 함수에 구현한 비즈니스 로직만 신경 쓰면 됩니다. 이렇듯 함수형 라이브러리를 쓰면 기존 코드도 진짜 순수 함수형 언어처럼 변신시킬 수 있습니다. 

map 연산은 무조건 왼쪽 -> 오른쪽 방향으로 진행합니다. 오른쪽 -> 왼쪽 방향으로 진행하려면 배열 원소를 거꾸로 뒤집어야겠죠? 로대시JS는 일관성을 유지하기 위해 자바스크립트의 Array.reverse()에 해당하는 _.reverse() 메서드를 지원합니다. 이 함수는 원본 배열에 변이를 일으키므로 개발자는 부수효과가 언제 일어날지 알고 있어야 합니다. 

```jsx
_(persons).reverse().map(
	p => (p !== null && p !== undefined) ? p.fullname : ''
);
```

못 보던 구문이 눈에 띄네요. 로대시JS는 기존 코드에 영향을 주지 않으면서도 쉽게 통합할 수 있는 멋진 방법을 제공합니다. 원하는 객체를 일단 _(...)로 감싸면 로대시JS의 강력한 함수형 도구를 이용해 마음껏 변환할 수 있습니다. 

지금까지 데이터를 변환하는 함수를 적용해보았고, 다음은 새로운 자료구조에 기반을 둔 값으로 귀결시키는 reduce 함수를 살펴볼 차례입니다. 

#### _.reduce: 결과를 수집

데이터를 변환한 후에는 변환된 데이터로부터 의미 있는 결과를 도출하고 싶겠지요. 이 일은 reduce 함수가 도맡습니다. reduce는 원소 배열을 하나의 값으로 짜내는 고계함수로, 원소마다 함수를 실행한 결괏값의 누적치를 계산합니다. 

수학적으로 쓰면 이렇습니다. 

```jsx
reduce(f, [e0, e1, e2, e3], accum) -> (f(f(f(f(accum, e0), e1, e2, e3)))) -> R
```

아래는 reduce를 간단히 구현한 코드입니다. 

```jsx
function reduce(arr, fn, accumulator) {
    let idx = -1,
        len = arr.length;
    
    if (!accumulator && len > 0) { // 누산치를 지정하지 않으면 배열의 첫 번째 원소를 초깃값으로 삼습니다. 
        accumulator = arr[++idx];
    }
    
    while (++idx < len) {
        accumulator = fn(accumulator, arr[idx], idx, arr); // 배열을 반복하면서 원소마다 누산치, 현재 값, 인덱스 배열을 인수로 fn을 실행
    }
    return accumulator; // 단일 누산치를 반환
}
```

reduce는 다음 매개변수를 받습니다.

+ fn: 배열 각 원소마다 실행할 이터레이터 함수로, 매개변수는 누산치, 현재 값, 인덱스 배열입니다. 
+ accumulator: 계산할 초깃값으로 넘겨받는 인수이고, 함수 호출을 거치며 매 호출 시 계산된 결괏값을 저장하는 데 쓰입니다. 

Person 객체 컬렉션에서 국가별 인구 등 유용한 통계치를 산출하는 프로그램을 작성해봅시다. 먼저 국가별 인구를 계산하는 코드입니다. 

```jsx
_(persons).reduce((stat, person) => {
    const country = person.address.country; // 거주 국가를 얻음
    stat[country] = _.inUndefined(stat[country]) ? 1 : stat[country] + 1;
    // country는 1로 초기화한 후, 해당 국가에 거주하는 사람이 있을 때마다 하나씩 더함
    return stat; // 누산 객체를 반환
}, {}); // 빈 객체로 리듀스를 시작(누산치를 초기화)
```

코드를 실행하면 주어진 Person 배열을 토대로 국가별 인구를 산출하여 다음과 같이 단일 객체에 담습니다. 

```json
{
    'US' : 2,
    'Greece' : 1,
    'Hungary': 1
}
```

많이 쓰이는 맵-리듀스 조합을 이용하면 작업을 더 단순화할 수 있습니다. 원하는 기능을 map, reduce 두 함수에 매개변수로 담아 보내고 이들을 연결해서 기능을 확장하는 겁니다. 대략 다음과 같은 흐름입니다. 

```jsx
_(persons).map(func1).reduce(func2);
```

여기서 원하는 작업을 func1, func2 함수에 각각 구현합니다. 다음 코드처럼 주요 흐름에서 함수를 떼어내 별도로 만드는 거죠.

```jsx
const getCountry = person => person.address.country;

const gatherStats = function (stat, criteria) {
    stat[criteria] = _.isUndefined(stat[criteria]) ? 1 :
    	stat[criteria] + 1;
    return stat;
};

_(persons).map(getCountry).reduce(gatherStats, {});
```

map으로 객체 배열을 처리하여 국가 정보를 뽑아낸 다음, reduce로 최종 결과를 수집합니다. 위의 국가별 인구 계산 코드와 결과는 같지만 훨씬 깔끔하고 확장 가능한 모양새입니다. 속성을 직접 건드리는 대신 (람다JS로) Person 객체의 address.city 속성에 초점을 맞춘 렌즈를 써봅시다. 

```jsx
const cityPath = ['address', 'city'];
const cityLens = R.lens(R.path(cityPath), R.assocPath(cityPath));
```

거주 도시별 인구를 산출하는 작업도 마찬가지로 어렵지 않습니다. 

```jsx
_(persons).map(R.view(cityLens)).reduce(gatherStats, {});
```

_.groupBy를 쓰면 코드가 훨씬 더 간명해집니다. 

```jsx
_.groupBy(persons, R.view(cityLens));
```

map과 달리 reduce는 누산치에 의존하기 때문에 결합법칙이 성립하지 않는 연산은 진행 순서(왼쪽 -> 오른쪽 또는 오른쪽 -> 왼쪽)에 따라 결과가 달라집니다. 예를 들어 다음과 같이 숫자 배열 원소를 모두 더하는 코드는 _.reduceRight로 순서를 반대로 해도 결과는 같습니다. 

```jsx
_([0, 1, 3, 4, 5]).reduce(_.add); // -> 13
```

덧셈은 결합법칙이 성립하기 때문에 당연한 얘기지만, 나눗셈 같은 연산은 결과가 완전히 달라지죠. _.reduceRight를 수학적으로 쓰면 다음과 같습니다. 

```jsx
reduceRight(f, [e0, e1, e2], accum) -> f(e0, f(e1, f(e2, f(e3,accum)))) -> R
```

_.divide로 나눗셈을 하는 다음 두 연산은 결과가 판이합니다. 

```jsx
([1,3,4,5]).reduce(_.divide) !== ([1,3,4,5]).reduceRight(_.divide);
```

또 reduce는 일괄적용 연산이라서 배열을 순회하는 도중 그만두고 나머지 원소를 생략할 방법이 없습니다. 가령 어떤 입력값 리스트를 검증하는 경우, 검증 결과를 하나의 불리언 값으로 리듀스하면 입력값이 전부 올바른지 알아낼 수 있을 것입니다. 

하지만 reduce는 리스트 값을 빠짐없이 방문하기 때문에 다소 비효율적입니다. 잘못된 입력값이 하나라도 발견되면 나머지 값들은 더 이상 체크할 필요가 없으니까요. 앞으로 애용하게 될 _.some, _.isUndefined, _.isNull 같은 함수를 써서 좀 더 효율적인 검증기를 만들어보겠습니다. 각 원소에 _.some 함수를 실행하면 주어진 조건을 만족하는 값이 발견되는 즉시 true를 반환합니다. 

```jsx
const isNotValid = val => _.isUndefined(val) || ._isNull(val); // undefined, null은 올바른 값이 아님

const notAllValid = args => _(args).some(isNotValid); // 하나라도 true면 some 함수를 즉시 반환. 최소한 하나의 값이라도 올바른지 확인할 때 유용

notAllValid(['string', 0, null, undefined]); // -> true
notAllValid(['string', 0, {}]); // -> false 
```

notAllValid의 논리적 역함수 allValid는 주어진 술어가 모든 원소에 대해 true인지 _.every로 체크합니다. 

```jsx
const inValid = val => !_.isUndefined(val) && !_.isNull(val);
const allValid = args => _(args).every(isValid);

allValid(['string', 0, null]); // -> false
allValid(['string', 0, {}]); // -> true
```

map과 reduce는 배열 원소를 모두 탐색한다고 했습니다. 자료구조의 원소를 다 처리하지 않고 null이나 undefined인 객체는 건너뛰어야 할 경우도 있겠죠. 계산을 시작하기 전에 특정 원소는 미리 솎아낼 수단이 있으면 좋겠습니다. 바로 이런 일을 하는 게 _.filter입니다. 

#### _.filter: 원하지 않는 원소를 제거

큰 데이터 컬렉션을 처리할 경우, 계산하지 않을 원소는 사전에 빼는 게 좋습니다. 예컨대, 특정 년도 출생자나 유럽 거주자 인구만을 산출할 때, if-else 문을 남발하는 대신 _.filter를 쓰면 한결 코드가 깔끔해집니다. 

filter(select라고도 합니다)는 배열 원소를 반복하면서 술어 함수 p가 true를 반환하는 원소만 추려내고 그 결과를 새 배열에 담아 반환하는 고계함수입니다. 수학적으로 쓰면 다음과 같습니다. 

```jsx
filter(p, [d0, d1, d2, d3...dn]) -> [d0, d1, ...dn] (원래 집합의 부분 집합)
```

> 필터는 주어진 배열 원소에 선별 기준을 나타내는 함수형 술어 p를 적용 후, 원래 배열의 부분집합을 돌려줍니다. 

아래의 코드는 filter 함수 구현부입니다. 

```jsx
function filter(arr, apredicate) {
    let idx = -1,
        len = arr.length,
        result = []; // 결과 배열은 입력받은 배열의 부분집합
    
    while (++idx < len) {
        let value = arr[idx];
        if (predicate(value, idx, this)) { // 술어 함수 실행 결과가 true면 원소를 유지하고 false면 버림
            result.push(value);
        }
    }
    return result;
}
```

filter는 대상 배열과, 원소를 결과에 포함할지 결정하는 술어 함수 두 가지를 인수로 받습니다. 술어 함수 결과가 true인 원소는 남기고 그렇지 않은 원소는 내보냅니다. filter는 배열에서 오류 데이터를 제거하는 용도로 자주 쓰입니다. 

```jsx
_(person).filter(isValid).map(fullname);
```

filter의 용도는 이뿐만이 아닙니다. Person 객체 컬렉션에서 1903년 출생자들만 추리고자 할 때, 조건문 대신 _.filter를 쓰면 코드가 훨씬 간결해집니다. 

```jsx
const bornIn1903 = person => person.birthYear === 1903;
_(persons).filter(bornIn1903).map(fullname).join(' and ');

// -> 'John von Neumann and Alonzo Church'
```

> **배열 축약**
>
> map, filter는 어떤 배열을 받아 새 배열을 내는 고계함수로, 하스켈, 클로저 등 대부분의 함수형 프로그래밍 언어에 기본 내장되어 있습니다. 이들을 조합하는 대신 **배열 축약**(또는 **리스트 축약**)이란 개념을 적용하는 방법도 있습니다. 배열 축약은 map, filter의 기능을 각각 for..of와 if 키워드를 이용하여 단축된 구문으로 캡슐화하는 함수형 장치입니다. 다음과 같은 형식입니다. 
>
> ```jsx
> [for (x of 이터러블) if 조건 x]
> ```
>
> 현재 배열 축약은 ECMAScript7 제안서에 포함되어 있습니다. 배열 축약을 활용하면 간결한 구문으로 새 배열을 조립할 수 있습니다.(그래서 전체 표현식을 []로 감쌉니다.) 예를 들어 방금 전 코드는 다음과 같이 바꿔 써도 됩니다.
>
> ```jsx
> [for (p of people) if (p.birthYear === 1903) p.fullname].join(' and ');
> ```

지금까지 살펴본 것처럼 확장성 좋고 강력한 함수를 이용해서 코딩하면 코드가 깔끔해질 뿐만 아니라 데이터를 더 잘 이해할 수 있습니다. 선언적 스타일은 개발자가 문제의 해법에 어떻게 도달해야 하는지 고민하기보다 애플리케이션이 어떤 결과를 내야 하는지에 전념하게 합니다. 따라서 애플리케이션을 더 깊이 있게 헤아리는 데 큰 도움이 됩니다. 

