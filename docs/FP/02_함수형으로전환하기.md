# 함수형으로 전환하기

## 자료구조는 적게, 일은 더 많이

이전에 두 가지 중요한 목표를 달성했습니다. 첫째, 함수형으로 사고하는 방법, 함수형 프로그래밍에 필요한 도구를 소개했습니다. 둘째, 고계함수를 비롯하여 많이 등장할 자바스크립트의 제반 특성을 압축해서 살펴보았습니다. 함수를 순수하게 만드는 법을 알았으니 이제 서로 연결하는 방법을 배울 차롑니다. 

자료구조를 순차적으로 탐색/변환하는데 쓰이는 실용적인 연산 몇 가지(map, reduce, filter)를 소개합니다. 이들은 사실상 모든 함수형 프로그램이 나름대로 응용해서 쓰기 때문에 매우 중요한 함수입니다. 대부분의 루프는 이들이 처리하는 하나의 특정 케이스에 지나지 않으므로 코드에서 수동 루프를 없앨 목적으로도 쓰입니다. 

또한 로대시JS의 사용법을 배웁니다. 애플리케이션의 구조는 물론 자료구조도 처리하고 이해할 수 있게 해주는 함수형 자바스크립트 라이브러리입니다. 또 함수형 프로그래밍에서 재귀가 차지하는 막대한 비중에 대해 알아보고 재귀적인 사고방식이 어떤 점에서 좋은지 설명합니다. 이런 개념들이 밑거름이 되어야 코드의 메인 로직에서 제어 흐름을 명확하게 분리하여 간결하고 확장성 좋은, 선언적 프로그램을 작성할 수 있습니다. 

### 애플리케이션의 제어 흐름

프로그램이 정답에 이르기까지 거치는 경로를 **제어 흐름**이라고 합니다. 명령형 프로그램은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다. 보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어차지요. 명령형 프로그램의 틀을 고수준에서 바라보면 다음 코드와 같습니다. 

```jsx
var loop = optC();
while(loop) {
    var condition = optA();
    if(condition) {
        optB1();
    }
    else {
        optB2();
    }
    loop = optc();
}
optD();
```

아래는 간단히 표현한 프로그램 흐름입니다.

> optA
>
> + 예: optB1
> + 아니오: optB2
> + 루프  optC -> optD

반면, 선언적 프로그램, 특히 함수형 프로그램은 독립적인 블랙박스 연산들이 단순하게, 즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높습ㄴ디ㅏ. 이렇게 연결한 연산들은 각자 다음 연산으로 상태를 이동시키는 고계함수에 불과합니다. 실제로 함수형 프로그램은 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다. 

> optA -> optB -> optC -> optD
>
> 프로그램실행 순서 -> 

함수형 프로그램은 서로 연결된 블랙박스 연산을 제어합니다. 정보는 한 연산에서 다른 연산으로 독립적으로(각 연산은 개별적인 순수함수이므로) 흘러가며, 분기와 반복은 상당 부분 줄이거나 아예 없애고 고수준의 추상화로 대체합니다.

덕분에 다음과 같이 코드가 짧아집니다.

```jsx
optA().optB().optC().optD();
// 점으로 연결하려면 이들 메서드가 모두 포함된 공유 객체가 있어야 합니다.
```

연산을 체이닝하면 간결하면서 물 흐르는 듯한, 표현적인 형태로 프로그램을 작성할 수 있어 제어 흐름과 계산 로직을 분리할 수 있고 코드와 데이터를 더욱 효과적으로 헤아릴 수 있습니다. 

### 메서드 체이닝

**메서드 체이닝**은 여러 메서드를 단일 구문으로 호출하는 OOP 패턴입니다. 메서드가 모두 동일한 객체에 속해 있으면 메서드 흘리기라고도 합니다. 대부분 객체지향 프로그램에서 불변 객체에 많이 적용하는 패턴이지만 함수형 프로그래밍에도 잘 맞습니다. 함수형에서 객체 변이는 금지되어 있습니다. 문자열을 다루는 예제를 하나 봅시다. 

```jsx
'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun';
```

substring과 toLowerCase 메서드는 각각 자신을 소유한 문자열 객체에 (this로 접근하여) 어떤 작업을 한 다음 새로운 문자열을 반환합니다. 자바스크립트 문자열에서 플러스(+) 연산자는 문자열을 합친 다음 새 문자열을 반환하도록 오버로드한 간편 구문입니다. 이러한 변환 과정을 거치면 원본 문자열은 전혀 건드리지 않고도 원본과는 무관한 문자열이 생성됩니다. 문자열은 처음부터 불변값으로 설계됐으니 당연한 결과지요. 객체지향 관점에서 보면 지극히 당연한 일이지만, 함수형 입장에서는 문자열 따위에 렌즈까지 들이댈 필요가 없으니 아주 다행스런 일입니다. 

함수형으로 리팩터링한 코드는 다음과 같습니다. 

```jsx
concat(toLowerCase(substring('Functional Programming', 1, 10)),' is fun');
```

매개변수는 모두 함수 선언부에 명시해서 부수효과를 없애고 원본 객체를 바꾸지 않아야 한다는 함수형 교리를 충실히 반영한 코드입니다. 그러나 이렇게 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝 방식만큼 매끄럽지 못합니다. 로직을 파악하려면 가장 안쪽에 감싼 함수부터 한 꺼풀씩 벗겨내야 하고 가독성도 현저히 떨어지지요. 

변이를 일으키지 않는 한 함수형 프로그래밍에서도 단일 객체 인스턴스에 속한 메서드를 체이닝하는 건 나름대로 쓸모가 있습니다. 이 패턴을 배열에도 적용할 수는 없을까요? 자바스크립트 배열에도 문자열 객체에 메서드를 체이닝하는 패턴을 확장시켜 적용할 수는 있지만, 안타깝게도 많은 사람이 익숙지 않은 탓에 바로 머릿속에 떠오르는 지저분한 루프를 다시 꺼내 쓰기 쉽습니다. 