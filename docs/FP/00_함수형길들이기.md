# 함수형 길들이기

개발자의 본능은 확장성 좋고 깔끔한 애플리케이션 아키텍처를 구축하는 데 유용한 프레임워크에 끌리지만, 현행 코드베이스는 이미 너무 복잡해진 상태라서 기본 설계 원리부터 다시 검토해야 하는 어려움이 있습니다. 사실 자바스크립트 개발자 입장에서 오늘 날 웹은 수년 전 웹과는 근본적으로 다릅니다. 과거에 기술적으로 거의 불가능했던 일들이 지금은 얼마든지 구현 가능하지요. Node.js로 대규모 서버 측 애플리케이션을 개발할 수도 있고, 기반 서버는 가볍게 하되 비즈니스 로직은 대부분 클라이언트 측에 심을 수도 있습니다. 요즘 개발자는 저장소와 통신하면서 비동기 프로세스를 생성하고 이벤트를 처리하는 등 다양한 기술을 섭렵해야 합니다. 

어떤 문제는 객체지향 설계 방식으로도 해결할 수 있지만, 자바스크립트는 상태 공유가 보편적인, 참으로 동적인 언어라서 조금만 시간이 지나도 복잡해지면서 가독성이 떨어지고 관리하기 어려운 코드가 되기 일쑤입니다. 객체지향 설계 방향이 잘못된 건 아니지만 현실의 문제를 해결하기엔 역부족이죠. 최근 유행하기 시작한 **리액티브 프로그래밍**은 데이터 흐름(data flow)과 변경 전파(propagation of change)에 초점을 둡니다. 자바스크립트로 비동기 또는 이벤트 중심(event-driven) 코드를 다룰 때에도 이런 부분이 아주 중요합니다. 전반적으로 보면, 이제 자바스크립트에서도 데이터 및 데이터를 다루는 함수에 대해 진지하게 고민하는 프로그래밍 패러다임이 필요한 시기가 도래했습니다. 여러분이 반드시 자문해봐야 할 애플리케이션의 설계 요소를 정리해보겠습니다. 

+ **확장성**: 추가 기능을 지원하기 위해 계속 코드를 리팩터링해야 하는가?
+ **모듈화 용이성**: 파일 하나를 고치면 다른 파일도 영향을 받는가? 
+ **재사용성**: 중복이 많은가?
+ **테스트성**: 함수를 단위 테스트하기 어려운가?
+ **헤아리기 쉬움**: 체계도 없고 따라가기 어려운 코드인가?

이 중 한가지라도 해당된다면 함수형 프로그래밍(FP)으로 생산성을 높여줄 수 있습니다. 단순한 개념에 근거한 FP는 문제를 다른 사고방식으로 바라봅니다. FP는 새로운 도구나 API가 아닙니다. 하지만 FP의 기본 원리를 깨치고 나면 전혀 다른 문제 해결 방법이 아주 친근하고 당연하게 여겨질 것입니다. 

## 함수형 프로그래밍은 과연 유용한가?

함수형 프로그래밍이 요즘처럼 각광받은 적은 없었습니다. 개발 커뮤니티와 주요 소프트웨어 회사들도 FP 기법을 이용하여 강력한 비즈니스 애플리케이션을 구축하는 것이 이롭다는 사실을 깨닫기 시작했지요. 요즘 많이 쓰는 프로그래밍 언어 대부분(스칼라, 자바 8, F#, 파이썬 등)이 네이티브 또는 API 형태로 FP를 지원합니다. 이제 FP 스킬은 수요가 제법 높은 편인데요, 앞으로 수년 간 이런 추세는 지속될 전망입니다. 

자바스크립트 맥락에서 보면, FP 사고방식은 자바스크립트만의 매우 표현적인 특성을 가다듬어, 깔끔하면서도 모듈적인, 테스트하기 좋고 간결한 코드를 작성하는 데 도움이 됩니다. 결과적으로 업무 능률 또한 높아지지요. 사실 자바스크립트는 함수형 스타일로 작성해야 더 효과적이라는 측면이 오랫동안 간과됐습니다. 자바스크립트라는 언어를 많이들 오해한 부분도 있지만, 언어 내부에 상태를 적절히 관리할 장치가 마땅찮았던 이유도 있습니다. 자바스크립트는 상태 관리를 개발자에게 떠넘기는 동적인 플랫폼이니까요.(결국, 각종 애플리케이션 버그를 양산하는 근원이 되었습니다.) 짧은 스크립트는 별 문제 없지만 코드베이스가 커지면 점점 다루기가 버거워집니다. 

자바스크립트 코드를 함수형으로 작성하면 대부분의 문제가 해결됩니다. 순수함수에 기반을 두고 이미 검증된 기법과 관례에 따라 구현하면 코드가 점점 복잡해지더라도 헤아리기 쉬운 방향으로 작성할 수 있습니다. 그야말로 일석이조지요. 전체 애플리케이션 품질을 향상시키는 동시에 자바스크립트 언어를 더 잘 이해하게 되니 스킬도 향상됩니다. 

함수형 프로그래밍은 프레임워크나 도구가 아닙니다. 함수형으로 생각하고 코딩하는 건 지금까지 객체지향 관점에서 해왔던 것과는 근본적으로 다릅니다. 그럼 어떻게 함수형으로 전환할 수 있을까요? 함수형으로 사고하려면 어디서부터 시작해야 할까요? 일단 본질은 간파하고 나면 함수형 프로그래밍은 아주 직관적입니다. 오랜 잘못된 습관이 가장 고치기 어려운 것이기에 객체지향으로 무장한 대다수 사람들에겐 언제나 패러다임의 변화처럼 느껴질 수 있습니다. 함수형 사고 체게를 배우기 전에 과연 FP가 무엇인지 알아봅시다. 

## 함수형 프로그래밍이란?

함수형 프로그래밍이란, 한마디로 함수 사용을 강조하는 소프트웨어 개발 스타일입니다. FP에서는 눈앞에 맞닥뜨린 문제를 조금 다른 사고방식으로 접근해야 합니다. 단지 어떤 결과를 만드는 함수를 적용하는 그런 단순한 차원의 문제가 아닙니다. 진짜 목표는 애플리케이션의 **부수효과를 방지**하고 **상태 변이를 감소**하기 위해 **데이터의 제어 흐름과 연산을 추상**하는 것입니다.

```jsx
document.querySelector('#msg').innerHTML = '<h1>Hello World</h1>';
```

> 함수형 프로그래밍은 특정 도구가 아닌, 하나의 코드 작성 방법이므로 서버(노드JS) 측은 물론, 클라이언트(브라우저 기반) 측에도 적용 가능하다고 했습니다. 

위의 예제는 모든 걸 하드코딩한 단순한 프로그램에라서 메시지를 동적으로 표시할 수 없습니다. 내용이나 형식을 바꾼다든가, 타깃 요소(element)를 달리한다든지 할 땐 표현시을 전부 재작성해야 하죠. 함수를 만들어 달라지는 부분만 매개변수로 주면 같은 코드를 다시 사용할 수 있습니다. 

```js
function printMessage(elementId, format, message) {
    document.querySelector('#${elementId').innerHTML = '<${format}>${message}</${format}>';
}
```

분명히 나아지긴 했으나 아직 완벽히 재사용이 가능한 코드는 아닙니다. 메시지를 HTML 페이지 대신 파일에 쓴다면 어떨까요? 매개변수가 단순한 스칼라(scalar) 값이 아닌, 특정 기능을 함수에 추가하여 매개변수로 전달하는, 다시 말해 함수를 매개변수화(parameterize)하는 전혀 다른 차언의 과정을 떠올려야 합니다. 함수형 프로그래밍은 함수를 아주 왕성하게 활용합니다. 여러 함수를 서로 합성하고 평가해서 더 많은 기능을 탑재하는 것이 유일한 목표니까요. 그럼 좀 전의 코드가 함수형으로 접근하면 어떻게 바뀌는지 보겠습니다.

```jsx
var printMessage = run(addToDom('msg'), h1, echo);

printMessage('Hello World');
```

언뜻 봐도 원래 코드와는 완전 다르네요. 일단 h1은 스칼라 값이 아닌, addToDom, echo와 같은 함수입니다. 작은 함수들을 재료로 새로운 함수를 만들어내는 것처럼 보이네요. 

여기에는 그럴 만한 이유가 있습니다. 위의 코드는 재사용성과 믿음성(reliability)이 좋고 이해하기 쉬운, 더 작은 조각들로 프로그램을 나눈 후, 전체적으로 더 헤아리기 쉬운 형태의 프로그램으로 다시 조합하는 과정을 나타냅니다. 모든 함수형 프로그램이 이 기본 원리를 따릅니다. 지금은 여러분 눈에는 run 함수가 addToDom, h1, echo 함수를 차례대로 실행하는 모습이 무슨 마법을 부린 것처럼 보일지도 모릅니다. run 함수는 세 함수를 마치 자전거 체인처럼 연결해서 한 함수의 반환값이 다른 함수의 입력값으로 전달되게끔 합니다. 그래서 echo가 "Hello World" 문자열을 반환하면 h1으로 전달되고, 마지막으로 이 함수의 결괏값이 addToDom에 넘어갑니다. 

함수형 코드는 왜 이런 모습일까요? 기본적으로, 마치 알고리즘의 초기 조건을 조정하듯, 본연의 기능은 그대로 간직한 채 코드를 쉽게 변경하기 위해 코드 자체를 매개변수화하는 것입니다. 이렇게 하면 내부 로직은 하나도 안 고치고도 예를 들어 printMessage가 메시지를 2회 표시하게, 헤더는 h2 요소로, DOM 대신 콘솔에 출력하게 변경하는 일도 수월해집니다. 

```jsx
var printMessage = run(console.log, repeat(2), h2, echo);

printMessage('Get Functional';)
```

이처럼 시각적으로 명료한 접근 방법은 우연한 부산물이 아닙니다. 함수형/비함수형 해법을 견주어보면 근본적으로 스타일이 다르다는 걸 알 수 있습니다. 결과는 같지만 코드는 완전 딴판이지요. FP 특유의 선언적 개발 방식 때문에 그렇습니다. 함수형 프로그래밍을 온전히 이해하려면, 먼저 그 이면에 깔려 있는 다음 기본 개념을 숙지해야 합니다. 

+ 선언적 프로그래밍
+ 순수함수
+ 참조 투명성
+ 불변성

### 함수형 프로그래밍은 선언적

함수형 프로그래밍은 큰 틀에서 **선언적** 프로그래밍 패러다임에 속합니다. 내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산/작업을 표현하는 사상이지요. 아직은 자바, C#, C++ 등의 구조적/객체지향 언어가 지원하는 **명령혀** 또는 **절차적** 모델이 더 많이 쓰입니다. 명령형 프로그램은 어떤 결과를 내기 위해 시스템의 상태를 변경하는 구문을 위에서 아래로 죽 늘어놓은 순차적(수열)에 불과합니다. 

숫자 배열의 원소들은 모두 제곱수로 바꾸는 간단한 예제를 봅시다. 명령형으로 짠 코드는 이런 모습이겠죠. 

```jsx
var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for(let i = 0; i < array.length; i++) {
    array[i] = Math.pow(array[i], 2);
}
arary; // -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

명령형 프로그래밍은 컴퓨터에게 원하는 작업(루프를 반복하면서 각 숫자의 제곱수를 계산)을 **어떻게** 하는지 상세히 이릅니다. 사실 이게 가장 흔한 코딩 방법입니다. 

이와 달리 선언적 프로그래밍은 프로그램의 서술부와 평가부를 분리하여, 제어 흐름이나 상태 변화를 특정하지 않고도 프로그램의 로직이 무엇인지를 **표현식**으로 나타냅니다. SQL 구문도 선언적 프로그래밍의 한 예입니다. SQL 쿼리를 보면, 데이터를 실제로 가져오는 내부메커니즘은 추상한 상태에서 그 결과가 어떻게 나와야 하는지를 구문으로 서술합니다. 

같은 작업이라도 함수형으로 접근하면, 개발자가 각 요소를 올바르게 작동시키는 일에만 전념하고 루프 제어는 시스템의 다른 파트에 일임할 수 있습니다. 다음과 가팅 힘든 일은 Array.map()에게 모두 맡기면 그만이지요. 

```jsx
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(
	function(num) {
        return Math.pow(num, 2);
    }
);

// -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

이전 코드와 비교하면 루프 카운터를 관리하고 배열 인덱스에 정확하게 접근하는 일 따위는 개발자가 신경 쓸 필요가 없어 부담이 줄어듭니다. 사실 코드가 길어지면 버그가 날 가능성도 높아지고, 일반 루프는 함수로 추상하지 않는 한 재사용 자체가 안 됩니다. 지금부터 우리가 할 일이 바로 함수로 추상하는 작업입니다. 

루프를 함수로 추상하면 ES6부터 새로 선보인 **람다 표현식**이나 **화살표 함수**를 쓸 수 있습니다. 람다 표현식은 함수 인수로 전달 가능한 익명 함수를 대체할 수 있는 깔끔한 수단입니다. 코드도 덜 쓰면서 말이죠. 

```jsx
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2));
// -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

> **람다 표기를 일반 함수 표기로 전환**
>
> 람다 표현식은 함수 호출의 구조를 가장 중요한 부분만 남기고 축약하므로 일반 함수 표기보다 구문상 이점이 많습니다. 예를 들어 다음 ES6 람다 표현식을 보죠. 
>
> ```jsx
> num => Math.pow(num, 2)
> ```
>
> 이 함수는 아래 함수와 같습니다. 
>
> ```jsx
> function(num) {
>     return Math.pow(num, 2);
> }
> ```

왜 루프를 제거해야 할까요? 루프는 재사용하기도 어렵거니와 다른 연산에 끼워 넣기도 어려운 명령형 제어 구조물입니다. 또 루프는 성격상 반복할 때마다 값이나 상태가 계속 바뀝니다. 그러나 함수형 프로그램은 **무상태성**과 **불변성**을 지향합니다. 무상태 코드는 전역 상태를 바꾸거나 혼선을 일으킬 가능성이 단 1%도 없습니다. 상태를 두지 않으려면 부수효과와 상태 변이를 일으키지 않는 **순수함수**를 써야 합니다. 

### 순수함수와 부수효과

함수형 프로그래밍은 순수함수로 구성된 불변 프로그램 구축을 전제로 합니다. 순수함수의 특성을 정리하면 다음과 같습니다. 

+ 주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 작동합니다. 
+ 전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않습니다. 

당연히 위 요건이 성립되지 않은 함수는 모두 '불순'하다고 볼 수 있습니다. 불변성을 바탕으로 프로그래밍하는 것이 처음엔 다소 낯설게 드껴질지 모르지만, 어쨌든 우리가 익숙한 명령형 프로그래밍에서는 변수가 한 구문에서 다른 구문으로 옮겨지면서 그 값이 변하는 것이 기본입니다(변수란 말 자체가 '변하는 것'을 뜻하니까요). 지극히 상식적인 얘기지요. 다음 함수를 봅시다. 

```jsx
var counter = 0;
function increment() {
    return ++counter;
}
```

이 함수는 자신의 스코프에 없는 외부 변수 counter를 읽고 수정하므로 불순합니다. 일반적으로 외부 자원을 상대로 데이터를 읽고 쓰는 함수는 부수효과를 동반합니다. Date.now()처럼 많이 쓰이는 날짜/시간 함수도 미리 헤아릴 수 있는 일정한 결괏값을 내지 않기 때문에 순수함수가 아닙니다. 

여기서 counter는 암시적 전역 변수(브라우저 기반 자바스크립트에서는 window 객체)를 통해 접근합니다. this 키워드를 거쳐 인스턴스 데이터에 접근하는 것 역시 부수효과가 유발되는 흔한 예입니다. 특히 자바스크립트의 this는 해당 함수의 런타임 콘텍스트에 따라 달라지므로 여타 프로그래밍 언어와는 작동 방식이 다릅니다. 그래서 코드가 더더욱 헷갈릴 수 있습니다. 부수효과가 발생하는 상황은 다양합니다. 

+ 전역 범위에서 변수, 속성, 자료구조를 변경
+ 함수의 원래 인수 값을 변경
+ 사용자 입력을 처리
+ 예외를 일으킨 해당 함수가 붙잡지 않고(catch) 그대로 예외를 던짐(throw)
+ 화면 또는 로그 파일에 룰력
+ HTML 문서, 브라우저 쿠키, DB에 질의

객체를 생성/변경하지 못하고 콘솔에 출력조차 할 수 없다면 그런 프로그램이 대체 무슨 소용일까요? 역동적으로 움직이며 온갖 변경이 난무하는 프로그램에서 순수함수를 사용하기란 현실적으로 어려울 수 있지만, 실제로 함수형 프로그래밍은 모든 상태 변이를 근절하자는 건 아니고, 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 겁니다. 불순한 코드는 방금 전에도 예시했듯이 밖에서 가시적인 부수효과를 일으키죠. 

예를 들어, 모 대학교 전산실에 근무하는 개발자로, 학생 데이터를 관리하는 애플리케이션을 개발하는 프로젝트에 참여 중이라고 가정합시다. 아래는 사회보장번호(SSN)로 학생 레코드를 검색하여 브라우저에 표시하는 명령형 프로그램입니다(꼭 브라우저일 이유는 없습니다. 콘솔, DB 파일 등 쓰는 대상은 여러 매체일 수 있습니다). 앞으로 아래의 코드는 (객레 배열 같은) 외부 객체 저장소와 연동하여 어떤 IO 작업을 수행하며 부수효과를 일으키는 전형적인 시나리오로 자주 언급될 것입니다. 

```jsx
function showStudent(ssn) {
    let student = db.find(ssn);
    if(student !== null) {
        document.querySelector(`$#{elementId}`).innerHTML = `${student.ssn}, ${student.firstname}, ${student.lastname}`;
    }
    else {
        throw new Error('학생을 찾을 수 없습니다.'); // 올바른 학생이 아닐 경우 예외
    }
}

showStudent('444-44-4444'); // SSN 444-44-4444으로 프로그램을 실행하고 해당 학생 정보를 페이지에 붙입니다. 
```

자세히 코드를 뜯어봅시다. 이 함수는 확실히 자신의 스코프를 벗어나 몇 가지 부수효과의 파장을 일으킵니다. 

+ 변수 db를 통해 데이터에 접근하는데, 함수 서명에는 이런 매개변수가 없으니 이는 외부 변수입니다. 문제는 이 변수가 실행 중 언제라도 null을 참조하거나 호출 단계마다 상이한 값을 가리키면 결괏값이 완전히 달라지고 프로그램의 무결성이 깨질 수 있다는 점입니다. 
+ elementId는 그 값이 언제라도 바뀔 수 있는 전역 변수라 이 함수가 어쩔 도리가 없습니다. 
+ HTML 요소를 직접 고칩니다. HTML 문서(DOM)는 그 자체로 가변적인, 전역 공유 자원입니다. 
+ 학생 레코드를 찾지 못해 예외를 던지면 전체 프로그램의 스택이 툭 풀리면서 종료될 것입니다. 

위의 함수는 외부 자원에 의존하므로 코드가 유연하지 않고 다루기가 힘들뿐더러 테스트 역시 어렵습니다. 반면, 순수함수는 서명에 정규 매개변수(입력 집합)를 빠짐없이 명시하므로 코드를 이해하고 사용하기가 쉽습니다. 

그럼, 함수형 마음가짐으로 방금 전 printMessage 프로그램에서 배웠던 내용을 실제 시나리오에도 하나씩 적용해봅시다. 일단 여기선 두 가지를 개선합니다. 

+ 긴 함수를 하나의 목적을 가진 짧은 함수로 각각 분리한다. 
+ 함수가 해야 할 작업에 필요한 인수를 모두 명시하여 부수효과 개수를 줄인다. 

먼저, 학생 레코드를 조회하는 일과 이를 화면에 그리는 일을 분리합시다. 외부 저장소 및 DOM과 연동하면서 비롯되는 부수효과는 당연히 불가피하지만, 조금이라도 더 다루기 쉽고 주요 로직에 충실한 코드로 떼어낼 수는 있겠지요. 여기서 **커링**이라는 유명한 FP 기법을 사용합니다. 커링은 함수의 여러 인수를 부분적으로 나누어 세팅하는 것입니다. 아래의 코드는 find와 append 두 함수를 커링을 통해 쉽게 조합해서 실행 가능한 단항 함수로 나눕니다. 

```jsx
// find 함수는 객체가 저장된 곳을 가리키는 레퍼런스와 검색할 학생 ID를 받습니다. 
var find = curry((db, id)) => { 
    let obj = db.find(id);
    if(obj === null) {
        throw new Error('객체를 찾을 수 없습니다!');
    }
    return obj;
});

// student 객체를 콤마로 분리된 문자열로 바꿉니다. 
var csv = student => '${student.ssn}, ${student.firstname}, ${student.lastname}';


// 학생 상세 정보를 페이지 표시하려면 요소 ID, 학생 데이터가 필요합니다. 
var append = curry((selector, info) => {
    document.querySelector(selector).innerHTML = info;
});
```

한 가지만 개선했는데도 벌써 여러 가지 장점이 눈에 띄네요. 

+ 재사용 가능한 컴포넌트 3개로 나뉘어 코드가 훨씬 유연해졌습니다. 
+ 이렇게 잘게 나뉜 함수를 재사용하면 신경 써서 관리할 코드의 크기가 확 줄기 때문에 생산성을 높일 수 있습니다. 
+ 프로그램이 해야 할 일들을 고수준에서 단게별로 명확하게 보여주는 선언적 스타일을 따르므로 코드 가독성이 향상됩니다. 
+ 무엇보다 중요한 건, HTML 객체와의 상호작용을 자체 함수로 빼내어 순수하지 않은(불순한) 로직을 순수함수에서 배제했다는 점입니다. 

아직은 느슨한 편이라 바짝 죄어야 할 부분이 남아 있긴 하지만, 부수효과를 줄임으로써 외부 조건 변화에 덜 취약한 프로그램이 되었습니다. find 함수를 자세히 보면 예외를 내는 별도의 null 체크 분기문이 포함되어 있습니다. 나중에 다시 언급하겠지만 이처럼 함수가 일관된 반환값을 보장하도록 해서 전체 함수 결고를 예측 가능한 방향으로 유도하면 여러모로 이롭습니다. 이것이 바로 **참조 투명성**이라는 순수함수 본연이 특징입니다. 

### 참조 투명성과 치환성

참조 투명성은 순수함수를 정의하는 좀 더 공식적인 방법이며, 여기서 **순수성**이란 함수의 인수와 결괏값 사이의 순수한 매핑 관계를 의미합니다. 따라서 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 **참조 투명한 ** 함수라고 합니다. 예컨대 좀 전에 보았던 increment는 상태적 함수로서 외부 변수 counter에 완전히 종속된 반환값을 내므로 참조 투명하지 않습니다. 코드를 다시 볼까요? 

```jsx
var counter = 0;

function increment() {
    return ++counter;
}
```

참조 투명한 함수로 만들려면 이 함수가 의존하는 상태, 즉 외부 변수를 제거하고 함수 서명에 정규 매개변수로 명시해야 합니다. 다음과 같이 ES6 람다 표현식으로 바꾸면 됩니다. 

```jsx
var increment = counter => counter + 1;
```

이제 increment는 같은 입력에 같은 결과를 반환하는 안전한 함수입니다. 그렇지 않으면 함수가 내는 반환값이 어떤 외부 요소의 영향을 받겠지요. 

이런 함수는 코드를 테스트하기 쉽고 **전체 로직을 파악**하는 것도 쉽습니다. 참조 투명성 혹은 **등식 정합성**은 수학에서 나온 용어지만 프로그래밍 언어의 함수는 수학 함수처럼 움직이지 않기 때문에 참조 투명성은 전적으로 개발자의 숙제로 남습니다. 아래의 코드는 increment 함수의 명령형 버전과 마법의 run 함수를 이용한 함수형 버전을 비교한 코드입니다. 

```jsx
// 명령형
increment();
increment();
print(counter); // -> 
// 이 값은 카운터의 초깃값에 의존하고 호출 도중 변경되면 값이 어떻게 변할지 알 수 없다. 

// 함수형
var plus2 = run(increment, increment);

print(plus2(0));
// 항상 초깃값을 2만큼 증가시킨다. 
```

> increment 함수의 명령형 버전과 함수형 버전의 작동 방식을 비교, 명령형 버전은 외부 변수 counter 값이 언제 어떻게 바뀔지 모르므로 반환값을 예측하기 어렵고 일관성이 없으므로 함수를 계속 호출하면 엉뚱한 결괏값이 나올 수 있습니다. 참조 투명한 함수형 버전은 항상 옳은 결과를 내며 에러 날 일이 없습니다. 

이런 식으로 구축한 프로그램은 시스템의 상태를 머릿속으로 그려볼 수 있고(멘털 모델) 코드를 **재작성**하거나 **치환**하더라도 원하는 결과를 얻을 수 있기 때문에 헤아리기가 쉽습니다. 좀 더 구체적으로 살펴볼까요? 주어진 입력을 처리해서 결과를 내는 일련의 함수들로 임의읭 프로그램을 정의한다고 합시다. 의사 형식으로 나타내면 이런 모습이겠죠. 

`Program = [Input] + [func1, func2, func3, ...] -> Output`

[func1, func2, func3 ...]이 모두 순수함수면 이들이 내는 결과를 바꾸지 않고 [val1, val2, val3, ...] 식으로 나열하여 프로그램을 쉽게 고칠 수 있습니다. 학생들 평균 점수를 계산하는 간단한 예제를 볼까요? 

```jsx
var input = [80, 90, 100];
var average = (arr) => divide(sum(arr), size(arr));
average(input); // -> 90
```

sum, size는 둘 다 참조 투명한 함수라서 이 표현식은 다음과 같이 입력값을 넣어 쉽게 바꿔 쓸 수 있습니다. 

```jsx
var average = divide(270, 3); // -> 90
```

divide는 100% 순수함수여서 수식으로 표기할 수도 있습니다. 그래서 평균은 항상 270 / 3 = 90이겠죠. 참조 투명성 덕분에 이렇게 체계적인, 거의 수학적인 형태로 프로그램을 헤아릴 수 있는 것입니다. 다음은 전체 프로그램입니다. 

```jsx
var sum = (total, current) => total + current;
var total = arr => arr.reduce(sum);
var size = arr => arr.length;
var divide = (a, b) => a / b;
var average = arr => divide(total(arr), size));
average(input); // -> 90
```

함수 인수를 전부 명확하게 정의하면 스칼라 값을 비롯해 대부분의 경우 부수효과를 예방할 수 있지만, 객체를 레퍼런스로 넘길 때 실수로 객체에 변이를 일으키지 않도록 주의해야 합니다. 

### 불변 데이터 유지하기

불변 데이터는 한번 생성된 후에는 절대 바뀌지 않습니다. 다른 언어도 그렇듯이 문자열, 숫자 등 자바스크립트의 모든 기본형(원시 자료형)은 처음부터 불변입니다. 그러나 배열 드으이 객체는 불변이 아니어서 함수 인수로 전달해도 원래 내용이 변경되어 부수효과가 발생할 소지는 남아 있습니다. 배열을 정렬하는 간단한 코드를 봅시다. 

```jsx
var sortDesc = arr => {
	arr.sort(
    	(a, b) => b - a
    );
};
```

얼핏 보기에 위 코드는 부수효과와 전혀 무관한, 좋은 코드 같습니다. 인수로 받은 배열의 원소를 내림차순으로 정렬한 뒤 그대로 반환하는 정해진 임무를 문제없이 완수합니다. 

```jsx
var arr = [1,2,3,4,5,6,7,8,9];
sortDesc(arr); // -> [9,8,7,6,5,4,3,2,1];
```

하지만 불행히도 상태적 함수인 Array.sort는 원본 래퍼런스가 가리키는 배열의 원소를 정렬하는 부수효과를 일으킵니다. 이는 언어 자체의 심각한 결함이기도 합니다. 

함수형 프로그래밍의 밑그림에 해당하는 기본 원리들(선언형, 순수, 불변)을 대략 엿보앗으니 이제 좀 더 간명하게 정의를 내리겠습니다. **함수형 프로그래밍은, 외부에서 관찰 가능한 부수 효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것입니다.** 

오늘날 자바스크립트 개발자가 직면한 문제의 원인은, 대부분 뚜렷한 체계 없이 분기 처리를 남발하고 외부 공유 변수에 지나치게 의존하는 덩치 큰 함수를 과용하는 데 있습니다. 안타깝지만 아직도 많은 자바스크립트 애플리케이션이 이런 딱한 상황에 처해 있고, 심지어 성공적이라는 작품조차 많은 파일이 한데 뒤섞여 추적/디버깅이 어려운 가변/전역 데이터를 공유하는 촘촘한 그물망이 형성된 경우가 있습니다. 

함수를 순수 연산의 관점에서 데이터를 절대 변경하지 않는 고정된 **작업 단위**로 바라본다면 확실히 잠재적인 버그는 줄게 될 것입니다. 함수형 프로그래밍을 코드에 도입해서 반드시 이익을 보려면, 복잡성을 극복하는 길로 안내하는 함수형 프로그래밍의 핵심 원리를 반드시 이해해야 합니다. 

