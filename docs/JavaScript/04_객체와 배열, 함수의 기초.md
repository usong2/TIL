# 04 객체와 배열, 함수의 기초

## 4.1 객체의 기초 ① 객체 리터럴

자바스크립트에서는 원시 타입을 제외한 모든 값이 객체입니다. 객체는 자바스크립트에서 가장 중요한 데이터 타입입니다. 객체는 객체 리터럴과 생성자로 생성할 수 있습니다. 

<br />

### 4.1.1 객체

객체는 이름과 값을 한 쌍으로 묶은 데이터를 여러 개로 모은 것입니다. 즉, 객체는 데이터 여러 개를 하나로 모은 복합 데이터로 **연관 배열** 또는 **사전**이라고도 부릅니다. 예를 들어 트럼프 카드를 표현하는 객체는 아래와 같이 설명할 수 있습니다. 

<table>
    <thead>
    	<tr>
        	<th>이름</th>
        	<th>값</th>
        </tr>
    </thead>
    <tbody>
    	<tr>
        	<td>suit</td>
        	<td>"하트"</td>
        </tr>
        <tr>
        	<td>rank</td>
        	<td>"A"</td>
        </tr>
    </tbody>
</table>

객체에 포함된 데이터 하나(이름과 값의 쌍)을 가리켜 객체의 **프로퍼티**라고 부릅니다. suit과 rank는 프로퍼티이며  프로퍼티의 이름 부분을 **프로퍼티 이름** 또는 **키**라고 부릅니다. 

자바스크립트로 객체를 생성하는 방법은 두 가지 입니다. 하나는 객체 리터럴을 사용하는 방법이고 나머지 하나는 생성라는 함수를 사용하는 방법입니다. 

<br />

### 4.2.1 객체 리터럴로 객체 생성하기

다음 코드는 트럼프 카드의 하트 , 정보를 객체 리터럴로 표현한 것입니다. 

```javascript
var card = { suit: "하트", rank: "A" };
```

{ ... } 부분이 바로 객체 리터럴이며, 객체 리터럴은 변수 card에 대입하고 있습니다. 프로퍼티 이름과 프로퍼티 값은 suit: "하트"처럼 콜론(:)을 사용하여 구분하며, 중괄호({}) 안에 있는 프로퍼티들은 쉼표(,)로 구분합니다. 프로퍼티 이름으로는 모든 식별자와 문자열 리터럴(빈 문자열도 사용 가능)을 사용할 수 있습니다. 즉, 앞 코드에 있는 프로퍼티 이름은 문자열로 바꾸어 작성할 수 있습니다. 

```javascript
var card = { "suit": "하트", 'rank': "A" };
```

프로퍼티 값에는 모든 데이터 타입의 값과 표현식을 대입할 수 있습니다. 

변수에 대입된 객체 안의 프로퍼티 값을 읽거나 쓸 때는 **마침표**(.) **연산자** 또는 **대괄호**([]) **연산자**를 사용합니다. 

```javascript
card.suit    // 하트
card["rank"] // A
```

여기에서 마침표 다음에 문자열이 붙어 있지 않다는 점과 대괄호 안이 문자열로 채워져 있다는 점을 주목하세요. 마침표로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름 즉, 식별자만 사용할 수 있습니다. 대괄호로 프로퍼티를 읽거나 쓸 때는 프로퍼티 이름 또는 문자열을 반환하는 표현식을 사용할 수 있습니다. 

객체가 없는 프로퍼티를 읽으려고 시도하면 undefined를 반환합니다. 

```javascript
card.color // undefined
```

선언되지 않은 변수를 읽으려고 시도하면 참조 오류가 발생하는 것과는 대조적입니다. 

객체 리터럴 안에 어떠한 프로퍼티도 작성하지 않으면 빈 객체가 생성됩니다. 

```javascript
var obj = {};
console.log(obj); // Object{}
```

<br />

### 4.1.3 프로퍼티 추가와 삭제

없는 프로퍼티 이름에 값을 대입하면 새로운 프로퍼티가 추가됩니다. 

```javascript
card.value = 14;
consoel.log(card) // Object {suit: "하트", rank: "A", value: 14}
```

delete 연산자를 사용하면 프로퍼티를 삭제할 수 있습니다. 

```javascript
delete card.rank;
console.log(card); // Object {suit: "하트", value: 14}
```

이처럼 자바스크립트의 객체는 실행 중에 프로퍼티를 자유롭게 추가하거나 삭제할 수 있습니다. 반면 Java와 C++ 등에서는 객체의 프로퍼티를 실행 중에 추가하거나 삭제할 수 없습니다. 

<br />

### 4.1.4 in 연산자로 프로퍼티가 있는지 확인하기

in 연산자를 사용하면 객체에 특정 프로퍼티가 있는지 확인할 수 있습니다. 코드를 다음과 같이 작성하면 프로퍼티가 객체에 포함되었을 때는 true를 반환하고 포함되지 않았을 때는 false를 반환합니다. 

```javascript
프로퍼티 이름을 뜻하는 문자열 in 객체명
```

<br />

```javascript
var card = { suit: "하트", rank: "A" };
console.log("suit" in card); // true
console.log("color" in card); // false
```

앞 코드에서 in 연산자가 조사하는 대상이 그 객체가 가진 프로퍼티와 그 객체가 상속받은 모든 프로퍼티라는 점을 주의합시다. 

원래 toString 프로퍼티는 card 객체 안에 없지만 다음 코드를 보면 toString 프로퍼티가 card에 있다는 결과가 나옵니다. 

```javascript
console.log("toString" in card) // true
```

이는 card가 Object 객체를 상속받았기 때문입니다. 

<br />

### 4.1.5 객체 리터럴 예제

객체 리터럴을 사용하는 몇 가지 예를 살펴보겠습니다. 

1. 좌표평면의 점을 표현하는 객체

   ```javascript
   var p = { x: 1.0, y: 2.5 };
   ```

2. 원을 표현하는 객체

   ```javascript
   var circle = {
       center: { x: 1.0, y: 2.0 }, // 원의 중심을 표현하는 객체
       radius: 2.5					// 원의 반지름
   }
   ```

   center 프로퍼티는 원의 중점을 표현하고 radius 프로퍼티는 원의 반지름을 표현합니다. center 프로퍼티의 값으로는 1에 등장한 좌표평면의 점을 표현하는 객체를 대입했습니다. 이처럼 객체의 프로퍼티 값으로 객체를 대입할 수 있습니다. 이때 원 중점의 x좌표는 다음 코드처럼 마침표 뒤에 프로퍼티 이름을 연결해서 표현할 수 있습니다. 

   ```javascript
   circle.center.x // 1.0
   ```

3. 회원 정보를 표현하는 객체

   ```javascript
   var person = {
       name: "초코송이",	// 회원 이름 
       age: 20			   // 나이
       sex: "여",		  // 성별
       married : false	  // 결혼 여부를 표현하는 논리값 
   }
   ```

<br />

### 4.1.6 메서드

프로퍼티에 저장된 값이 타입이 함수면 그 프로퍼티를 메서드라고 부릅니다. 

<br />

### 4.1.7 객체는 참조 타입

생성된 객체는 메모리의 영역을 차지하는 한 덩어리가 됩니다. 객체 타입의 값을 변수에 대입하면 그 변수에는 객체의 **참조**(메모리에서의 위치 정보)가 저장됩니다. 이때의 변수 상태를 가리켜 객체를 **참조하고 있다**라고 합니다. 

변수에 저장된 객체의 참조는 다른 원시 값과 마찬가지로 다른 변수에 저장할 수 있습니다. 

```javascript
var a = card;
```

그러면 변수 a가 card 객체를 참조하게 되므로 a로 card 객체를 읽거나 수정할 수 있습니다. 

```javascript
console.log(a.suit); // 하트
a.suit = "스페이드";
console.log(a.suit); // 스페이드
console.log(card.suit); // 스페이드
```

<br /><hr />

## 4.2 함수의 기초

함수는 자바스크립트 프로그래밍 언어를 규정하는 가장 중요한 구성 요소입니다. 

<br />

### 4.2.1 함수

수학에서의 함수는 주어진 입력 값 x에 대해 출력 값 y를 대응시키는 규칙입니다. 

함수의 이름을 f라고 할 때, 함수 값인 y는 f(x)라고 씁니다. 

자바스크립트에서의 함수는 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 둔 것입니다. 자바스크립트의 함수는 언뜻 보기에 수학 함수와 다르지 않습니다. 입력 값을 받으면 출력 값으로 함수 값을 반환합니다. 수학 함수와 다른 점이라면 입력을 받은 후에 함수 안의 프로그램에서 특정 작업을 수행한다는 점입니다. 자바스크립트에서는 함수의 입력 값을 **인수**라고 부르고 함수의 출력 값을 **변환값**이라고 부릅니다. 

<br />

### 4.2.2 함수 선언문으로 함수 정의하기

함수는 function 키워드를 사용해서 정의합니다. 예를 들어 다음은 square 함수를 정의하는 코드입니다. 

```javascript
function square(x) { return x * x; }
```

이 함수는 인수의 제곱을 계산해서 반환합니다. 이 코드에서는 소괄호 안에 있는 x가 인수고 중괄호 안에 있는 코드가 함수가 실행하는 작업입니다. 앞 코드에서 함수가 처리하는 내용은 다음의 return 문 뿐입니다. 

```javascript
return x * x;
```

> return문 다음에는 줄 바꿈 문자를 넣지 말 것
>
> > return과 값 사이에 줄 바꿈 문자를 넣으면 자바스크립트 엔진이 세미콜론을 자동으로 추가해서 해석합니다. 예를 들어 다음 코드를 살펴봅시다. 
> >
> > ```javascript
> > return
> > x * x;
> > ```
> >
> > 자바스크립트 엔진은 이 코드를 다음과 같이 해석합니다. 
> >
> > ```javascript
> > return;
> > x * x;
> > ```
> >
> > 즉, 값이 없는 return 문으로 해석합니다. 

return 문이 실행되면 제어권이 함수를 호출한 코드로 되돌아가고, return 문에 지정된 값(앞 코드에서는 x * x : x와 x의 곱)은 함수의 반환값이 됩니다. 

<br />

### 4.2.3 함수 이름

변수 이름과 마찬가지로 모든 식별자를 함수 이름으로 사용할 수 있습니다. 그러나 함수 이름은 해당 함수의 기능을 이해하기 쉽게 지어야 합니다. 함수에 이름을 잘 붙이면 그 함수가 어떤 일을 하는지 주석을 보지 않고도 파악할 수 있으므로 프로그램의 가독성과 유지 보수성이 크게 높아집니다. 함수 이름은 일반적으로 동사 또는 동사로 시작된느 어휘로 만듭니다. 이때 캐멀 표기법 또는 밑줄 표기법을 사용하세요. 

```javascript
function saveImage(img) {...}
function getMousePisition(event) {...}
function load_file() {...}
```

<br />

### 4.2.4 함수 호출

함수를 호출하려면 함수 이름 뒤에 소괄호로 인수를 묶어 입력합니다. 

```javascript
square(3)
```

그러면 인수로 넘긴 값인 3이 함수 정의문의 인수 x로 전달되고, 중괄호 안에 작성된 코드를 실행합니다. 결과적으로 return 문의 값인 9가 함수의 반환값이 됩니다. 이때 함수를 호출할 때 전달하는 값을 **인수**(argument), 함수 정의문의 인수를 **인자**(parameter)라고 부릅니다. 

<br />

### 4.2.5 인수

함수는 인수를 여러 개 받을 수 있습니다. 인수가 여러 개라면 인수와 인수를 쉼표(,)로 구분합니다. 예를 들어 다음 함수 dist는 두 점 사이의 거리를 구하는 함수입니다. 이때 전달하는 인수 p와 q는 좌표평면의 점 하나를 표현하는 객체이며, 각각의 객체는 {x:1, y:2}라는 구조를 갖고 있습니다. 

```javascript
function dist(p, q){
    var dx = q.x - p.x;
    var dy = q.y - q.y;
    return Math.sqrt(dx*dx+dy*dy);
}
```

이 코드에 등장하는 Math.sqrt는 제곱근을 구하는 함수입니다. 함수 dist를 사용하여 두 점 사이의 거리를 구하는 코드는 다음과 같습니다. 

```javascript
var p1 = {x:1, y:1};
var p2 = {x:4, y:5};
var d = dist(p1, p2); // 5
```

인수를 받지 않는 함수도 정의할 수 있습니다. 

```javascript
var bark = function() { console.log("Box-wow"); }
bark(); // "Bow-wow"
```

bark 함수에는 인수도 없고 return 문도 없습니다. return 문이 실행되지 않은 상태에서 제어권이 함수를 호출한 코드로 되돌아가면 함수의 반환값이 undefined가 됩니다. 

```javascript
console.log(bark()); // undefined
```

<br />

### 4.2.6 함수의 실행 흐름

일반적인 함수의 실행 흐름은 다음과 같습니다

+ 호출한 코드에 있는 인수가 함수 정의문의 인자에 대입된다. 
+ 함수 정의문의 중괄호 안에 작성된 프로그램이 순차적으로 실행된다. 
+ return 문이 실행되면 호출한 코드로 돌아간다. return 문의 값은 함수의 반환값이 된다. 
+ return 문이 실행되지 않은 상태로 마지막 문장이 실행되면, 호출한 코드로 돌아간 후에 undefined가 함수의 반환값이 된다. 

<br />

### 4.2.7 함수 선언문의 끌어올림

자바스크립트 엔진은 변수 선언문과 마찬가지로 함수 선언문을 프로그램의 첫머리로 끌어올립니다. 함수 선언문은 프로그램의 어떤 위치에도 작성할 수 있습니다. 예를 들어 다음과 같이 함수를 정의하기 전에 함수를 실행하는 코드를 작성해도 문제없이 동작합니다. 

``` javascript
console.log(square(5)) // 25
function square(x) { return x * x; }
```

<br />

### 4.2.8 값으로서의 함수

자바스크립트에서는 함수가 객체입니다. 함수 선언문으로 함수를 선언하면 내부적으로는 그 함수 이름을 변수 이름으로 한 변수와 함수 객체가 만들어지고, 그 변수에 함수 객체의 참조가 저장됩니다. 

변수 값을 다른 변수에 할당하면 그 변수 이름으로 함수를 실행할 수 있습니다. 

```javascript
var sq = square;
console.log(sq(5)); // 25
```

또한 함수를 다른 함수의 인수로 넘길 수도 있습니다. 

<br />

### 4.2.9 참조에 의한 호출과 값에 의한 호출

함수는 원시 값을 인수로 넘겼을 때와 객체를 인수로 넘겼을 때 다르게 동작합니다. 먼저 인수가 원시 값일 때 어떻게 동작하는지 예제를 살펴보겠습니다. 

```javascript
function add1(x) { return x = x + 1; }
var a = 3;
var b = add1(3)
console.log("a = " + a + ", b = " + b); // a = 3, b = 4
```

add1은 전달받은 인수에 1을 더하여 반환하는 함수입니다. 이 함수가 호출될 때 변수 a의 복사본이 인자 x에 할당됩니다. 즉, 인수에 원시 값을 넘기면 그 값 자체가 인자에 전달됩니다. 

이를 가리켜 **값의 전달**이라고 부릅니다. 이때 변수 a와 변수 x는 다른 영역의 메모리에 위치한 별개의 변수입니다. 따라서 x 값을 바꾸더라도 a 값은 바뀌지 않습니다. 

다음으로 인수가 객체일 때 어떻게 동작하는지 예제를 살펴보겠습니다. 

```javascript
function add1(p) { p.x = p.x + 1; p.y = p.y + 1; return p; }
var a = { x:3, y:4 };
var b = add1(a);
console.log(a, b); // Object {x=4, y=5} Object {x=4, y=5}
```

이번에 등장한 add1 함수는 2차원 좌표의 각 성분에 1을 더한 좌표를 반환하는 함수입니다. 함수가 호출될 대 변수 a의 복사본이 인자 p에 할당됩니다. 여기까지는 원시 값을 인수로 넘겼을 때와 동일하게 동작합니다. 그러나 이전과 다르게 변수 a에 객체 {x:3, y:4}의 참조가 저장되어 있으며, 이 참조 값을 인자 p에 대입합니다. 즉, 인수로 객체를 넘겼을 때 전달되는 값은 참조 값입니다. 이를 가리켜 참조 전달이라고 부릅니다. 이때 인자 p와 변수 a는 똑같은 객체를 참조하고 있습니다. 따라서 함수 안에서 p.x와 p.y를 수정하는 행위는 a.x와 a.y를 수정하는 행위와 같습니다. 이처럼 함수의 인수로 객체를 넘기면 함수 안에서 원래의 객체를 바꿀 수 있습니다. 

<br />

#### 인수 여러 개를 우아하게 전달하는 방법(Elegant way)

함수에 넘겨야 하는 인수 개수가 많아지면 다음과 같은 문제가 발생합니다. 

+ 인수의 순서를 착각하기 쉽다. 
+ 함수가 받는 인수 개수를 바꾸면 함수의 호출 방법이 바뀌므로 프로그램 전체를 수정해야 한다. 

<br />

객체의 프로퍼티에 인수를 담아서 넘기면 이러한 문제를 우아하게 해결할 수 있습니다. 

다음과 같은 인수가 많은 함수를 예로 들어 보겠습니다. 

```javascript
function setBallProperties(x, y, vx, vy, radius) { ... }
...
setBallProperties(0, 0, 10, 15, 5);
```

이 함수의 인수를 다음과 같이 객체의 프로퍼티에 담아서 함수에 넘기도록 고쳐 봅니다. 

```javascript
var parameters = {
    x: 0,
    y: 0,
    vx: 10, 
    vy: 15,
    radius: 5
}
```

이렇게 수정하면 함수의 인수를 하나만 받도록 만들 수 있습니다. 

```javascript
function setBallProperties(params) { ... }
...
setballProperties(parameters);
```

이때 함수 안에서 프로퍼티를 읽는 코드는 params, vx처럼 표현하면 되므로 인수 순서가 바뀌는 문제가 발생하지 않습니다. 또한 전달하는 인수를 추가하는 경우에도 프로퍼티만 추가하면 되므로 함수를 호출하는 방법을 바꿀 필요가 없습니다. 

```javascript
var parameters = {
    x: 0,
    y: 0, 
    vx: 10, 
    vy: 15,
    radius: 5,
    color: "blue"
};
setBallProperties(parameters);
```

단, 함수 안에서 객체의 프로퍼티를 수정하면 호출한 코드에 있는 인수 객체의 프로퍼티가 함께 바뀌므로 주의해야 합니다. 객체를 인수로 넘기면 함수에는 객체의 참조가 전달되기 때문입니다. 

<br />

### 4.2.10 변수의 유효 범위

#### 전역 유효 범위와 지역 유효 범위

변수에 접근할 수 있는 범위를 그 변수의 **유효 범위**(Scope)라고 합니다. 유효 범위를 결정하는 방법에는 두 가지가 있습니다. 하나는 프로그램의 구문만으로 유효 범위를 정하는 **어휘적 범위**(lexical scope)고 남은 하나는 프로그램 실행 중에 유효 범위를 정하는 **동적 범위**(dynamic scope)입니다. C나 Java 같은 대다수의 프로그래밍 언어와 마찬가지로 자바스크립트도 어휘적 범위를 채택하고 있습니다. 자바스크립트 변수는 변수의 유효 범위에 따라 두 가지로 나뉩니다. 하나는 **전역 변수**고 남은 하나는 **지역 변수**입니다. 

전역 변수는 함수 바깥에서 선언된 변수로 유효 범위가 전체 프로그램입니다. 지역 변수는 함수 안에서 선언된 변수와 함수 인자로 유효 범위는 변수가 선언된 함수 내부입니다. 예를 들면 다음과 같습니다. 

```javascript
var a = "global";
function f(){
    var b = "local";
    console.log(a); // global
    return b;
}
f();
console.log(b); // ReferenceError: b is not defined
```

위의 코드에 등장하는 변수 a는 전역 변수입니다. 전역 변수의 유효 범위는 전체 프로그램이므로 변수 a는 함수 f 내부에서도 유효합니다. 따라서 함수 f 안에서도 변수 a값을 읽거나 수정할 수 있습니다. 반면 변수 b는 함수 f 안에서만 유효한 지역 변수입니다. 따라서 함수 f 바깥에서 변수 b를 읽으려고 시도하면 참조 오류가 발생합니다.

<br />

#### 변수의 충돌

변수에 유효 범위가 있는 이유는 프로그램의 다른 부분에서 선언된 이름이 같은 변수와 충돌하지 않도록 하기 위해서입니다. 다른 함수 내부에서 선언된 각각의 지역 변수는 모두 선언된 함수 내부에서만 유효하므로 이름이 같아도 충돌하지 않습니다. 덕분에 함수 안에서 변수 이름을 지을 때는 다른 함수 안에서 사용하는 변수 이름까지 신경 쓸 필요가 없습니다. 

하지만 전역 변수 이름과 지역 변수 이름이 같아지면 두 변수가 충돌합니다. 이때는 전역 변수를 숨기고 지역 변수를 사용하게 됩니다. 예로 살펴봅시다. 

```javascript
var a = "global";
function f() {
    var a = "local";
    console.log(a); // local
    return a;
}
f();
console.log(a); // global
```

이 코드에는 함수 바깥에서 선언한 전역 변수 a와 함수 안에서 선언한 지역 변수 a가 등장합니다. 두 변수는 이름이 같지만 다른 위치의 메모리에 있는 별개의 변수입니다. 지역 변수 a의 유효 범위 안에서 전역 변수 a는 숨겨집니다. 따라서 첫 번째 console.log(a)의 출력은 local이 됩니다. 한편 함수 바깥은 지역 변수 a의 유효 범위를 벗어나므로 두 번째 console.log(a)의 출력은 global이 됩니다. 

<br />

#### 함수 안에서의 변수 선언과 끌어올림

함수 안에서 선언된 지역 변수의 유효 범위는 함수 전체입니다. 함수 중간 부분에서 변수를 선언하더라도 변수는 함수 첫머리에서 선언된 것처럼 함수 안의 다른 문장보다 먼저 생성됩니다. 즉, 자바스크립트 엔진은 함수 안의 변수 선언부를 함수의 첫머리로 끌어올립니다. 

```javascript
function f() {
    console.log(a); // undefined
    var a = "local";
    console.log(a); // local
    return a;
}
```

<br />

#### 함수 안에서의 변수 선언 생략

변수를 선언하지 않은 상태에서 값을 대입하면 전역 변수로 선언됩니다. 이 현상은 함수 바깥에서 발생하지만 함수 안에서도 발생합니다. 

```javascript
function f() {
    a = "local";
    console.log(a); // local
    return a;
}
f();
console.log(a); // local 
```

언뜻 보기에 변수 a는 함수 f의 지역 변수처럼 보이지만 var로 선언하지 않았으므로 실제로는 전역 변수입니다. 따라서 프로그램의 어느 위치에서도 사용할 수 있습니다. 

<br />

### 4.2.11 블록 유효 범위 : let과 const

'함수의 기초'에 해당하는 내용은 아니지만 변수의 유효 범위와 밀접한 관계가 있는 let과 const 선언자도 함께 살펴보겠습니다. let과 const는 ECMAScript 6부터 추가된 변수 선언자로 모두가 '블록 유효 범위'를 갖는 변수를 선언합니다. 블록 유효 범위를 가진 변수는 중괄호({}) 안에서만 유효합니다. let은 변수를 선언하고 const는 한 번만 할당할 수 있는 상수를 선언합니다. 

#### let 선언자

let 문은 블록 유효 범위를 갖는 지역 변수를 선언합니다. 사용법은 var 문과 같습니다. 

```javascript
let x;
```

변수가 여러 개일 때는 쉼표로 구분하여 동시에 선언할 수 있습니다. 

```javascript
let a, b, c;
```

변수를 선언하면서 초깃값을 설정할 수도 있습니다. 

```javascript
let x = 5, y = 7;
```

var로 선언한 변수와 let으로 선언한 변수의 가장 큰 차이점은 let으로 선언한 변수의 유효 범위가 블록 안이라는 점입니다. 다음 예를 살펴봅시다. 

```javascript
let x = "outer x";
{
    let x = "inner x";
    let y = "inner y";
    console.log(x); // inner x
    console.log(y); // inner y
}
console.log(x); // outer x
console.log(y); // ReferenceError: y is not defined
```

앞 코드에서 중괄호 바깥에 있는 변수 x의 유효 범위는 전체 프로그램이며, 안에 있는 변수 x의 유효 범위는 중괄호 안쪽입니다. 중괄호 안에 있는 변수 이름과 바깥에 있는 변수 이름이 같지만 중괄호 안에서는 중괄호 내부의 변수가 유효합니다. 또한 y의 유효 범위는 중괄호 안이므로 y를 함수 바깥에서 읽으려고 시도하면 참조 오류가 발생합니다. 

자바스크립트 엔진은 var 문과 달리 let 문으로 선언한 변수를 끌어올리지 않습니다. 

```javascript
console.log(x); // ReferenceError: x is not defined
let x = 5;
```

또한 let 문으로 똑같은 이름을 가진 변수를 선언하면 문법 오류가 발생합니다. 

```javascript
let x;
let x; // Uncaught SyntaxError
```

<br />

### const 선언자

const 문은 블록 유효 범위를 가지면서 한 번만 할당할 수 있는 변수(상수)를 선언합니다. const로 선언한 상수는 let 문으로 선언한 변수처럼 동작합니다. 단, 반드시 초기화해야 한다는 차이점이 있습니다. 

```javascript
const  = 2;
```

const 문으로 선언한 변수에 다시 대입을 시도하면 타입 오류가 발생합니다. 

```javascript
c = 5; // Uncaught TypeError
```

const 문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있습니다. 

```javascript
const origin = {x:1, y:2};
origin.x = 3;
console.log(origin); // Object {x:3, y:2}
```

<br />

### 4.2.12 함수 리터럴로 함수 정의하기

함수는 함수 리터럴로도 정의할 수 있습니다. 예를 들어 앞에서 예로 들었던 함수 square는 다음과 같이 함수 리터럴로 수정할 수 있습니다. 

```javascript
var square = function(x) { return x * x; }
```

이 코드에서 function(x) { ... } 부분이 함수 리터럴입니다. **함수 리터럴**은 이름이 없는 함수이므로 **익명 함수** 또는 **무명 함수**라고 부릅니다. 함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만 함수 리터럴을 사용할 때는 끝에 반드시 세미콜론을 붙여야 합니다. 

함수 선언문으로 정의한 함수와 함수 리터럴로 정의한 함수의 사용법은 같습니다. square(5)라고 작성하면 함수를  실행할 수 있습니다. 이는 함수 리터럴과 함수 선언문이 모두 내부적으로 square 변수에 함수 객체의 참조를 저장하기 때문입니다. 한 가지 차이점이라면 자바스크립트 엔진이 함수 선언문으로 정의한 함수는 끌어올리지만 함수 리터럴로 정의한 함수는 끌어올리지 않는다는 점입니다. 함수 리터럴로 정의한 익명 함수는 변수에 할당한 후에야 비로소 square라는 이름을 갖게 되고, 그 이름으로 호출할 수 있게 됩니다. 이러한 이유 때문에 함수를 정의하지 않은 상태에서 함수를 사용하려고 하면 타입 오류가 발생합니다. 

```javascript
console.log(square(3)); // TypeError: square is not a function
var square = function(x) { return x * x; };
```

익명 함수에도 이름을 붙일 수 있습니다. 

```javascript
var square = function sq(x) { return x * x; }
```

그러나 코드에서 sq라는 이름은 함수 안에서만 유효하므로 함수 바깥에서는 sq라는 이름으로 함수를 호출할 수 없습니다. 익명 함수 코드는 디버거에 모두 anonymous function이라고 표시되므로 함수를 구별할 수 없다는 단점이 있습니다. 단, 이름이 붙은 익명 함수는 어떤 함수인지 확인할 수 있습니다. 

<br />

### 4.2.13 객체의 메서드

객체의 프로퍼티 중에서도 함수 객체의 참조를 값으로 담고 있는 프로퍼티를 가리켜 메서드라고 부릅니다. 메서드를 정의할 때는 프로퍼티 값으로 함수 리터럴을 대입합니다.

예를 들어 원을 그리는 객체에 원의 넓이를 구하는 메서드인 area를 추가할 수 있습니다.

```javascript
var circle = {
    center: { x:1.0, y:2.0 },
    radius: 2.5, 
    area: function() {
        return Math.PI * this.radius * this.radius;
    }
};
```

함수 객체 안에 적힌 this는 그 함수를 메서드로 가지고 있는 객체를 가리킵니다. 위 코드에서는 circle을 가리킵니다. 즉, this.radius가 circle.radius입니다. 메서드는 일반 함수와 마찬가지로 소괄호를 붙여서 실행합니다. 

```javascript
circle.area() // 19.634954084936208
```

메서드 또한 프로퍼티의 일종이므로 나중에 추가할 수 있습니다. 예를 들어 지금 설명한 원을 표현하는 객체 circle에 원을 평행으로 이동시키는 translate 메서드를 추가할 수 있습니다. 

```javascript
circle.translate = function(a, b) {
    this.center.x = this.center.x + a;
    this.center.y = this.center.y + a;
}
```

이 메서드를 실행하면 다음과 같은 결과가 나옵니다. 

```javascript
circle.translate(1, 2);
circle.center; // Object {x=2, y=4}
```

이 예에서 알 수 있듯이 메서드는 일반적으로 메서드가 속한 객체의 내부 데이터(프로퍼티 값) 상태를 바꾸는 용도로 사용합니다. 일반적인 객체 지향 언어에서는 데이터와 그 상태를 바꾸는 메서드를 하나로 묶는 용도로 객체를 사용합니다. 

이러한 객체를 기본 부품으로 삼아 프로그램을 만들어 가는 기법을 가리켜 객체 지향 프로그래밍이라고 부릅니다. 

<br />

> **메서드는 프로퍼티**
>
> > C++나 Java 등의 객체 지향 언어에서는 객체 안의 데이터와 메서드를 별개로 다룹니다. 하지만 자바스크립트의 메서드는 함수를 값으로 가진 프로퍼티입니다. 단지 프로퍼티 값의 데이터 타입만 다를 뿐 객체 안의 데이터와 메서드가 모두 프로퍼티입니다. 따라서 자바스크립트에서 프로퍼티는 객체 내부의 데이터와 메서드를 모두 뜻합니다. 그래서 객체의 프로퍼티 목록을 열거하면 프로퍼티 값의 데이터 타입에 관계없이 모든 프로퍼티를 열거하는 것입니다. 기본적으로 함수가 저장된 프로퍼티를 포함한 모든 프로퍼티를 프로퍼티라고 부르지만, 상황에 따라서는 '프로퍼티와 메서드' 등으로 구분해서 설명할 때도 있습니다. 이때 프로퍼티는 함수를 값으로 가지고 있지 않은 프로퍼티를 뜻하며, 메서드는 함수를 값으로 가진 프로퍼티를 뜻합니다. 

<br />

### 4.2.14 함수를 활용하면 얻을 수 있는 장점

함수를 활용하면 다양한 효과를 기대할 수 있습니다. 

<br />

#### 재사용할 수 있다

똑같은 작업을 여러 번 반복해야 할 때 그 작업을 하나로 모아서 함수 하나로 만들어 두면, 함수 호출만으로 같은 작업을 여러 번 반복할 수 있습니다. 결과적으로 같은 코드를 여러 번 작성할 필요가 없어지므로 프로그램이 간결해집니다. 또한 같은 알고리즘을 사용하지만 시작 값이 다른 처리를 인수 값만 바꿔 호출하도록 수정하면 함수를 하나만 만들어 쓸 수 있습니다. 

<br />

#### 만든 프로그램을 이해하기 쉽다

함수를 사용하면 일정한 처리를 모아서 이름을 붙일 수 있습니다. 이는 함수 안에 상세한 내용을 숨기는 효과가 있습니다. 따라서 프로그램을 읽을 때 프로그램의 큰 흐름을 쉽게 파악할 수 있습니다. 

<br />

#### 프로그램 수정이 간단해진다

함수를 사용하지 않으면 똑같은 처리를 프로그램 곳곳에 작성해야 합니다. 처리 부분을 수정해야 한다면 같은 작업을 여러 번 반복해야 합니다. 그러나 함수로 정리해 두면 해당 함수만 수정하면 되므로 수정이 간단해집니다. 

<br />

<hr />
## 4.2 객체의 기초 ② 생성자

생성자를 사용하면 이름이 같은 메서드와 프로퍼티를 가진 객체 여러 개를 효율적으로 생성할 수 있습니다. 

<br />

### 4.3.1 생성자로 객체 생성하기

Java와 C++ 등은 같은 프로퍼티를 갖는 객체를 여러 개 생성하는 수단으로 클래스(class)를 제공합니다. 클래스는 **붕어빵 틀**에 비유할 수 있습니다. 붕어빵 틀을 사용하면 모양이 같은 붕어빵을 얼마든지 만들 수 있습니다. 

하지만 자바스크립트에는 클래스가 없습니다. 대신 생성자라고 하는 함수로 객체를 생성할 수 있습니다. 

<br />

#### 간단한 예

다음 코드는 트럼프 카드를 표현하는 객체를 생성하는 생성자입니다. 

```javascript
function Card(suit, rank) {
    this.suit = suit;
    this.rank = rank;
}
```

 생성자로 객체를 생성할 때는 **new 연산자**를 사용합니다. 

```javascript
var card = new Card("하트", "A");
```

이 코드를 실행하면 suit 프로퍼티에는 "하트", rank 프로퍼티에는 "A"라는 값이 저장된 객체가 생성되고, 마지막으로 그 객체의 참조가 변수 card에 할당됩니다.

```javascript
console.log(card); // Card {suit: "하트", rank: "A"}
```

이때 Card 생성자로 생성한 객체를 Card 객체라고 부릅니다. console.log로 객체를 출력하면 앞에 생성자 이름이 표시됩니다. 

<br />

#### 생성자

앞의 예처럼 new 연산자로 객체를 생성할 것이라 기대하고 만든 함수를 생성자라고 부릅니다. 생성자 이름은 관례적으로 그것이 생성자임을 알리기 위해 첫 글자를 대문자로 쓰는 파스칼 표기법을 사용합니다. 생성자 안에서 **this.프로퍼티 이름**에 값을 대입하면 그 이름을 가진 프로퍼티에 값이 할당된 객체가 생성됩니다. 이때 this는 생성자가 생성하는 객체를 가리킵니다. 앞의 예는 다음과 같이 객체 리터럴로 고쳐 쓸 수 있습니다. 

```javascript
var card = {};
card.suit = "하트";
card.rank = "A";
```

생성자와 new 연산자로 생선한 객체를 그 생성자의 인스턴스라고 부릅니다. 인스턴스에는 **실체**라는 뜻이 있습니다. 객체 지향 언어에서 인스턴스는 클래스로 생성한 실체를 뜻합니다. 이때 클래스는 객체를 실체로 만들기 위한 설계도고 그 설계도로 생성한 실체가 바로 인스턴스입니다. 자바스크립트에는 클래스가 없습니다. 생성자 자체가 함수 객체라는 실체입니다. 따라서 자바스크립트 생성자로 생성한 객체는 엄밀히 말해 인스턴스가 아닙니다. 하지만 생성자가 클래스처럼 객체를 생성하는 역할을 담당하고 있으므로 생성자로 생성한 객체도 인스턴스라고 부르는 것이 관례입니다. 

<br />

#### 생성자의 역할

생성자는 객체를 생성하고 초기화하는 역할을 합니다. 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체(인스턴스) 여러 개를 간단히 생성할 수 있습니다. 

다음 예제는 생성자 Card를 사용하여 트럼프 카드를 표현하는 객체를 생성하고 변수 여러 개에 저장합니다. 

```javascript
var card1 = new Card("하트", "A");
var card2 = new Card("클럽", "K");
var card3 = new Card("스페이드", "2");
```

이처럼 생성자를 사용하면 이름은 같지만 프로퍼티 값이 다른 객체 여러 개를 효율적으로 생성할 수 있습니다. 

생성자는 함수이므로 프로퍼티에 값을 대입할 수 있습니다. 다른 함수와 마찬가지로 다양한 처리를 할 수도 있습니다. 이를 활용하면 객체를 생성할 때 초기화 작업을 병행할 수 있습니다. 

```javascript
function Particle(x, y, vx, vy) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.velocity = Math.sqrt(vx * vx + vy * vy);
}
var p = new Particle(0, 0, 3, 4);
console.log(p); // Particle {x:0, y:0, vx:3, vy:4, velocity:5}
```

이 코드에서는 좌푯값(x, y)과 속도 벡터(vx, vy) 외에도 속도 velocity를 계산해서 프로퍼티에 추가합니다. 

<br />

### 4.3.2 메서드를 가진 객체를 생성하는 생성자

생성자에서 **this.프로퍼티 이름**에 함수의 참조를 대입하면 메서드를 정의할 수 있습니다. 이때 메서드 함수 안에 있는 this는 생성될 인스턴스를 가리킵니다. 

```javascript
function Circle(center, radius) {
    this.center = center;
    this.radius = radius;
    this.area = function() {
        return Math.PI * this.radius * this.radius;
    };
}
var p = {x:0, y:0};
var c = new Circle(p, 2.0);
console.log("넓이 = " + c.area()); // 넓이 = 12.566370614359172
```

메서드 함수 안에서 this를 사용하면 그 값이 인스턴스의 프로퍼티임을 명시할 수 있습니다. 

<br />

<hr />
## 4.2 객체의 기초 ③ 내장 객체

자바스크립트에는 처음부터 사용할 수 있는 내장 객체(빌트인 오브젝트)가 마련되어 있습니다. 내장 객체는 자바스크립트라는 프로그래밍 언어의 뼈대를 구성합니다. 

<br />

### 4.4.1 내장 생성자

자바스크립트에서 사용할 수 있는 생성자에는 사용자가 정의하는 생성자 외에도 자바스크립트에 처음부터 포함된 '내장 생성자' 가 있습니다. 

ECMAScript 5에서 사용할 수 있는 주요 내장 생성자는 아래의 표와 같습니다. 이 생성자는 자바스크립트 실행 환경에서 사용할 수 있습니다. 내장 생성자에는 이미 유용한 프로퍼티와 메서드가 마련되어 있으므로 내장 생성자를 이용하여 객체를 생성하면 다양한 작업을 쉽게 처리할 수 있습니다. 

<table>
    <thead>
    	<tr>
        	<th>생성자 이름</th>
        	<th>생성되는 객체</th>
        	<th>기타</th>
        </tr>
    </thead>
    <tbody>
    	<tr>
        	<td>Object</td>
        	<td>일반 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>String</td>
        	<td>문자열 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>Number</td>
        	<td>숫자 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>Boolean</td>
        	<td>논리값 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>Array</td>
        	<td>배열</td>
        	<td></td>
        </tr>
        <tr>
        	<td>Date</td>
        	<td>날짜와 시간을 다루는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>Function</td>
        	<td>함수 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>RegExp</td>
        	<td>정규 표현식 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>Error</td>
        	<td>오류 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>EvalError</td>
        	<td>eval() 함수와 관련된 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>InternalError</td>
        	<td>자바스크립트 내부에서 발생한 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>RangeError</td>
        	<td>값이 허용 범위를 넘었을 때 발생한 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>ReferenceError</td>
        	<td>없는 변수를 참조할 때 발생한 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>SyntaxError</td>
        	<td>문법이 어긋날 때 발생한 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>TypeError</td>
        	<td>값이 기대한 타입이 아닐 때 발생한 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
        <tr>
        	<td>URIError</td>
        	<td>잘못된 URI를 만났을 때 발생한 오류를 표현하는 객체</td>
        	<td></td>
        </tr>
    </tbody>
</table>

<br />

ECMAScript 6부터는 위의 표에 있는 생성자에 더해 아래의 표에 있는 생성자가 추가되었습니다. 

<table>
    <thead>
    	<tr>
        	<th>생성자 이름</th>
        	<th>생성되는 객체</th>
        	<th>기타</th>
        </tr>
    </thead>
    <tbody>
    	<tr>
        	<td>Symbol</td>
        	<td>심벌을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Int8Array8</td>
        	<td>부호가 있는 8비트 정수 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Unit8Array8</td>
        	<td>부호가 없는 8비트 정수 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Init16Array16</td>
        	<td>부호가 있는 16비트 정수 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Unit16Array16</td>
        	<td>부호가 없는 32비트 정수 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Init32Array32</td>
        	<td>부호가 있는 32비트 정수 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Unit32Array32</td>
        	<td>부호가 없는 32비트 정수 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Float32Array32</td>
        	<td>32비트 부동 소수점 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Float64Array64</td>
        	<td>64비트 부동소수점 배열을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>ArrayBuffer</td>
        	<td>고정 길이 이진 데이터 버퍼를 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>DateView</td>
        	<td>ArrayBuffer 데이터를 읽고 쓸 수 있는 수단을 제공</td>
            <td></td>
        </tr>
        <tr>
        	<td>Promise</td>
        	<td>처리 지연 및 비동기 처리를 관리하는 수단을 제공</td>
            <td></td>
        </tr>
        <tr>
        	<td>Generator</td>
        	<td>제네레이터 함수를 다룰 수 있는 수단을 제공</td>
            <td></td>
        </tr>
        <tr>
        	<td>GeneratorFunction</td>
        	<td>제네레이터 함수를 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Proxy</td>
        	<td>객체의 기본적인 동작을 재정의하는 기능을 제공</td>
            <td></td>
        </tr>
        <tr>
        	<td>Map</td>
        	<td>key/value 맵을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>Set</td>
        	<td>중복을 허용하지 않는 데이터 집합을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>WeakMap</td>
        	<td>약한 참조를 유지하는 key/value 맵을 생성</td>
            <td></td>
        </tr>
        <tr>
        	<td>WeakSet</td>
        	<td>약한 참조를 유지하는 고유한 데이터 집합을 생성</td>
            <td></td>
        </tr>
    </tbody>
</table>

