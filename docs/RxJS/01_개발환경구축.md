# 01. RxJS 소개와 개발 환경 구축

## 1.1 리액티브 프로그래밍이란?

사용자의 활동에 좀 더 즉각 반응하는 소프트웨어를 개발하려면 이벤트를 적절하게 처리해야 한다. 그런데 프로그래밍할 때 다뤄야 할 데이터 소스의 종류가 다양해지면서 이벤트 수는 점점 많아지고 있다. 즉, 요구사항은 이전과 비교했을 때 복잡하고 처리 방법은 좀 더 효율적이어야 한다는 문제를 해결해야 할 필요성이 생긴 것이다. RxJS는 방금 설명한 문제를 해결하는 방법의 하나인 리액티브 프로그래밍 패러다임이 이는 라이브러리다. 

리액티브 프로그래밍은 비동기 프로그래밍 패러다임의 하위 개념으로 이벤트나 배열 같은 데이터 스트림을 비동기로 처리해 변화에 유연하게 반응하는 프로그래밍 패러다임이라고 정의할 수 있다. 

위키백과 리액티브 프로그래밍에서 핵심 키워드를 소개한다.

+ 데이터 스트림(Data streams)
+ 변화의 전달(The propagation of change)

'데이터 스트림'은 말 그대로 데이터의 흐름이다. 보통 정적인 데이터 스트림은 배열을, 동적인 데이터 스트림은 이벤트 이미터를 뜻한다. 정적이든 동적이든 여러 개의 데이터 흐름이 존재할 수 있는데, 동적인 데이터 스트림의 예로는 마우스 클릭처럼  여러 번 발생할 수 있는 이벤트가 있다. 

'변화의 전달'은 데이터 스트림 안에서 어떤 값이 변했을 때의 전달이 바로 이루어지는 것을 뜻한다. 예를 들어 명령형 프로그래밍에서는 c = a + b를 실행한 후 a 값이 바뀐다면 a만 바뀔 뿐 c 값이 같이 바뀌지 않는다. 하지만 리액티브 프로그래밍은 a 값이 바뀌었을 때 바로 c 값도 변한다. 엑셀에서 특정 셀 값을 바꿨을 때 해당 셀을 이용하는 다른 셀 값도 같이 변하는 것과 같다. 즉, 리액티브 프로그래밍은 정적/동적인 데이터 흐름의 변화에 곧바로 반응하는 프로그램을 만드는 것이라고 할 수 있겠다.

그럼 리액티브 프로그래밍을 적용할 때는 무엇을 고려해야 할까? 이를 알아보려면 '리액티브 선언문'에서 말하는 '리액티브 시스템'의 개념을 살펴보는 것이 좋다. 예를 들어 100ms당 1개씩 값을 발행하는 데이터 스트림이 있을 때, 1개를 처리할 때 1초 이상의 시간이 걸린다고 생각해보자. 다음과 같은 부분을 고려해야 한다.

+ 이벤트 발생처럼 언제, 어떤 속도로 발생할지 모르는 데이터 흐름의 처리 속도가 느리다면 버퍼를 두어야 할 수 있다.
+ 버퍼를 두면 메모리가 얼마나 데이터를 수용할 수 있는가를 고려해야 한다.
+ '블로킹' 방식은 응답성이 나쁘다. 정적 데이터 스트림처럼 데이터 흐름을 직접 제어할 수 있다고 해도 처리할 때마다 1초씩 기다려야 다음 데이터를 요청할 수 있다.
+ '비동기/논블로킹' 방식은 '비동기 프로그래밍 패러다임'과 잘 맞는다. 100ms마다 발행하는 데이터를 전달하는 부분과 1초 동안 데이터를 처리하는 실행 부분이 다르므로 1초마다 변화를 확인할 수 있다.
+ 에러 처리 상황을 고려해야 한다. 에러가 발생했을 때 기본값으로 계산할 수 없음을 보여준다거나, 에러 메시지를 나타낸 후 이동 동작을 진행한다거나, 재시도하는 방법 등으로 응답성을 높일 수 있다.

이는 근본적으로 좋은 '응답성'을 유지하는 방법들이다.

리액티브 프로그래밍이 반드시 리액티브 시스템의 특징을 충족해야 하는 것은 아니다. 그런데도 예를 들면서 리액티브 시스템의 특징을 소개한 이유는 리액티브 시스템을 구성하는 도구 중 하나로 리액티브 프로그래밍을 사용할 때 가치를 극대화할 수 있기 때문이다.

## 1.2 RxJS

RxJS는 ReactiveX 프로젝트에서 출발한 리액티브 프로그래밍을 지원하는 자바스크립트 라이브러리다. 이벤트 스트림을 옵저버블이라는 객체로 표현한 후 비동기 이벤트 기반의 프로그램 작성을 돕는다. 이벤트 처리를 위한 API로 다양한 연산자를 제공하는 함수형 프로그래밍 기법도 도입되어 있다. 앞에서 소개한 리액티브 프로그래밍을 쉽게 해주는 장점이 있다.

### 1.2.1 RxJS의 역사

ReactiveX는 마이크로소프트 .NET의 'Reactive Extensions'에서 시작해서 발전해왔다. ReactiveX 프로젝트를 시작한 목적은 비동기 이벤트 기반의 프로그래밍을 쉽게 하려는 것이다. 이 때문에 선언형 방식의 LINQ 스타일 연산자를 제공했다. 'Reactive Extensions'에서는 ReactiveX를 다음처럼 설명한다.

> **풀링(Pulling)방식의 이터레이터 패턴을 사용하는 IEnumerable<T>IEnumerator<T>를 데이터 스트림을 구독하는 푸시(Pushing) 방식의 옵저버 패턴인 IObservable<T>/IObserver<T>로 전환한다.**

이렇게 시작한 라이브러리가 다양한 언어의 오픈 소스 라이브러리로 확장되면서 RxJS, RxJava 등의 라이브러리가 생긴 것이다.

현재 RxJS 라이브러리는 크게 RxJS 4와 RxJS 5+ (5, 6 포함)가 있다. GitHub에서 RxJS 4 관련 정보를 확인하면 Rx의 처음 이름인 Reactive-Extensions 아래 RxJS라는 이름으로 2012년에 최초 커밋이 있다. 라이선스 정보를 보면 마이크로소프트웨어에 저작권이 있음을 확인할 수 있다. RxJS 5는 ReactvieX 아래 rxjs라는 이름으로 2015년에 최초 커밋이 발생했음을 확인할 수 있다. 라이선스 정보를 보면 구글과 넷플릭스가 추가되어 있음을 알 수 있다.

RxJS 프로젝트는 벤 레시가 리드하고 있으며, 버전 6에서는 버전 5의 큰 틀은 유지하면서 단점을 개선하였고, 버전 7까지 고려한 큰 그림을 그리며 변화 중이다. 

인터넷 익스플로러 8과 같은 하위 브라우저 지원을 위해 RxJS 4를 사용할 때도 있다.

## 1.3 RxJS로 개발할 때 알아야할 것

RxJS를 사용하려면 당연히 RxJS 라이브러리를 설치해야 한다. 그 밖에도 함께 사용해야 할 자바스크립트 기반 개발 환경이 있다. 

+ Node.js v8.9.0 이상
+ npm v3.0.0 이상
+ Git v2.0.0 이상
+ RxJS v6.1.0

### 1.3.1 Node.js

Node.js는 자바스크립트 기반으로 네트워크 애플리케이션을 개발하는 플랫폼이다. 윈도우나 macOS에서는 공식 웹 사이트에서 설치 파일을 다운로드해 사용하면 Node.js를 손쉽게 설치할 수 있다. 리눅스는 NodeSource에서 제공하는 Node.js 버전별 설치 스크립트를 활용하면 된다.

### 1.3.2 npm

npm은 Node.js의 패키지 관리자다. 다른 사람들이 만든 Node.js 기반 코드 모음을 쉽게 설치하거나 공유해 사용할 수 있다. 이러한 코드 모음을 패키지 또는 모듈이라고 하며 package.json 안에 메타데이터를 담고 있다. 어떤 Node.js 프로젝트든 package.json을 알면 해당 프로젝트가 사용하는 모듈 목록을 쉽게 확인할 수 있다.

또한 package.json이 있는 디렉터리에서 npm install 명령을 실행하면 package.json에서 선언된 의존 모듈 목록을 분석해 node_modules라는 디렉터리 안에 의존 모듈들을 설치한다.

프로젝트에 다른 모듈을 추가하는 방법은 모든 프로젝트에 사용하도록 전역 범위에 설치하는 것과 해당 프로젝트에서만 사용하도록 로컬 범위에 설치하는 것으로 나눌 수 있다. 일반적으로는 CLI와 같이 실행할 수 있는 모듈은 주로 전역 범위에 설치하고 그 외 대부분은 로컬 범위에 설치한다. 

각 설치 명령은 다음과 같다.

```bash
# 전역 범위에 모듈 설치
$ npm install --global <모듈 이름>

# 로컬 범위 모듈 설치
$ npm install --save <모듈 이름>

# 로컬 범위에 개발용 모듈 설치
$ npm install --save-dev <모듈 이름>
```

전역 범위는 --global 옵션을 추가하고 로컬 범위는 --save 옵션을 추가하면 된다. 또한 앞에서 설명하지 않았던 방식으로 개발용 모듈 설치도 있다. 예를 들어 테스트용 모듈 등 개발할 때만 필요한 패키지를 설치할 때는 --save-dev 옵션을 추가해 설치한다. 전역 범위에 패키지를 설치하면 package.json에 따로 모듈 설치 기록이 추가되진 않는다. --save 옵션으로 설치하면 해당 모듈 이름이 package.json의 dependencies 항목에 추가되고, --save-dev 옵션으로 설치하면 해당 모듈 이름이 devDependencies 항목에 추가된다.

### 1.3.3 Git

Git은 리눅스를 만든 리누스 토르발스가 만든 버전 관리 시스템이다. GitHub에서 제공하는 예제 파일을 설치하고 환경을 설정하는 데 사용한다.

리눅스에서 Git을 설치할 때는 각 배포판의 패키지 관리 도구를 사용하여 설치한다. 페도라 혹은 센트OS에서는 yum 명령을 사용해서 설치한다.

```bash
$ sudo yum install git-all
```

우분투 등의 데비안 계열 배포판에서는 apt-get을 사용해서 설치한다.

```bash
$ sudo apt-get install git-all
```

윈도우나 macOS는 Git 공식 웹 사이트에서 설치 파일을 다운로드해서 설치할 수 있다. 

### 1.3.4 RxJS 4와 Rxjs 5+

RxJS 5.x 버전부터는 모듈화, 디버깅을 위한 콜스택 지원 등 더 나은 성능을 추구하고자 완전히 새로 만들었다. 그 결과 인터넷 익스플로러 8과 같은 오래된 브라우저의 지원을 종료했다. 인터넷 익스플로러 8과 같은 오래된 브라우저의 지원이 필요하다면 RxJS 4.x 버전 사용을 고려할 필요가 있다. 4.x 버전과 5.x 버전은 기본 개념을 공유하므로 대부분 비슷하지만 일부 다른 부분들이 존재하므로 개발할 때 주의가 필요하다.

인터넷 익스플로러 8과 같은 오래된 브라우저를 지원하기 위해 4.x 버전을 사용해야 한다면 4.x 버전이 제공하는 라이브러리 세트를 알아야 한다. 오래된 브라우저를 지원할 필요가 없다면 생략해도 좋다.

+ **rx.all.js**: 모든 연산자를 포함하는 라이브러리 세트
+ **rx.lite.js**: 필수 연산자만 포함해서 용량을 줄인 라이브러리 세트
+ **rx.core.js**: RxJS의 핵심 부분만 포함한 라이브러리 세트

필요에 따라 적절한 라이브러리 세트를 선택해야 한다. 참고로 파일 이름 중간에 'compat'이 붙으면 오래된 브라우저를 지원하는 폴리필을 포함한 버전이다. 대부분 rx.lite.js로 충분하지만 좀 더 많은 연산자가 필요하다면 RxJS 메인 라이브러리에서 필요한 연산자가 포함된 스크립트 파일을 찾은 후 추가해서 사용하면 된다.

4.x 버전의 라이브러리 종류를 간단히 정리해보면 아래와 같다.

| 구분               | 설명                                                         | 구성                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Complete Libraries | Scheduler, Disposables, Observable, Observer 등 핵심 구성 요소와 모든 연산자를 포함하지만 테스트 기능이 빠져 있다. | rx.all.js                                                    |
| Main Libraries     | rx.js는 Scheduler, Disposables, Observable, Observer를 포함하여 많은 핵심 구성 요소를 포함하며, 여기에 추가로 필요한 연산자를 조합해서 사용한다. | rx.js<br />rx.aggregates.js<br />rx.async.js<br />rx.binding.js<br />rx.coincidence.js<br />rx.experimental.js<br />rx.joinpatterns.js<br />rx.testing.js<br />rx.time.js<br />rx.virtualtime.js |
| Lite Libraries     | 경량화 버전으로 Scheduler, Disposables, Observable 및 Observer를 포함하여 핵심 구성 요소, 주로 사용하는 연산자들, 이벤트 브리지, 프로미스 등을 내장하고 있다. | rx.lite.js<br />rx.lite.extras.js                            |
| Core Libraries     | 자체적인 용도로 취소 구현만 필요할 때 rx.core.js를 사용하며 Disposables, Schedulers, Observer 및 Observable 등의 기본 요소만 포함되어 있다. | rx.core.js<br />rx.core.binding.js<br />rx.core.testing.js   |

이러한 라이브러리 종류를 좀 더 자세히 알려면 다음 GitHub 저장소(https://github.com/Reactive-Extensions/RxJS/tree/master/doc/libraries)를 참고하면 된다.

## 1.4 RxJS 개발 환경 설정하기

RxJS를 브라우저에서 사용하는 방법은 크게 두 가지로 나눌 수 있다. 하나는 직접 script 태그로 웹 페이지 안에 포함해서 전역 범위에서 RxJS를 사용하는 전통적인 방법이다. 다른 하나는 Node.js의 패키지 관리자 npm으로 RxJS를 설치하고 최근 많이 사용하는 브라우저리파이나 웹팩과 같은 모듈 번들러를 사용하는 방법이다. 

### 1.4.1 script 태그로 RxJS 사용하기

6.x 버전의 RxJS를 script 태그로 추가할 때는 다음처럼 알려진 CDN을 이용하면 편리하다.

```html
<script src="https://unpkg.com/rxjs/bundles/rxjs.umd.min.js"></script>
```

window에 rxjs라는 객체가 주입되어 rxjs라는 이름으로 RxJS 요소들에 접근할 수 있다.

4.x 버전과 5.x 버전에서는 Rx.Observable처럼 Rx라는 네임스페이스를 기준으로 RxJS 요소들에 접근할 수 있다. 다음 CDN 주소를 사용할 수 있다.

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.3.0/Rx.min.js"></script>
```

all 버전을 기준으로 RxJS v4.x.x를 script 태그로 추가하는 방법은 다음과 같다.

```html
<script src="https://cdn.js/cloudflare/com/ajax/libs/rxjs/4.1.0/rx.all.min.js"></script>
```

### 1.4.2 모듈 번들러로 RxJS 사용하기

RxJS를 브라우저에서 사용하는 또 한 가지 방법은 모듈 번들러를 사용하는 것이다. 모듈 번들러의 동작 방식을 간단하게 설명하면 다음과 같다.

+ 모듈(예를 들면 CommonJS 프로젝트)을 사용해서 프론트엔드 코드를 작성한다.
+ 시작점(Entry Point)이 되는 자바스크립트 파일을 지정한다.
+ 모듈 번들러(module bundler)는 시작점에서 모듈과 관련된 부분을 분석해서 하나의 자바스크립트 파일로 번들링해준다.

이러한 방식은 최근 프론트엔드 개발에서 당연하다고 여길 정도로 보편화된 방법이다. Node.js의 강력한 패키지 관리 도구인 npm을 이용해서 패키지를 관리할 수 있고, 번들링 과정에서 모듈화된 자바스크립트 파일을 압축하는 등 부가 작업도 할 수 있다. 그러므로 프론트엔드 개발을 한다면 모듈 번들러 사용 방법을 반드시 이해할 필요가 있다.

#### 기본적인 모듈 번들러 사용법

```bash
# RxJS v6 설치
$ npm install --save rxjs
```

RxJS를 설치했다면 Node.js 백엔드 코드처럼 모듈 작성 방식으로 RxJS 코드를 작성하면 된다. 즉, 다음처럼 require 함수를 사용한다.

```jsx
// RxJS 모듈 가져오기
const { range } = require('rxjs');

range(1, 10)
// ...
```

Node.js에서 require 함수와 module.exports(또는 exports)로 모듈을 가져오고 내보낼 때는 주로 CommonJS 프로젝트에서 제시하는 방식을 사용한다. 이 방식은 Node.js처럼 의존 모듈들이 로컬에 존재해서 매우 직관적이고 단순한 문법으로 모듈을 불러오거나 내보낼 수 있다. 하지만 브라우저에서는 의존 모듈들을 로컬에서 불러올 수 있는 상황이 아니므로 CommonJS 방식을 바로 사용하기가 어렵다. 이를 극복하기 위해 시작점이 되는 파일에서 CommonJS 방식을 사용한 모듈들을 분석한 후 하나의 자바스크립트 파일로 병합해주는 '모듈 번들러'가 등장했다. 대표적인 라이브러리로 앞에서 소개한 브라우저리파이와 웹팩이 있다.

여기에서는 웹팩으로 모듈을 번들링하는 방법을 간단하게 살펴보겠다. 먼저 덧셈을 하는 add 함수를 포함한 모듈이 있는 math.js를 만들자.

```jsx
// math.js
function add(a, b) {
    return a + b;
}

exports.add = add;
```

정말 단순하게 덧셈만 실행하는 add 함수가 exports 키워드로 모듈 외부에 노출되는 것을 볼 수 있다. CommonJS 방식은 모듈마다 독립적인 범위가 보장된다. 즉, 모듈 안에 선언한 변수나 함수는 모듈 외부에서 사용할 수 없다. 모듈 외부에서 참조하려면 exports의 멤버로 노출해야 하는 것이다.

이제 math.js의 add 함수를 불러와 덧셈을 실제로 실행하는 프로그램을 작성해보자.

```jsx
// entrypoints.js
const math = require('./math');

console.log('1 + 2 = ', math.add(1, 2));
```

require 함수를 사용하면 다른 모듈을 불러올 수 있다. 지금처럼 직접 작성한 모듈은 모듈 파일의 경로를 꼭 입력해주어야 한다. 확장자는 기본적으로 .js라고 가정하므로 일반적으로 생략한다. 경로는 require를 실행하는 파일을 기준으로 한 상대 경로다. 직접 작성한 모듈이 아니라 npm으로 설치해 node_mojdules 디렉터리 아래에 있는 모듈이라면 별다른 경로 지정 없이 바로 모듈 이름을 쓰면 된다.

이제 웹팩을 사용해 모듈화된 2개의 파일을 하나의 파일로 번들링해보자. 먼저 다음 명령을 입력해 웹팩을 설치하자. --global 옵션을 설정하면 CLI에서도 사용할 수 있다.

```bash
$ npm install webpack webpack-cli --global
```

다음으로 시작점이 되는 파일을 지정하면 웹팩이 모듈 관계를 알아서 분석한 후 파일 하나로 번들링해준다.

```bash
$ webpack entrypoint.js 

Hash: 3f4330f3ea728925ec4d
Version: webpack 3.6.0
Time: 56ms
	Asset	Size	Chunks		Chunk Names
bundle.js  2.69KB	0 [emitted]	  main
  [0] ./entrypoints.js 73 bytes {0} [built]
  [1] ./math.js 63 bytes {0} [built]
```

첫 번째로 시작점이 될 파일인 entrypoints.js를 지정했고, 두 번째로 번들링한 결과 파일의 이름을 bundle.js로 지정했다. bundle.js의 내용 일부를 살펴보면 파일 2개 내용이 파일 하나로 합해져 있음을 알 수 있다.

```js
/**********************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, _webpack_require_) {
    const math = _webpack_require(1);
    console.log('1 + 2 = ', math.add(1, 2));
    
/***/ }),
/* 1 */
/***/ (function(module, exports) {

function add(a, b) {
    return a + b;
}
exports.add = add;
    
/***/ })
/******/ ]);
```

브라우저에서는 이렇게 합한 bundle.js를 script 태그로 추가해서 사용할 수 있다.

```html
<script src="bundle.js"></script>
```

